"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main-app",{

/***/ "(app-pages-browser)/../node_modules/next/dist/client/app-index.js":
/*!*****************************************************!*\
  !*** ../node_modules/next/dist/client/app-index.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hydrate\", ({\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js\");\n__webpack_require__(/*! ./app-globals */ \"(app-pages-browser)/../node_modules/next/dist/client/app-globals.js\");\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react-dom/client.js\"));\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _client1 = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(app-pages-browser)/../node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _errorboundarycallbacks = __webpack_require__(/*! ./react-client-callbacks/error-boundary-callbacks */ \"(app-pages-browser)/../node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\");\nconst _appcallserver = __webpack_require__(/*! ./app-call-server */ \"(app-pages-browser)/../node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ./app-find-source-map-url */ \"(app-pages-browser)/../node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterinstance = __webpack_require__(/*! ./components/app-router-instance */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-instance.js\");\nconst _approuter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./components/app-router */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router.js\"));\nconst _createinitialrouterstate = __webpack_require__(/*! ./components/router-reducer/create-initial-router-state */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _appbuildid = __webpack_require__(/*! ./app-build-id */ \"(app-pages-browser)/../node_modules/next/dist/client/app-build-id.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ./flight-data-helpers */ \"(app-pages-browser)/../node_modules/next/dist/client/flight-data-helpers.js\");\n/// <reference types=\"react-dom/experimental\" />\nconst createFromReadableStream = _client1.createFromReadableStream;\nconst createFromFetch = _client1.createFromFetch;\nconst appElement = document;\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    } else if (seg[0] === 3) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        // Decode the base64 string back to binary data.\n        const binaryString = atob(seg[1]);\n        const decodedChunk = new Uint8Array(binaryString.length);\n        for(var i = 0; i < binaryString.length; i++){\n            decodedChunk[i] = binaryString.charCodeAt(i);\n        }\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(decodedChunk);\n        } else {\n            initialServerDataBuffer.push(decodedChunk);\n        }\n    }\n}\nfunction isStreamErrorOrUnfinished(ctr) {\n    // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n    return ctr.desiredSize === null || ctr.desiredSize < 0;\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val);\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            if (isStreamErrorOrUnfinished(ctr)) {\n                ctr.error(Object.defineProperty(new Error('The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E117\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            } else {\n                ctr.close();\n            }\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n_c = DOMContentLoaded;\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n} else {\n    // Delayed in marco task to ensure it's executed later than hydration\n    setTimeout(DOMContentLoaded);\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\n// Consume all buffered chunks and clear the global data array right after to release memory.\n// Otherwise it will be retained indefinitely.\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.length = 0;\n// Patch its push method so subsequent chunks are handled (but not actually pushed to the array).\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nconst readable = new ReadableStream({\n    start (controller) {\n        nextServerDataRegisterWriter(controller);\n    }\n});\nif (true) {\n    // @ts-expect-error\n    readable.name = 'hydration';\n}\nlet debugChannel;\nif (false) {}\nconst clientResumeFetch = window.__NEXT_CLIENT_RESUME;\nlet initialServerResponse;\nif (clientResumeFetch) {\n    initialServerResponse = Promise.resolve(createFromFetch(clientResumeFetch, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel\n    })).then(async (fallbackInitialRSCPayload)=>(0, _flightdatahelpers.createInitialRSCPayloadFromFallbackPrerender)(await clientResumeFetch, fallbackInitialRSCPayload));\n} else {\n    initialServerResponse = createFromReadableStream(readable, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel,\n        startTime: 0\n    });\n}\nfunction ServerRoot({ initialRSCPayload, actionQueue, webSocket, staticIndicatorState }) {\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuter.default, {\n        actionQueue: actionQueue,\n        globalErrorState: initialRSCPayload.G,\n        webSocket: webSocket,\n        staticIndicatorState: staticIndicatorState\n    });\n    if ( true && initialRSCPayload.m) {\n        // We provide missing slot information in a context provider only during development\n        // as we log some additional information about the missing slots in the console.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {\n            value: initialRSCPayload.m,\n            children: router\n        });\n    }\n    return router;\n}\n_c1 = ServerRoot;\nconst StrictModeIfEnabled =  true ? _react.default.StrictMode : 0;\nfunction Root({ children }) {\n    if (false) {}\n    return children;\n}\n_c2 = Root;\nconst enableTransitionIndicator = false;\nfunction noDefaultTransitionIndicator() {\n    return ()=>{};\n}\nconst reactRootOptions = {\n    onDefaultTransitionIndicator: enableTransitionIndicator ? undefined : noDefaultTransitionIndicator,\n    onRecoverableError: _onrecoverableerror.onRecoverableError,\n    onCaughtError: _errorboundarycallbacks.onCaughtError,\n    onUncaughtError: _errorboundarycallbacks.onUncaughtError\n};\nasync function hydrate(instrumentationHooks, assetPrefix) {\n    let staticIndicatorState;\n    let webSocket;\n    if (true) {\n        const { createWebSocket } = __webpack_require__(/*! ./dev/hot-reloader/app/web-socket */ \"(app-pages-browser)/../node_modules/next/dist/client/dev/hot-reloader/app/web-socket.js\");\n        staticIndicatorState = {\n            pathname: null,\n            appIsrManifest: null\n        };\n        webSocket = createWebSocket(assetPrefix, staticIndicatorState);\n    }\n    const initialRSCPayload = await initialServerResponse;\n    // setAppBuildId should be called only once, during JS initialization\n    // and before any components have hydrated.\n    (0, _appbuildid.setAppBuildId)(initialRSCPayload.b);\n    const initialTimestamp = Date.now();\n    const actionQueue = (0, _approuterinstance.createMutableActionQueue)((0, _createinitialrouterstate.createInitialRouterState)({\n        navigatedAt: initialTimestamp,\n        initialFlightData: initialRSCPayload.f,\n        initialCanonicalUrlParts: initialRSCPayload.c,\n        initialRenderedSearch: initialRSCPayload.q,\n        location: window.location\n    }), instrumentationHooks);\n    const reactEl = /*#__PURE__*/ (0, _jsxruntime.jsx)(StrictModeIfEnabled, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n            value: {\n                appDir: true\n            },\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ServerRoot, {\n                    initialRSCPayload: initialRSCPayload,\n                    actionQueue: actionQueue,\n                    webSocket: webSocket,\n                    staticIndicatorState: staticIndicatorState\n                })\n            })\n        })\n    });\n    if (document.documentElement.id === '__next_error__') {\n        let element = reactEl;\n        // Server rendering failed, fall back to client-side rendering\n        if (true) {\n            const { RootLevelDevOverlayElement } = __webpack_require__(/*! ../next-devtools/userspace/app/client-entry */ \"(app-pages-browser)/../node_modules/next/dist/next-devtools/userspace/app/client-entry.js\");\n            // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n            element = /*#__PURE__*/ (0, _jsxruntime.jsx)(RootLevelDevOverlayElement, {\n                children: element\n            });\n        }\n        _client.default.createRoot(appElement, reactRootOptions).render(element);\n    } else {\n        _react.default.startTransition(()=>{\n            _client.default.hydrateRoot(appElement, reactEl, {\n                ...reactRootOptions,\n                formState: initialFormStateData\n            });\n        });\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const { linkGc } = __webpack_require__(/*! ./app-link-gc */ \"(app-pages-browser)/../node_modules/next/dist/client/app-link-gc.js\");\n        linkGc();\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"DOMContentLoaded\");\n$RefreshReg$(_c1, \"ServerRoot\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hcHAtaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0FzU3NCQTs7O2VBQUFBOzs7OztvQkF0U2Y7NkVBQ29COzRFQUNUO3FDQU1YOzZEQUM0QjtnREFDQTtvREFJNUI7MkNBQ29CO2lEQUNNOytDQUkxQjtnRkFDZTtzREFFbUI7MkRBQ047d0NBQ0w7K0NBRStCO0FBRTdELGdEQUFnRDtBQUVoRCxNQUFNQywyQkFDSkMsU0FBQUEsd0JBQStCO0FBQ2pDLE1BQU1DLGtCQUNKQyxTQUFBQSxlQUFzQjtBQUV4QixNQUFNQyxhQUFxQ0M7QUFFM0MsTUFBTUMsVUFBVSxJQUFJQztBQUVwQixJQUFJQywwQkFBK0RDO0FBQ25FLElBQUlDLDBCQUNGRDtBQUNGLElBQUlFLDBCQUEwQjtBQUM5QixJQUFJQywyQkFBMkI7QUFFL0IsSUFBSUMsdUJBQW1DO0FBdUJ2QyxTQUFTQyx1QkFBdUJDLEdBQWtCO0lBQ2hELElBQUlBLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUNoQlAsMEJBQTBCLEVBQUU7SUFDOUIsT0FBTyxJQUFJTyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUc7UUFDdkIsSUFBSSxDQUFDUCx5QkFDSCxNQUFNLHFCQUE4RCxDQUE5RCxJQUFJUSxNQUFNLHNEQUFWO21CQUFBO3dCQUFBOzBCQUFBO1FBQTZEO1FBRXJFLElBQUlOLHlCQUF5QjtZQUMzQkEsd0JBQXdCTyxPQUFPLENBQUNYLFFBQVFZLE1BQU0sQ0FBQ0gsR0FBRyxDQUFDLEVBQUU7UUFDdkQsT0FBTztZQUNMUCx3QkFBd0JXLElBQUksQ0FBQ0osR0FBRyxDQUFDLEVBQUU7UUFDckM7SUFDRixPQUFPLElBQUlBLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUN2QkYsdUJBQXVCRSxHQUFHLENBQUMsRUFBRTtJQUMvQixPQUFPLElBQUlBLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUN2QixJQUFJ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RSxVQUFBQSxXQUFBQSxHQUNFLHFCQUFDQyw0QkFBQUE7MEJBQTRCRDs7UUFFakM7UUFFQUUsUUFBQUEsT0FBYyxDQUFDQyxVQUFVLENBQUM1SCxZQUFZMkYsa0JBQWtCa0MsTUFBTSxDQUFDSjtJQUNqRSxPQUFPO1FBQ0w3QyxPQUFBQSxPQUFLLENBQUNrRCxlQUFlLENBQUM7WUFDcEJILFFBQUFBLE9BQWMsQ0FBQ0ksV0FBVyxDQUFDL0gsWUFBWW1ILFNBQVM7Z0JBQzlDLEdBQUd4QixnQkFBZ0I7Z0JBQ25CcUMsV0FBV3ZIO1lBQ2I7UUFDRjtJQUNGO0lBRUEseUVBQXlFO0lBQ3pFLElBN1BGLElBNlAwQixFQUFtQjtRQUN6QyxNQUFNLEVBQUV3SCxNQUFNLEVBQUUsR0FDZC9FLG1CQUFPQSxDQUFDLDBGQUFlO1FBQ3pCK0U7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdml0YWxpeXVsaXRvdnNreS9kZXYvc3JjL2NsaWVudC9hcHAtaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9hcHAtZ2xvYmFscydcbmltcG9ydCBSZWFjdERPTUNsaWVudCBmcm9tICdyZWFjdC1kb20vY2xpZW50J1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuLy8gVE9ETzogRXhwbGljaXRseSBpbXBvcnQgZnJvbSBjbGllbnQuYnJvd3NlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuaW1wb3J0IHtcbiAgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIGFzIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbUJyb3dzZXIsXG4gIGNyZWF0ZUZyb21GZXRjaCBhcyBjcmVhdGVGcm9tRmV0Y2hCcm93c2VyLFxufSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IG9uUmVjb3ZlcmFibGVFcnJvciB9IGZyb20gJy4vcmVhY3QtY2xpZW50LWNhbGxiYWNrcy9vbi1yZWNvdmVyYWJsZS1lcnJvcidcbmltcG9ydCB7XG4gIG9uQ2F1Z2h0RXJyb3IsXG4gIG9uVW5jYXVnaHRFcnJvcixcbn0gZnJvbSAnLi9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL2Vycm9yLWJvdW5kYXJ5LWNhbGxiYWNrcydcbmltcG9ydCB7IGNhbGxTZXJ2ZXIgfSBmcm9tICcuL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuL2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsJ1xuaW1wb3J0IHtcbiAgdHlwZSBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSxcbiAgY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlLFxufSBmcm9tICcuL2NvbXBvbmVudHMvYXBwLXJvdXRlci1pbnN0YW5jZSdcbmltcG9ydCBBcHBSb3V0ZXIgZnJvbSAnLi9jb21wb25lbnRzL2FwcC1yb3V0ZXInXG5pbXBvcnQgdHlwZSB7IEluaXRpYWxSU0NQYXlsb2FkIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLXR5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIH0gZnJvbSAnLi9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZSdcbmltcG9ydCB7IE1pc3NpbmdTbG90Q29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgc2V0QXBwQnVpbGRJZCB9IGZyb20gJy4vYXBwLWJ1aWxkLWlkJ1xuaW1wb3J0IHR5cGUgeyBTdGF0aWNJbmRpY2F0b3JTdGF0ZSB9IGZyb20gJy4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCdcbmltcG9ydCB7IGNyZWF0ZUluaXRpYWxSU0NQYXlsb2FkRnJvbUZhbGxiYWNrUHJlcmVuZGVyIH0gZnJvbSAnLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0LWRvbS9leHBlcmltZW50YWxcIiAvPlxuXG5jb25zdCBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gPVxuICBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIGFzICh0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmJyb3dzZXInKSlbJ2NyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSddXG5jb25zdCBjcmVhdGVGcm9tRmV0Y2ggPVxuICBjcmVhdGVGcm9tRmV0Y2hCcm93c2VyIGFzICh0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmJyb3dzZXInKSlbJ2NyZWF0ZUZyb21GZXRjaCddXG5cbmNvbnN0IGFwcEVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgRG9jdW1lbnQgPSBkb2N1bWVudFxuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyOiAoc3RyaW5nIHwgVWludDhBcnJheSlbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHwgdW5kZWZpbmVkID1cbiAgdW5kZWZpbmVkXG5sZXQgaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQgPSBmYWxzZVxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCA9IGZhbHNlXG5cbmxldCBpbml0aWFsRm9ybVN0YXRlRGF0YTogbnVsbCB8IGFueSA9IG51bGxcblxudHlwZSBGbGlnaHRTZWdtZW50ID1cbiAgfCBbaXNCb290U3RyYXA6IDBdXG4gIHwgW2lzTm90Qm9vdHN0cmFwOiAxLCByZXNwb25zZVBhcnRpYWw6IHN0cmluZ11cbiAgfCBbaXNGb3JtU3RhdGU6IDIsIGZvcm1TdGF0ZTogYW55XVxuICB8IFtpc0JpbmFyeTogMywgcmVzcG9uc2VCYXNlNjRQYXJ0aWFsOiBzdHJpbmddXG5cbnR5cGUgTmV4dEZsaWdodCA9IE9taXQ8QXJyYXk8RmxpZ2h0U2VnbWVudD4sICdwdXNoJz4gJiB7XG4gIHB1c2g6IChzZWc6IEZsaWdodFNlZ21lbnQpID0+IHZvaWRcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBJZiB5b3UncmUgd29ya2luZyBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgLyoqXG4gICAgICogcmVxdWVzdCBJRCwgZGV2LW9ubHlcbiAgICAgKi9cbiAgICBfX25leHRfcj86IHN0cmluZ1xuICAgIF9fbmV4dF9mOiBOZXh0RmxpZ2h0XG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dFNlcnZlckRhdGFDYWxsYmFjayhzZWc6IEZsaWdodFNlZ21lbnQpOiB2b2lkIHtcbiAgaWYgKHNlZ1swXSA9PT0gMCkge1xuICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyID0gW11cbiAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDEpIHtcbiAgICBpZiAoIWluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNlcnZlciBkYXRhOiBtaXNzaW5nIGJvb3RzdHJhcCBzY3JpcHQuJylcblxuICAgIGlmIChpbml0aWFsU2VydmVyRGF0YVdyaXRlcikge1xuICAgICAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShzZWdbMV0pKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlci5wdXNoKHNlZ1sxXSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VnWzBdID09PSAyKSB7XG4gICAgaW5pdGlhbEZvcm1TdGF0ZURhdGEgPSBzZWdbMV1cbiAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDMpIHtcbiAgICBpZiAoIWluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNlcnZlciBkYXRhOiBtaXNzaW5nIGJvb3RzdHJhcCBzY3JpcHQuJylcblxuICAgIC8vIERlY29kZSB0aGUgYmFzZTY0IHN0cmluZyBiYWNrIHRvIGJpbmFyeSBkYXRhLlxuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2Ioc2VnWzFdKVxuICAgIGNvbnN0IGRlY29kZWRDaHVuayA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlY29kZWRDaHVua1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpXG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyKSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5lbnF1ZXVlKGRlY29kZWRDaHVuaylcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIucHVzaChkZWNvZGVkQ2h1bmspXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFtRXJyb3JPclVuZmluaXNoZWQoY3RyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSB7XG4gIC8vIElmIGBkZXNpcmVkU2l6ZWAgaXMgbnVsbCwgaXQgbWVhbnMgdGhlIHN0cmVhbSBpcyBjbG9zZWQgb3IgZXJyb3JlZC4gSWYgaXQgaXMgbG93ZXIgdGhhbiAwLCB0aGUgc3RyZWFtIGlzIHN0aWxsIHVuZmluaXNoZWQuXG4gIHJldHVybiBjdHIuZGVzaXJlZFNpemUgPT09IG51bGwgfHwgY3RyLmRlc2lyZWRTaXplIDwgMFxufVxuXG4vLyBUaGVyZSBtaWdodCBiZSByYWNlIGNvbmRpdGlvbnMgYmV0d2VlbiBgbmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlcmAgYW5kXG4vLyBgRE9NQ29udGVudExvYWRlZGAuIFRoZSBmb3JtZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBSZWFjdCBzdGFydHMgdG8gaHlkcmF0ZVxuLy8gdGhlIHJvb3QsIHRoZSBsYXR0ZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgRE9NIGlzIGZ1bGx5IGxvYWRlZC5cbi8vIEZvciBzdHJlYW1pbmcsIHRoZSBmb3JtZXIgaXMgY2FsbGVkIGZpcnN0IGR1ZSB0byBwYXJ0aWFsIGh5ZHJhdGlvbi5cbi8vIEZvciBub24tc3RyZWFtaW5nLCB0aGUgbGF0dGVyIGNhbiBiZSBjYWxsZWQgZmlyc3QuXG4vLyBIZW5jZSwgd2UgdXNlIHR3byB2YXJpYWJsZXMgYGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkYCBhbmRcbi8vIGBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWRgIHRvIG1ha2Ugc3VyZSB0aGUgd3JpdGVyIHdpbGwgYmUgY2xvc2VkIGFuZFxuLy8gYGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyYCB3aWxsIGJlIGNsZWFyZWQgaW4gdGhlIHJpZ2h0IHRpbWUuXG5mdW5jdGlvbiBuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyKGN0cjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikge1xuICBpZiAoaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIpIHtcbiAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlci5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIGN0ci5lbnF1ZXVlKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gZW5jb2Rlci5lbmNvZGUodmFsKSA6IHZhbClcbiAgICB9KVxuICAgIGlmIChpbml0aWFsU2VydmVyRGF0YUxvYWRlZCAmJiAhaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkKSB7XG4gICAgICBpZiAoaXNTdHJlYW1FcnJvck9yVW5maW5pc2hlZChjdHIpKSB7XG4gICAgICAgIGN0ci5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGNvbm5lY3Rpb24gdG8gdGhlIHBhZ2Ugd2FzIHVuZXhwZWN0ZWRseSBjbG9zZWQsIHBvc3NpYmx5IGR1ZSB0byB0aGUgc3RvcCBidXR0b24gYmVpbmcgY2xpY2tlZCwgbG9zcyBvZiBXaS1GaSwgb3IgYW4gdW5zdGFibGUgaW50ZXJuZXQgY29ubmVjdGlvbi4nXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHIuY2xvc2UoKVxuICAgICAgfVxuICAgICAgaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkID0gdHJ1ZVxuICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBpbml0aWFsU2VydmVyRGF0YVdyaXRlciA9IGN0clxufVxuXG4vLyBXaGVuIGBET01Db250ZW50TG9hZGVkYCwgd2UgY2FuIGNsb3NlIGFsbCBwZW5kaW5nIHdyaXRlcnMgdG8gZmluaXNoIGh5ZHJhdGlvbi5cbmNvbnN0IERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChpbml0aWFsU2VydmVyRGF0YVdyaXRlciAmJiAhaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkKSB7XG4gICAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIuY2xvc2UoKVxuICAgIGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCA9IHRydWVcbiAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciA9IHVuZGVmaW5lZFxuICB9XG4gIGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkID0gdHJ1ZVxufVxuXG4vLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIERPTSBpcyBhbHJlYWR5IGxvYWRlZC5cbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlKVxufSBlbHNlIHtcbiAgLy8gRGVsYXllZCBpbiBtYXJjbyB0YXNrIHRvIGVuc3VyZSBpdCdzIGV4ZWN1dGVkIGxhdGVyIHRoYW4gaHlkcmF0aW9uXG4gIHNldFRpbWVvdXQoRE9NQ29udGVudExvYWRlZClcbn1cblxuY29uc3QgbmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsID0gKHNlbGYuX19uZXh0X2YgPSBzZWxmLl9fbmV4dF9mIHx8IFtdKVxuXG4vLyBDb25zdW1lIGFsbCBidWZmZXJlZCBjaHVua3MgYW5kIGNsZWFyIHRoZSBnbG9iYWwgZGF0YSBhcnJheSByaWdodCBhZnRlciB0byByZWxlYXNlIG1lbW9yeS5cbi8vIE90aGVyd2lzZSBpdCB3aWxsIGJlIHJldGFpbmVkIGluZGVmaW5pdGVseS5cbm5leHRTZXJ2ZXJEYXRhTG9hZGluZ0dsb2JhbC5mb3JFYWNoKG5leHRTZXJ2ZXJEYXRhQ2FsbGJhY2spXG5uZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwubGVuZ3RoID0gMFxuXG4vLyBQYXRjaCBpdHMgcHVzaCBtZXRob2Qgc28gc3Vic2VxdWVudCBjaHVua3MgYXJlIGhhbmRsZWQgKGJ1dCBub3QgYWN0dWFsbHkgcHVzaGVkIHRvIHRoZSBhcnJheSkuXG5uZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwucHVzaCA9IG5leHRTZXJ2ZXJEYXRhQ2FsbGJhY2tcblxuY29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgbmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlcihjb250cm9sbGVyKVxuICB9LFxufSlcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgcmVhZGFibGUubmFtZSA9ICdoeWRyYXRpb24nXG59XG5cbmxldCBkZWJ1Z0NoYW5uZWw6XG4gIHwgeyByZWFkYWJsZT86IFJlYWRhYmxlU3RyZWFtOyB3cml0YWJsZT86IFdyaXRhYmxlU3RyZWFtIH1cbiAgfCB1bmRlZmluZWRcblxuaWYgKFxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ERUJVR19DSEFOTkVMICYmXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4pIHtcbiAgY29uc3QgeyBjcmVhdGVEZWJ1Z0NoYW5uZWwgfSA9XG4gICAgcmVxdWlyZSgnLi9kZXYvZGVidWctY2hhbm5lbCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4vZGV2L2RlYnVnLWNoYW5uZWwnKVxuXG4gIGRlYnVnQ2hhbm5lbCA9IGNyZWF0ZURlYnVnQ2hhbm5lbCh1bmRlZmluZWQpXG59XG5cbmNvbnN0IGNsaWVudFJlc3VtZUZldGNoOiBQcm9taXNlPFJlc3BvbnNlPiB8IHVuZGVmaW5lZCA9XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgd2luZG93Ll9fTkVYVF9DTElFTlRfUkVTVU1FXG5cbmxldCBpbml0aWFsU2VydmVyUmVzcG9uc2U6IFByb21pc2U8SW5pdGlhbFJTQ1BheWxvYWQ+XG5pZiAoY2xpZW50UmVzdW1lRmV0Y2gpIHtcbiAgaW5pdGlhbFNlcnZlclJlc3BvbnNlID0gUHJvbWlzZS5yZXNvbHZlKFxuICAgIGNyZWF0ZUZyb21GZXRjaDxJbml0aWFsUlNDUGF5bG9hZD4oY2xpZW50UmVzdW1lRmV0Y2gsIHtcbiAgICAgIGNhbGxTZXJ2ZXIsXG4gICAgICBmaW5kU291cmNlTWFwVVJMLFxuICAgICAgZGVidWdDaGFubmVsLFxuICAgIH0pXG4gICkudGhlbihhc3luYyAoZmFsbGJhY2tJbml0aWFsUlNDUGF5bG9hZCkgPT5cbiAgICBjcmVhdGVJbml0aWFsUlNDUGF5bG9hZEZyb21GYWxsYmFja1ByZXJlbmRlcihcbiAgICAgIGF3YWl0IGNsaWVudFJlc3VtZUZldGNoLFxuICAgICAgZmFsbGJhY2tJbml0aWFsUlNDUGF5bG9hZFxuICAgIClcbiAgKVxufSBlbHNlIHtcbiAgaW5pdGlhbFNlcnZlclJlc3BvbnNlID0gY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtPEluaXRpYWxSU0NQYXlsb2FkPihcbiAgICByZWFkYWJsZSxcbiAgICB7XG4gICAgICBjYWxsU2VydmVyLFxuICAgICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgICAgIGRlYnVnQ2hhbm5lbCxcbiAgICAgIHN0YXJ0VGltZTogMCxcbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gU2VydmVyUm9vdCh7XG4gIGluaXRpYWxSU0NQYXlsb2FkLFxuICBhY3Rpb25RdWV1ZSxcbiAgd2ViU29ja2V0LFxuICBzdGF0aWNJbmRpY2F0b3JTdGF0ZSxcbn06IHtcbiAgaW5pdGlhbFJTQ1BheWxvYWQ6IEluaXRpYWxSU0NQYXlsb2FkXG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuICB3ZWJTb2NrZXQ6IFdlYlNvY2tldCB8IHVuZGVmaW5lZFxuICBzdGF0aWNJbmRpY2F0b3JTdGF0ZTogU3RhdGljSW5kaWNhdG9yU3RhdGUgfCB1bmRlZmluZWRcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICBjb25zdCByb3V0ZXIgPSAoXG4gICAgPEFwcFJvdXRlclxuICAgICAgYWN0aW9uUXVldWU9e2FjdGlvblF1ZXVlfVxuICAgICAgZ2xvYmFsRXJyb3JTdGF0ZT17aW5pdGlhbFJTQ1BheWxvYWQuR31cbiAgICAgIHdlYlNvY2tldD17d2ViU29ja2V0fVxuICAgICAgc3RhdGljSW5kaWNhdG9yU3RhdGU9e3N0YXRpY0luZGljYXRvclN0YXRlfVxuICAgIC8+XG4gIClcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgaW5pdGlhbFJTQ1BheWxvYWQubSkge1xuICAgIC8vIFdlIHByb3ZpZGUgbWlzc2luZyBzbG90IGluZm9ybWF0aW9uIGluIGEgY29udGV4dCBwcm92aWRlciBvbmx5IGR1cmluZyBkZXZlbG9wbWVudFxuICAgIC8vIGFzIHdlIGxvZyBzb21lIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1pc3Npbmcgc2xvdHMgaW4gdGhlIGNvbnNvbGUuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNaXNzaW5nU2xvdENvbnRleHQgdmFsdWU9e2luaXRpYWxSU0NQYXlsb2FkLm19PlxuICAgICAgICB7cm91dGVyfVxuICAgICAgPC9NaXNzaW5nU2xvdENvbnRleHQ+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHJvdXRlclxufVxuXG5jb25zdCBTdHJpY3RNb2RlSWZFbmFibGVkID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFX0FQUFxuICA/IFJlYWN0LlN0cmljdE1vZGVcbiAgOiBSZWFjdC5GcmFnbWVudFxuXG5mdW5jdGlvbiBSb290KHsgY2hpbGRyZW4gfTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e30+KSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlXG4gICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0FUID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0I/LigpXG4gICAgfSwgW10pXG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuY29uc3QgZW5hYmxlVHJhbnNpdGlvbkluZGljYXRvciA9IHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFOU0lUSU9OX0lORElDQVRPUlxuXG5mdW5jdGlvbiBub0RlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yKCkge1xuICByZXR1cm4gKCkgPT4ge31cbn1cblxuY29uc3QgcmVhY3RSb290T3B0aW9uczogUmVhY3RET01DbGllbnQuUm9vdE9wdGlvbnMgPSB7XG4gIG9uRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3I6IGVuYWJsZVRyYW5zaXRpb25JbmRpY2F0b3JcbiAgICA/IC8vIFRPRE86IENvbXBvc2UgZGVmYXVsdCB3aXRoIHVzZXItY29uZmlndXJlYWJsZSAoZS5nLiBucHJvZ3Jlc3MpXG4gICAgICB1bmRlZmluZWRcbiAgICA6IG5vRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3IsXG4gIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgb25DYXVnaHRFcnJvcixcbiAgb25VbmNhdWdodEVycm9yLFxufVxuXG5leHBvcnQgdHlwZSBDbGllbnRJbnN0cnVtZW50YXRpb25Ib29rcyA9IHtcbiAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQ/OiAoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgbmF2aWdhdGlvblR5cGU6ICdwdXNoJyB8ICdyZXBsYWNlJyB8ICd0cmF2ZXJzZSdcbiAgKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoeWRyYXRlKFxuICBpbnN0cnVtZW50YXRpb25Ib29rczogQ2xpZW50SW5zdHJ1bWVudGF0aW9uSG9va3MgfCBudWxsLFxuICBhc3NldFByZWZpeDogc3RyaW5nXG4pIHtcbiAgbGV0IHN0YXRpY0luZGljYXRvclN0YXRlOiBTdGF0aWNJbmRpY2F0b3JTdGF0ZSB8IHVuZGVmaW5lZFxuICBsZXQgd2ViU29ja2V0OiBXZWJTb2NrZXQgfCB1bmRlZmluZWRcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHsgY3JlYXRlV2ViU29ja2V0IH0gPVxuICAgICAgcmVxdWlyZSgnLi9kZXYvaG90LXJlbG9hZGVyL2FwcC93ZWItc29ja2V0JykgYXMgdHlwZW9mIGltcG9ydCgnLi9kZXYvaG90LXJlbG9hZGVyL2FwcC93ZWItc29ja2V0JylcblxuICAgIHN0YXRpY0luZGljYXRvclN0YXRlID0geyBwYXRobmFtZTogbnVsbCwgYXBwSXNyTWFuaWZlc3Q6IG51bGwgfVxuICAgIHdlYlNvY2tldCA9IGNyZWF0ZVdlYlNvY2tldChhc3NldFByZWZpeCwgc3RhdGljSW5kaWNhdG9yU3RhdGUpXG4gIH1cbiAgY29uc3QgaW5pdGlhbFJTQ1BheWxvYWQgPSBhd2FpdCBpbml0aWFsU2VydmVyUmVzcG9uc2VcbiAgLy8gc2V0QXBwQnVpbGRJZCBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSwgZHVyaW5nIEpTIGluaXRpYWxpemF0aW9uXG4gIC8vIGFuZCBiZWZvcmUgYW55IGNvbXBvbmVudHMgaGF2ZSBoeWRyYXRlZC5cbiAgc2V0QXBwQnVpbGRJZChpbml0aWFsUlNDUGF5bG9hZC5iKVxuXG4gIGNvbnN0IGluaXRpYWxUaW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gIGNvbnN0IGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSA9IGNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZShcbiAgICBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUoe1xuICAgICAgbmF2aWdhdGVkQXQ6IGluaXRpYWxUaW1lc3RhbXAsXG4gICAgICBpbml0aWFsRmxpZ2h0RGF0YTogaW5pdGlhbFJTQ1BheWxvYWQuZixcbiAgICAgIGluaXRpYWxDYW5vbmljYWxVcmxQYXJ0czogaW5pdGlhbFJTQ1BheWxvYWQuYyxcbiAgICAgIGluaXRpYWxSZW5kZXJlZFNlYXJjaDogaW5pdGlhbFJTQ1BheWxvYWQucSxcbiAgICAgIGxvY2F0aW9uOiB3aW5kb3cubG9jYXRpb24sXG4gICAgfSksXG4gICAgaW5zdHJ1bWVudGF0aW9uSG9va3NcbiAgKVxuXG4gIGNvbnN0IHJlYWN0RWwgPSAoXG4gICAgPFN0cmljdE1vZGVJZkVuYWJsZWQ+XG4gICAgICA8SGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IGFwcERpcjogdHJ1ZSB9fT5cbiAgICAgICAgPFJvb3Q+XG4gICAgICAgICAgPFNlcnZlclJvb3RcbiAgICAgICAgICAgIGluaXRpYWxSU0NQYXlsb2FkPXtpbml0aWFsUlNDUGF5bG9hZH1cbiAgICAgICAgICAgIGFjdGlvblF1ZXVlPXthY3Rpb25RdWV1ZX1cbiAgICAgICAgICAgIHdlYlNvY2tldD17d2ViU29ja2V0fVxuICAgICAgICAgICAgc3RhdGljSW5kaWNhdG9yU3RhdGU9e3N0YXRpY0luZGljYXRvclN0YXRlfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvUm9vdD5cbiAgICAgIDwvSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvU3RyaWN0TW9kZUlmRW5hYmxlZD5cbiAgKVxuXG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaWQgPT09ICdfX25leHRfZXJyb3JfXycpIHtcbiAgICBsZXQgZWxlbWVudCA9IHJlYWN0RWxcbiAgICAvLyBTZXJ2ZXIgcmVuZGVyaW5nIGZhaWxlZCwgZmFsbCBiYWNrIHRvIGNsaWVudC1zaWRlIHJlbmRlcmluZ1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB7IFJvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50IH0gPVxuICAgICAgICByZXF1aXJlKCcuLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvY2xpZW50LWVudHJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2NsaWVudC1lbnRyeScpXG5cbiAgICAgIC8vIE5vdGUgdGhpcyB3b24ndCBjYXVzZSBoeWRyYXRpb24gbWlzbWF0Y2ggYmVjYXVzZSB3ZSBhcmUgZG9pbmcgQ1NSIHcvbyBoeWRyYXRpb25cbiAgICAgIGVsZW1lbnQgPSAoXG4gICAgICAgIDxSb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudD57ZWxlbWVudH08L1Jvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50PlxuICAgICAgKVxuICAgIH1cblxuICAgIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoYXBwRWxlbWVudCwgcmVhY3RSb290T3B0aW9ucykucmVuZGVyKGVsZW1lbnQpXG4gIH0gZWxzZSB7XG4gICAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIFJlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGFwcEVsZW1lbnQsIHJlYWN0RWwsIHtcbiAgICAgICAgLi4ucmVhY3RSb290T3B0aW9ucyxcbiAgICAgICAgZm9ybVN0YXRlOiBpbml0aWFsRm9ybVN0YXRlRGF0YSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIFRPRE8tQVBQOiBSZW1vdmUgdGhpcyBsb2dpYyB3aGVuIEZsb2F0IGhhcyBHQyBidWlsdC1pbiBpbiBkZXZlbG9wbWVudC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IGxpbmtHYyB9ID1cbiAgICAgIHJlcXVpcmUoJy4vYXBwLWxpbmstZ2MnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL2FwcC1saW5rLWdjJylcbiAgICBsaW5rR2MoKVxuICB9XG59XG4iXSwibmFtZXMiOlsiaHlkcmF0ZSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbUJyb3dzZXIiLCJjcmVhdGVGcm9tRmV0Y2giLCJjcmVhdGVGcm9tRmV0Y2hCcm93c2VyIiwiYXBwRWxlbWVudCIsImRvY3VtZW50IiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIiLCJ1bmRlZmluZWQiLCJpbml0aWFsU2VydmVyRGF0YVdyaXRlciIsImluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkIiwiaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkIiwiaW5pdGlhbEZvcm1TdGF0ZURhdGEiLCJuZXh0U2VydmVyRGF0YUNhbGxiYWNrIiwic2VnIiwiRXJyb3IiLCJlbnF1ZXVlIiwiZW5jb2RlIiwicHVzaCIsImJpbmFyeVN0cmluZyIsImF0b2IiLCJkZWNvZGVkQ2h1bmsiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiaSIsImNoYXJDb2RlQXQiLCJpc1N0cmVhbUVycm9yT3JVbmZpbmlzaGVkIiwiY3RyIiwiZGVzaXJlZFNpemUiLCJuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyIiwiZm9yRWFjaCIsInZhbCIsImVycm9yIiwiY2xvc2UiLCJET01Db250ZW50TG9hZGVkIiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXRUaW1lb3V0IiwibmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsIiwic2VsZiIsIl9fbmV4dF9mIiwicmVhZGFibGUiLCJSZWFkYWJsZVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm5hbWUiLCJkZWJ1Z0NoYW5uZWwiLCJfX05FWFRfUkVBQ1RfREVCVUdfQ0hBTk5FTCIsIndpbmRvdyIsImNyZWF0ZURlYnVnQ2hhbm5lbCIsInJlcXVpcmUiLCJjbGllbnRSZXN1bWVGZXRjaCIsIl9fTkVYVF9DTElFTlRfUkVTVU1FIiwiaW5pdGlhbFNlcnZlclJlc3BvbnNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYWxsU2VydmVyIiwiZmluZFNvdXJjZU1hcFVSTCIsInRoZW4iLCJmYWxsYmFja0luaXRpYWxSU0NQYXlsb2FkIiwiY3JlYXRlSW5pdGlhbFJTQ1BheWxvYWRGcm9tRmFsbGJhY2tQcmVyZW5kZXIiLCJzdGFydFRpbWUiLCJTZXJ2ZXJSb290IiwiaW5pdGlhbFJTQ1BheWxvYWQiLCJhY3Rpb25RdWV1ZSIsIndlYlNvY2tldCIsInN0YXRpY0luZGljYXRvclN0YXRlIiwicm91dGVyIiwiQXBwUm91dGVyIiwiZ2xvYmFsRXJyb3JTdGF0ZSIsIkciLCJtIiwiTWlzc2luZ1Nsb3RDb250ZXh0IiwidmFsdWUiLCJTdHJpY3RNb2RlSWZFbmFibGVkIiwiX19ORVhUX1NUUklDVF9NT0RFX0FQUCIsIlJlYWN0IiwiU3RyaWN0TW9kZSIsIkZyYWdtZW50IiwiUm9vdCIsImNoaWxkcmVuIiwiX19ORVhUX1RFU1RfTU9ERSIsInVzZUVmZmVjdCIsIl9fTkVYVF9IWURSQVRFRCIsIl9fTkVYVF9IWURSQVRFRF9BVCIsInBlcmZvcm1hbmNlIiwibm93IiwiX19ORVhUX0hZRFJBVEVEX0NCIiwiZW5hYmxlVHJhbnNpdGlvbkluZGljYXRvciIsIl9fTkVYVF9UUkFOU0lUSU9OX0lORElDQVRPUiIsIm5vRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3IiLCJyZWFjdFJvb3RPcHRpb25zIiwib25EZWZhdWx0VHJhbnNpdGlvbkluZGljYXRvciIsIm9uUmVjb3ZlcmFibGVFcnJvciIsIm9uQ2F1Z2h0RXJyb3IiLCJvblVuY2F1Z2h0RXJyb3IiLCJpbnN0cnVtZW50YXRpb25Ib29rcyIsImFzc2V0UHJlZml4IiwiY3JlYXRlV2ViU29ja2V0IiwicGF0aG5hbWUiLCJhcHBJc3JNYW5pZmVzdCIsInNldEFwcEJ1aWxkSWQiLCJiIiwiaW5pdGlhbFRpbWVzdGFtcCIsIkRhdGUiLCJjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUiLCJjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUiLCJuYXZpZ2F0ZWRBdCIsImluaXRpYWxGbGlnaHREYXRhIiwiZiIsImluaXRpYWxDYW5vbmljYWxVcmxQYXJ0cyIsImMiLCJpbml0aWFsUmVuZGVyZWRTZWFyY2giLCJxIiwibG9jYXRpb24iLCJyZWFjdEVsIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJhcHBEaXIiLCJkb2N1bWVudEVsZW1lbnQiLCJpZCIsImVsZW1lbnQiLCJSb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudCIsIlJlYWN0RE9NQ2xpZW50IiwiY3JlYXRlUm9vdCIsInJlbmRlciIsInN0YXJ0VHJhbnNpdGlvbiIsImh5ZHJhdGVSb290IiwiZm9ybVN0YXRlIiwibGlua0djIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/app-index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/app-link-gc.js":
/*!*******************************************************!*\
  !*** ../node_modules/next/dist/client/app-link-gc.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"linkGc\", ({\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n}));\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === 'childList') {\n                    for (const node of mutation.addedNodes){\n                        if ('tagName' in node && node.tagName === 'LINK') {\n                            const link = node;\n                            if (link.dataset.precedence?.startsWith('next')) {\n                                const href = link.getAttribute('href');\n                                if (href) {\n                                    const [resource, version] = href.split('?v=', 2);\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            if (otherLink.dataset.precedence?.startsWith('next')) {\n                                                const otherHref = otherLink.getAttribute('href');\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split('?v=', 2);\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector(`link[rel=\"preload\"][as=\"style\"][href=\"${otherHref}\"]`);\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-link-gc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hcHAtbGluay1nYy5qcyIsIm1hcHBpbmdzIjoiOzs7OzBDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0E7SUFDZCx5RUFBeUU7SUFDekUsSUFBSUMsSUFBb0IsRUFBbUI7UUFDekMsTUFBTUcsV0FBVyxDQUFDQztZQUNoQixLQUFLLE1BQU1DLFlBQVlELGFBQWM7Z0JBQ25DLElBQUlDLFNBQVNDLElBQUksS0FBSyxhQUFhO29CQUNqQyxLQUFLLE1BQU1DLFFBQVFGLFNBQVNHLFVBQVUsQ0FBRTt3QkFDdEMsSUFDRSxhQUFhRCxRQUNaQSxLQUF5QkUsT0FBTyxLQUFLLFFBQ3RDOzRCQUNBLE1BQU1DLE9BQU9IOzRCQUNiLElBQUlHLEtBQUtDLE9BQU8sQ0FBQ0MsVUFBVSxFQUFFQyxXQUFXLFNBQVM7Z0NBQy9DLE1BQU1DLE9BQU9KLEtBQUtLLFlBQVksQ0FBQztnQ0FDL0IsSUFBSUQsTUFBTTtvQ0FDUixNQUFNLENBQUNFLFVBQVVDLFFBQVEsR0FBR0gsS0FBS0ksS0FBSyxDQUFDLE9BQU87b0NBQzlDLElBQUlELFNBQVM7d0NBQ1gsTUFBTUUsZ0JBQWdCQyxPQUFPQyxRQUFRLENBQUNDLE1BQU07d0NBQzVDLE1BQU1DLFdBQVc7K0NBQ1pDLFNBQVNDLGdCQUFnQixDQUMxQixpQkFBaUJULFdBQVc7NENBRTlCLGtFQUFrRTs0Q0FDbEUscURBQXFEOytDQUNsRFEsU0FBU0MsZ0JBQWdCLENBQzFCLGlCQUNHVCxDQUFBQSxTQUFTSCxVQUFVLENBQUNNLGlCQUNqQkgsU0FBU1UsS0FBSyxDQUFDUCxjQUFjUSxNQUFNLElBQ25DUixnQkFBZ0JILFFBQUFBLENBQU8sR0FDM0I7eUNBRUw7d0NBRUQsS0FBSyxNQUFNWSxhQUFhTCxTQUFVOzRDQUNoQyxJQUFJSyxVQUFVakIsT0FBTyxDQUFDQyxVQUFVLEVBQUVDLFdBQVcsU0FBUztnREFDcEQsTUFBTWdCLFlBQVlELFVBQVViLFlBQVksQ0FBQztnREFDekMsSUFBSWMsV0FBVztvREFDYixNQUFNLEdBQUdDLGFBQWEsR0FBR0QsVUFBVVgsS0FBSyxDQUFDLE9BQU87b0RBQ2hELElBQUksQ0FBQ1ksZ0JBQWdCLENBQUNBLGVBQWUsQ0FBQ2IsU0FBUzt3REFDN0Msb0RBQW9EO3dEQUNwRCxtREFBbUQ7d0RBQ25ELG9EQUFvRDt3REFDcEQsbURBQW1EO3dEQUNuRGMsV0FBVzs0REFDVEgsVUFBVUksTUFBTTt3REFDbEIsR0FBRzt3REFDSCxNQUFNQyxjQUFjVCxTQUFTVSxhQUFhLENBQ3hDLENBQUMsc0NBQXNDLEVBQUVMLFVBQVUsRUFBRSxDQUFDO3dEQUV4RCxJQUFJSSxhQUFhOzREQUNmQSxZQUFZRCxNQUFNO3dEQUNwQjtvREFDRjtnREFDRjs0Q0FDRjt3Q0FDRjtvQ0FDRjtnQ0FDRjs0QkFDRjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSw4REFBOEQ7UUFDOUQsTUFBTUcsV0FBVyxJQUFJQyxpQkFBaUJqQztRQUN0Q2dDLFNBQVNFLE9BQU8sQ0FBQ2IsU0FBU2MsSUFBSSxFQUFFO1lBQzlCQyxXQUFXO1FBQ2I7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdml0YWxpeXVsaXRvdnNreS9kZXYvc3JjL2NsaWVudC9hcHAtbGluay1nYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbGlua0djKCkge1xuICAvLyBUT0RPLUFQUDogUmVtb3ZlIHRoaXMgbG9naWMgd2hlbiBGbG9hdCBoYXMgR0MgYnVpbHQtaW4gaW4gZGV2ZWxvcG1lbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAobXV0YXRpb25MaXN0OiBNdXRhdGlvblJlY29yZFtdKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9uTGlzdCkge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbXV0YXRpb24uYWRkZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAndGFnTmFtZScgaW4gbm9kZSAmJlxuICAgICAgICAgICAgICAobm9kZSBhcyBIVE1MTGlua0VsZW1lbnQpLnRhZ05hbWUgPT09ICdMSU5LJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBub2RlIGFzIEhUTUxMaW5rRWxlbWVudFxuICAgICAgICAgICAgICBpZiAobGluay5kYXRhc2V0LnByZWNlZGVuY2U/LnN0YXJ0c1dpdGgoJ25leHQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpXG4gICAgICAgICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IFtyZXNvdXJjZSwgdmVyc2lvbl0gPSBocmVmLnNwbGl0KCc/dj0nLCAyKVxuICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsTGlua3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5rW2hyZWZePVwiJyArIHJlc291cmNlICsgJ1wiXSdcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgcmVzb3VyY2UgaXMgYSBmdWxsIFVSTCBvciBvbmx5IHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBhbHRlcm5hdGl2ZSBocmVmIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgICAgLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5rW2hyZWZePVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChyZXNvdXJjZS5zdGFydHNXaXRoKGN1cnJlbnRPcmlnaW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNvdXJjZS5zbGljZShjdXJyZW50T3JpZ2luLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnRPcmlnaW4gKyByZXNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJdJ1xuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIF0gYXMgSFRNTExpbmtFbGVtZW50W11cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG90aGVyTGluayBvZiBhbGxMaW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckxpbmsuZGF0YXNldC5wcmVjZWRlbmNlPy5zdGFydHNXaXRoKCduZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVySHJlZiA9IG90aGVyTGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVySHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCBvdGhlclZlcnNpb25dID0gb3RoZXJIcmVmLnNwbGl0KCc/dj0nLCAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyVmVyc2lvbiB8fCArb3RoZXJWZXJzaW9uIDwgK3ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmVtb3ZhbCBvZiB0aGUgc3R5bGVzaGVldCB0byBhdm9pZCBGT1VDXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2F1c2VkIGJ5IGBAZm9udC1mYWNlYCBydWxlcywgYXMgdGhleSBzZWVtIHRvIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjb3VwbGUgb2YgdGlja3MgZGVsYXllZCBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyBiZWluZyBzd2FwcGVkIGV2ZW4gaWYgdGhlIGZvbnQgaXMgY2FjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJMaW5rLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgNSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVsb2FkTGluayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgbGlua1tyZWw9XCJwcmVsb2FkXCJdW2FzPVwic3R5bGVcIl1baHJlZj1cIiR7b3RoZXJIcmVmfVwiXWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWxvYWRMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVsb2FkTGluay5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBsaW5rZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaylcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmhlYWQsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICB9KVxuICB9XG59XG4iXSwibmFtZXMiOlsibGlua0djIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY2FsbGJhY2siLCJtdXRhdGlvbkxpc3QiLCJtdXRhdGlvbiIsInR5cGUiLCJub2RlIiwiYWRkZWROb2RlcyIsInRhZ05hbWUiLCJsaW5rIiwiZGF0YXNldCIsInByZWNlZGVuY2UiLCJzdGFydHNXaXRoIiwiaHJlZiIsImdldEF0dHJpYnV0ZSIsInJlc291cmNlIiwidmVyc2lvbiIsInNwbGl0IiwiY3VycmVudE9yaWdpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiYWxsTGlua3MiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzbGljZSIsImxlbmd0aCIsIm90aGVyTGluayIsIm90aGVySHJlZiIsIm90aGVyVmVyc2lvbiIsInNldFRpbWVvdXQiLCJyZW1vdmUiLCJwcmVsb2FkTGluayIsInF1ZXJ5U2VsZWN0b3IiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiaGVhZCIsImNoaWxkTGlzdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/app-link-gc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router-instance.js":
/*!**************************************************************************!*\
  !*** ../node_modules/next/dist/client/components/app-router-instance.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createMutableActionQueue: function() {\n        return createMutableActionQueue;\n    },\n    dispatchNavigateAction: function() {\n        return dispatchNavigateAction;\n    },\n    dispatchTraverseAction: function() {\n        return dispatchTraverseAction;\n    },\n    getCurrentAppRouterState: function() {\n        return getCurrentAppRouterState;\n    },\n    publicAppRouterInstance: function() {\n        return publicAppRouterInstance;\n    }\n});\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _routerreducer = __webpack_require__(/*! ./router-reducer/router-reducer */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\nconst _isthenable = __webpack_require__(/*! ../../shared/lib/is-thenable */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/is-thenable.js\");\nconst _types = __webpack_require__(/*! ./segment-cache/types */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/types.js\");\nconst _prefetch = __webpack_require__(/*! ./segment-cache/prefetch */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/prefetch.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/../node_modules/next/dist/client/components/use-action-queue.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/../node_modules/next/dist/client/add-base-path.js\");\nconst _approuterutils = __webpack_require__(/*! ./app-router-utils */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-utils.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/../node_modules/next/dist/client/components/links.js\");\nfunction runRemainingActions(actionQueue, setState) {\n    if (actionQueue.pending !== null) {\n        actionQueue.pending = actionQueue.pending.next;\n        if (actionQueue.pending !== null) {\n            runAction({\n                actionQueue,\n                action: actionQueue.pending,\n                setState\n            });\n        }\n    } else {\n        // Check for refresh when pending is already null\n        // This handles the case where a discarded server action completes\n        // after the navigation has already finished and the queue is empty\n        if (actionQueue.needsRefresh) {\n            actionQueue.needsRefresh = false;\n            actionQueue.dispatch({\n                type: _routerreducertypes.ACTION_REFRESH\n            }, setState);\n        }\n    }\n}\nasync function runAction({ actionQueue, action, setState }) {\n    const prevState = actionQueue.state;\n    actionQueue.pending = action;\n    const payload = action.payload;\n    const actionResult = actionQueue.action(prevState, payload);\n    function handleResult(nextState) {\n        // if we discarded this action, the state should also be discarded\n        if (action.discarded) {\n            // Check if the discarded server action revalidated data\n            if (action.payload.type === _routerreducertypes.ACTION_SERVER_ACTION && action.payload.didRevalidate) {\n                // The server action was discarded but it revalidated data,\n                // mark that we need to refresh after all actions complete\n                actionQueue.needsRefresh = true;\n            }\n            // Still need to run remaining actions even for discarded actions\n            // to potentially trigger the refresh\n            runRemainingActions(actionQueue, setState);\n            return;\n        }\n        actionQueue.state = nextState;\n        runRemainingActions(actionQueue, setState);\n        action.resolve(nextState);\n    }\n    // if the action is a promise, set up a callback to resolve it\n    if ((0, _isthenable.isThenable)(actionResult)) {\n        actionResult.then(handleResult, (err)=>{\n            runRemainingActions(actionQueue, setState);\n            action.reject(err);\n        });\n    } else {\n        handleResult(actionResult);\n    }\n}\nfunction dispatchAction(actionQueue, payload, setState) {\n    let resolvers = {\n        resolve: setState,\n        reject: ()=>{}\n    };\n    // most of the action types are async with the exception of restore\n    // it's important that restore is handled quickly since it's fired on the popstate event\n    // and we don't want to add any delay on a back/forward nav\n    // this only creates a promise for the async actions\n    if (payload.type !== _routerreducertypes.ACTION_RESTORE) {\n        // Create the promise and assign the resolvers to the object.\n        const deferredPromise = new Promise((resolve, reject)=>{\n            resolvers = {\n                resolve,\n                reject\n            };\n        });\n        (0, _react.startTransition)(()=>{\n            // we immediately notify React of the pending promise -- the resolver is attached to the action node\n            // and will be called when the associated action promise resolves\n            setState(deferredPromise);\n        });\n    }\n    const newAction = {\n        payload,\n        next: null,\n        resolve: resolvers.resolve,\n        reject: resolvers.reject\n    };\n    // Check if the queue is empty\n    if (actionQueue.pending === null) {\n        // The queue is empty, so add the action and start it immediately\n        // Mark this action as the last in the queue\n        actionQueue.last = newAction;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else if (payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {\n        // Navigations (including back/forward) take priority over any pending actions.\n        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n        actionQueue.pending.discarded = true;\n        // The rest of the current queue should still execute after this navigation.\n        // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n        newAction.next = actionQueue.pending.next;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else {\n        // The queue is not empty, so add the action to the end of the queue\n        // It will be started by runRemainingActions after the previous action finishes\n        if (actionQueue.last !== null) {\n            actionQueue.last.next = newAction;\n        }\n        actionQueue.last = newAction;\n    }\n}\nlet globalActionQueue = null;\nfunction createMutableActionQueue(initialState, instrumentationHooks) {\n    const actionQueue = {\n        state: initialState,\n        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),\n        action: async (state, action)=>{\n            const result = (0, _routerreducer.reducer)(state, action);\n            return result;\n        },\n        pending: null,\n        last: null,\n        onRouterTransitionStart: instrumentationHooks !== null && typeof instrumentationHooks.onRouterTransitionStart === 'function' ? instrumentationHooks.onRouterTransitionStart : null\n    };\n    if (true) {\n        // The action queue is lazily created on hydration, but after that point\n        // it doesn't change. So we can store it in a global rather than pass\n        // it around everywhere via props/context.\n        if (globalActionQueue !== null) {\n            throw Object.defineProperty(new Error('Internal Next.js Error: createMutableActionQueue was called more ' + 'than once'), \"__NEXT_ERROR_CODE\", {\n                value: \"E624\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        globalActionQueue = actionQueue;\n    }\n    return actionQueue;\n}\nfunction getCurrentAppRouterState() {\n    return globalActionQueue !== null ? globalActionQueue.state : null;\n}\nfunction getAppRouterActionQueue() {\n    if (globalActionQueue === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return globalActionQueue;\n}\nfunction getProfilingHookForOnNavigationStart() {\n    if (globalActionQueue !== null) {\n        return globalActionQueue.onRouterTransitionStart;\n    }\n    return null;\n}\nfunction dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {\n    // TODO: This stuff could just go into the reducer. Leaving as-is for now\n    // since we're about to rewrite all the router reducer stuff anyway.\n    const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n    if (false) {}\n    (0, _links.setLinkForCurrentNavigation)(linkInstanceRef);\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, navigateType);\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_NAVIGATE,\n        url,\n        isExternalUrl: (0, _approuterutils.isExternalURL)(url),\n        locationSearch: location.search,\n        shouldScroll,\n        navigateType\n    });\n}\nfunction dispatchTraverseAction(href, historyState) {\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, 'traverse');\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_RESTORE,\n        url: new URL(href),\n        historyState\n    });\n}\nconst publicAppRouterInstance = {\n    back: ()=>window.history.back(),\n    forward: ()=>window.history.forward(),\n    prefetch: // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href, options)=>{\n        const actionQueue = getAppRouterActionQueue();\n        const prefetchKind = options?.kind ?? _routerreducertypes.PrefetchKind.AUTO;\n        // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n        // This will be possible when we update its API to not take a PrefetchKind.\n        let fetchStrategy;\n        switch(prefetchKind){\n            case _routerreducertypes.PrefetchKind.AUTO:\n                {\n                    // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n                    fetchStrategy = _types.FetchStrategy.PPR;\n                    break;\n                }\n            case _routerreducertypes.PrefetchKind.FULL:\n                {\n                    fetchStrategy = _types.FetchStrategy.Full;\n                    break;\n                }\n            default:\n                {\n                    prefetchKind;\n                    // Despite typescript thinking that this can't happen,\n                    // we might get an unexpected value from user code.\n                    // We don't know what they want, but we know they want a prefetch,\n                    // so use the default.\n                    fetchStrategy = _types.FetchStrategy.PPR;\n                }\n        }\n        (0, _prefetch.prefetch)(href, actionQueue.state.nextUrl, actionQueue.state.tree, fetchStrategy, options?.onInvalidate ?? null);\n    },\n    replace: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null);\n        });\n    },\n    push: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            dispatchNavigateAction(href, 'push', options?.scroll ?? true, null);\n        });\n    },\n    refresh: ()=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_REFRESH\n            });\n        });\n    },\n    hmrRefresh: ()=>{\n        if (false) {} else {\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_HMR_REFRESH\n                });\n            });\n        }\n    }\n};\n// Exists for debugging purposes. Don't use in application code.\nif ( true && window.next) {\n    window.next.router = publicAppRouterInstance;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-instance.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBbU5nQkEsd0JBQXdCO2VBQXhCQTs7SUEwREFDLHNCQUFzQjtlQUF0QkE7O0lBOEJBQyxzQkFBc0I7ZUFBdEJBOztJQWxEQUMsd0JBQXdCO2VBQXhCQTs7SUFzRUhDLHVCQUF1QjtlQUF2QkE7OztnREFuVE47MkNBQ2lCO21DQUNRO3dDQUNMO21DQUlwQjtzQ0FDOEM7NENBQ2I7eUNBQ1o7NENBQ0U7bUNBTWlDO0FBaUMvRCxTQUFTQyxvQkFDUEMsV0FBaUMsRUFDakNDLFFBQThCO0lBRTlCLElBQUlELFlBQVlFLE9BQU8sS0FBSyxNQUFNO1FBQ2hDRixZQUFZRSxPQUFPLEdBQUdGLFlBQVlFLE9BQU8sQ0FBQ0MsSUFBSTtRQUM5QyxJQUFJSCxZQUFZRSxPQUFPLEtBQUssTUFBTTtZQUNoQ0UsVUFBVTtnQkFDUko7Z0JBQ0FLLFFBQVFMLFlBQVlFLE9BQU87Z0JBQzNCRDtZQUNGO1FBQ0Y7SUFDRixPQUFPO1FBQ0wsaURBQWlEO1FBQ2pELGtFQUFrRTtRQUNsRSxtRUFBbUU7UUFDbkUsSUFBSUQsWUFBWU0sWUFBWSxFQUFFO1lBQzVCTixZQUFZTSxZQUFZLEdBQUc7WUFDM0JOLFlBQVlPLFFBQVEsQ0FBQztnQkFBRUMsTUFBTUMsb0JBQUFBLGNBQWM7WUFBQyxHQUFHUjtRQUNqRDtJQUNGO0FBQ0Y7QUFFQSxlQUFlRyxVQUFVLEVBQ3ZCSixXQUFXLEVBQ1hLLE1BQU0sRUFDTkosUUFBUSxFQUtUO0lBQ0MsTUFBTVMsWUFBWVYsWUFBWVcsS0FBSztJQUVuQ1gsWUFBWUUsT0FBTyxHQUFHRztJQUV0QixNQUFNTyxVQUFVUCxPQUFPTyxPQUFPO0lBQzlCLE1BQU1DLGVBQWViLFlBQVlLLE1BQU0sQ0FBQ0ssV0FBV0U7SUFFbkQsU0FBU0UsYUFBYUMsU0FBeUI7UUFD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QUFDQyxHQUFHO2dCQUNuQztRQUNGO1FBRUFHLENBQUFBLEdBQUFBLFVBQUFBLFFBQXdCLEVBQ3RCakMsTUFDQTNDLFlBQVlXLEtBQUssQ0FBQ2tFLE9BQU8sRUFDekI3RSxZQUFZVyxLQUFLLENBQUNtRSxJQUFJLEVBQ3RCUCxlQUNBTCxTQUFTYSxnQkFBZ0I7SUFFN0I7SUFDRkMsU0FBUyxDQUFDckMsTUFBY3VCO1FBQ3RCckMsQ0FBQUEsR0FBQUEsT0FBQUEsZUFBQUEsRUFBZ0I7WUFDZGxDLHVCQUF1QmdELE1BQU0sV0FBV3VCLFNBQVNlLFVBQVUsTUFBTTtRQUNuRTtJQUNGO0lBQ0FDLE1BQU0sQ0FBQ3ZDLE1BQWN1QjtRQUNuQnJDLENBQUFBLEdBQUFBLE9BQUFBLGVBQUFBLEVBQWdCO1lBQ2RsQyx1QkFBdUJnRCxNQUFNLFFBQVF1QixTQUFTZSxVQUFVLE1BQU07UUFDaEU7SUFDRjtJQUNBRSxTQUFTO1FBQ1B0RCxDQUFBQSxHQUFBQSxPQUFBQSxlQUFlLEVBQUM7WUFDZDJCLENBQUFBLEdBQUFBLGdCQUFBQSx1QkFBQUEsRUFBd0I7Z0JBQ3RCaEQsTUFBTUMsb0JBQUFBLGNBQWM7WUFDdEI7UUFDRjtJQUNGO0lBQ0EyRSxZQUFZO1FBQ1YsSUFBSWpDLEtBQW9CLEVBQW9CLEVBSTNDLE1BQU07WUFDTHRCLENBQUFBLEdBQUFBLE9BQUFBLGVBQUFBLEVBQWdCO2dCQUNkMkIsQ0FBQUEsR0FBQUEsZ0JBQUFBLHVCQUFBQSxFQUF3QjtvQkFDdEJoRCxNQUFNOEUsb0JBQUFBLGtCQUFrQjtnQkFDMUI7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGdFQUFnRTtBQUNoRSxJQUFJLEtBQTZCLElBQUkvQyxPQUFPcEMsSUFBSSxFQUFFO0lBQ2hEb0MsT0FBT3BDLElBQUksQ0FBQ29GLE1BQU0sR0FBR3pGO0FBQ3ZCIiwic291cmNlcyI6WyIvVXNlcnMvdml0YWxpeXVsaXRvdnNreS9zcmMvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1pbnN0YW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICB0eXBlIEFwcFJvdXRlclN0YXRlLFxuICB0eXBlIFJlZHVjZXJBY3Rpb25zLFxuICB0eXBlIFJlZHVjZXJTdGF0ZSxcbiAgQUNUSU9OX1JFRlJFU0gsXG4gIEFDVElPTl9TRVJWRVJfQUNUSU9OLFxuICBBQ1RJT05fTkFWSUdBVEUsXG4gIEFDVElPTl9SRVNUT1JFLFxuICB0eXBlIE5hdmlnYXRlQWN0aW9uLFxuICBBQ1RJT05fSE1SX1JFRlJFU0gsXG4gIFByZWZldGNoS2luZCxcbiAgdHlwZSBBcHBIaXN0b3J5U3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyByZWR1Y2VyIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlcidcbmltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNUaGVuYWJsZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaXMtdGhlbmFibGUnXG5pbXBvcnQge1xuICBGZXRjaFN0cmF0ZWd5LFxuICB0eXBlIFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3ksXG59IGZyb20gJy4vc2VnbWVudC1jYWNoZS90eXBlcydcbmltcG9ydCB7IHByZWZldGNoIGFzIHByZWZldGNoV2l0aFNlZ21lbnRDYWNoZSB9IGZyb20gJy4vc2VnbWVudC1jYWNoZS9wcmVmZXRjaCdcbmltcG9ydCB7IGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIH0gZnJvbSAnLi91c2UtYWN0aW9uLXF1ZXVlJ1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaXNFeHRlcm5hbFVSTCB9IGZyb20gJy4vYXBwLXJvdXRlci11dGlscydcbmltcG9ydCB0eXBlIHtcbiAgQXBwUm91dGVySW5zdGFuY2UsXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgUHJlZmV0Y2hPcHRpb25zLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbiwgdHlwZSBMaW5rSW5zdGFuY2UgfSBmcm9tICcuL2xpbmtzJ1xuaW1wb3J0IHR5cGUgeyBDbGllbnRJbnN0cnVtZW50YXRpb25Ib29rcyB9IGZyb20gJy4uL2FwcC1pbmRleCdcbmltcG9ydCB0eXBlIHsgR2xvYmFsRXJyb3JDb21wb25lbnQgfSBmcm9tICcuL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuXG5leHBvcnQgdHlwZSBEaXNwYXRjaFN0YXRlUHJvbWlzZSA9IFJlYWN0LkRpc3BhdGNoPFJlZHVjZXJTdGF0ZT5cblxuZXhwb3J0IHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUgPSB7XG4gIHN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxuICBkaXNwYXRjaDogKHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zLCBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2UpID0+IHZvaWRcbiAgYWN0aW9uOiAoc3RhdGU6IEFwcFJvdXRlclN0YXRlLCBhY3Rpb246IFJlZHVjZXJBY3Rpb25zKSA9PiBSZWR1Y2VyU3RhdGVcblxuICBvblJvdXRlclRyYW5zaXRpb25TdGFydDpcbiAgICB8ICgodXJsOiBzdHJpbmcsIHR5cGU6ICdwdXNoJyB8ICdyZXBsYWNlJyB8ICd0cmF2ZXJzZScpID0+IHZvaWQpXG4gICAgfCBudWxsXG5cbiAgcGVuZGluZzogQWN0aW9uUXVldWVOb2RlIHwgbnVsbFxuICBuZWVkc1JlZnJlc2g/OiBib29sZWFuXG4gIGxhc3Q6IEFjdGlvblF1ZXVlTm9kZSB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgR2xvYmFsRXJyb3JTdGF0ZSA9IFtcbiAgR2xvYmFsRXJyb3I6IEdsb2JhbEVycm9yQ29tcG9uZW50LFxuICBzdHlsZXM6IFJlYWN0LlJlYWN0Tm9kZSxcbl1cblxuZXhwb3J0IHR5cGUgQWN0aW9uUXVldWVOb2RlID0ge1xuICBwYXlsb2FkOiBSZWR1Y2VyQWN0aW9uc1xuICBuZXh0OiBBY3Rpb25RdWV1ZU5vZGUgfCBudWxsXG4gIHJlc29sdmU6ICh2YWx1ZTogUmVkdWNlclN0YXRlKSA9PiB2b2lkXG4gIHJlamVjdDogKGVycjogRXJyb3IpID0+IHZvaWRcbiAgZGlzY2FyZGVkPzogYm9vbGVhblxufVxuXG5mdW5jdGlvbiBydW5SZW1haW5pbmdBY3Rpb25zKFxuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZVxuKSB7XG4gIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nICE9PSBudWxsKSB7XG4gICAgYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvblF1ZXVlLnBlbmRpbmcubmV4dFxuICAgIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nICE9PSBudWxsKSB7XG4gICAgICBydW5BY3Rpb24oe1xuICAgICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25RdWV1ZS5wZW5kaW5nLFxuICAgICAgICBzZXRTdGF0ZSxcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENoZWNrIGZvciByZWZyZXNoIHdoZW4gcGVuZGluZyBpcyBhbHJlYWR5IG51bGxcbiAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSBkaXNjYXJkZWQgc2VydmVyIGFjdGlvbiBjb21wbGV0ZXNcbiAgICAvLyBhZnRlciB0aGUgbmF2aWdhdGlvbiBoYXMgYWxyZWFkeSBmaW5pc2hlZCBhbmQgdGhlIHF1ZXVlIGlzIGVtcHR5XG4gICAgaWYgKGFjdGlvblF1ZXVlLm5lZWRzUmVmcmVzaCkge1xuICAgICAgYWN0aW9uUXVldWUubmVlZHNSZWZyZXNoID0gZmFsc2VcbiAgICAgIGFjdGlvblF1ZXVlLmRpc3BhdGNoKHsgdHlwZTogQUNUSU9OX1JFRlJFU0ggfSwgc2V0U3RhdGUpXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkFjdGlvbih7XG4gIGFjdGlvblF1ZXVlLFxuICBhY3Rpb24sXG4gIHNldFN0YXRlLFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgYWN0aW9uOiBBY3Rpb25RdWV1ZU5vZGVcbiAgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlXG59KSB7XG4gIGNvbnN0IHByZXZTdGF0ZSA9IGFjdGlvblF1ZXVlLnN0YXRlXG5cbiAgYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvblxuXG4gIGNvbnN0IHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZFxuICBjb25zdCBhY3Rpb25SZXN1bHQgPSBhY3Rpb25RdWV1ZS5hY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChuZXh0U3RhdGU6IEFwcFJvdXRlclN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZGlzY2FyZGVkIHRoaXMgYWN0aW9uLCB0aGUgc3RhdGUgc2hvdWxkIGFsc28gYmUgZGlzY2FyZGVkXG4gICAgaWYgKGFjdGlvbi5kaXNjYXJkZWQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBkaXNjYXJkZWQgc2VydmVyIGFjdGlvbiByZXZhbGlkYXRlZCBkYXRhXG4gICAgICBpZiAoXG4gICAgICAgIGFjdGlvbi5wYXlsb2FkLnR5cGUgPT09IEFDVElPTl9TRVJWRVJfQUNUSU9OICYmXG4gICAgICAgIGFjdGlvbi5wYXlsb2FkLmRpZFJldmFsaWRhdGVcbiAgICAgICkge1xuICAgICAgICAvLyBUaGUgc2VydmVyIGFjdGlvbiB3YXMgZGlzY2FyZGVkIGJ1dCBpdCByZXZhbGlkYXRlZCBkYXRhLFxuICAgICAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCB0byByZWZyZXNoIGFmdGVyIGFsbCBhY3Rpb25zIGNvbXBsZXRlXG4gICAgICAgIGFjdGlvblF1ZXVlLm5lZWRzUmVmcmVzaCA9IHRydWVcbiAgICAgIH1cbiAgICAgIC8vIFN0aWxsIG5lZWQgdG8gcnVuIHJlbWFpbmluZyBhY3Rpb25zIGV2ZW4gZm9yIGRpc2NhcmRlZCBhY3Rpb25zXG4gICAgICAvLyB0byBwb3RlbnRpYWxseSB0cmlnZ2VyIHRoZSByZWZyZXNoXG4gICAgICBydW5SZW1haW5pbmdBY3Rpb25zKGFjdGlvblF1ZXVlLCBzZXRTdGF0ZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFjdGlvblF1ZXVlLnN0YXRlID0gbmV4dFN0YXRlXG5cbiAgICBydW5SZW1haW5pbmdBY3Rpb25zKGFjdGlvblF1ZXVlLCBzZXRTdGF0ZSlcbiAgICBhY3Rpb24ucmVzb2x2ZShuZXh0U3RhdGUpXG4gIH1cblxuICAvLyBpZiB0aGUgYWN0aW9uIGlzIGEgcHJvbWlzZSwgc2V0IHVwIGEgY2FsbGJhY2sgdG8gcmVzb2x2ZSBpdFxuICBpZiAoaXNUaGVuYWJsZShhY3Rpb25SZXN1bHQpKSB7XG4gICAgYWN0aW9uUmVzdWx0LnRoZW4oaGFuZGxlUmVzdWx0LCAoZXJyKSA9PiB7XG4gICAgICBydW5SZW1haW5pbmdBY3Rpb25zKGFjdGlvblF1ZXVlLCBzZXRTdGF0ZSlcbiAgICAgIGFjdGlvbi5yZWplY3QoZXJyKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlUmVzdWx0KGFjdGlvblJlc3VsdClcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlLFxuICBwYXlsb2FkOiBSZWR1Y2VyQWN0aW9ucyxcbiAgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlXG4pIHtcbiAgbGV0IHJlc29sdmVyczoge1xuICAgIHJlc29sdmU6ICh2YWx1ZTogUmVkdWNlclN0YXRlKSA9PiB2b2lkXG4gICAgcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWRcbiAgfSA9IHsgcmVzb2x2ZTogc2V0U3RhdGUsIHJlamVjdDogKCkgPT4ge30gfVxuXG4gIC8vIG1vc3Qgb2YgdGhlIGFjdGlvbiB0eXBlcyBhcmUgYXN5bmMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHJlc3RvcmVcbiAgLy8gaXQncyBpbXBvcnRhbnQgdGhhdCByZXN0b3JlIGlzIGhhbmRsZWQgcXVpY2tseSBzaW5jZSBpdCdzIGZpcmVkIG9uIHRoZSBwb3BzdGF0ZSBldmVudFxuICAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgYW55IGRlbGF5IG9uIGEgYmFjay9mb3J3YXJkIG5hdlxuICAvLyB0aGlzIG9ubHkgY3JlYXRlcyBhIHByb21pc2UgZm9yIHRoZSBhc3luYyBhY3Rpb25zXG4gIGlmIChwYXlsb2FkLnR5cGUgIT09IEFDVElPTl9SRVNUT1JFKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBwcm9taXNlIGFuZCBhc3NpZ24gdGhlIHJlc29sdmVycyB0byB0aGUgb2JqZWN0LlxuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBQcm9taXNlPEFwcFJvdXRlclN0YXRlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlcnMgPSB7IHJlc29sdmUsIHJlamVjdCB9XG4gICAgfSlcblxuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAvLyB3ZSBpbW1lZGlhdGVseSBub3RpZnkgUmVhY3Qgb2YgdGhlIHBlbmRpbmcgcHJvbWlzZSAtLSB0aGUgcmVzb2x2ZXIgaXMgYXR0YWNoZWQgdG8gdGhlIGFjdGlvbiBub2RlXG4gICAgICAvLyBhbmQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBhY3Rpb24gcHJvbWlzZSByZXNvbHZlc1xuICAgICAgc2V0U3RhdGUoZGVmZXJyZWRQcm9taXNlKVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBuZXdBY3Rpb246IEFjdGlvblF1ZXVlTm9kZSA9IHtcbiAgICBwYXlsb2FkLFxuICAgIG5leHQ6IG51bGwsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZXJzLnJlc29sdmUsXG4gICAgcmVqZWN0OiByZXNvbHZlcnMucmVqZWN0LFxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5XG4gIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nID09PSBudWxsKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGlzIGVtcHR5LCBzbyBhZGQgdGhlIGFjdGlvbiBhbmQgc3RhcnQgaXQgaW1tZWRpYXRlbHlcbiAgICAvLyBNYXJrIHRoaXMgYWN0aW9uIGFzIHRoZSBsYXN0IGluIHRoZSBxdWV1ZVxuICAgIGFjdGlvblF1ZXVlLmxhc3QgPSBuZXdBY3Rpb25cblxuICAgIHJ1bkFjdGlvbih7XG4gICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgIGFjdGlvbjogbmV3QWN0aW9uLFxuICAgICAgc2V0U3RhdGUsXG4gICAgfSlcbiAgfSBlbHNlIGlmIChcbiAgICBwYXlsb2FkLnR5cGUgPT09IEFDVElPTl9OQVZJR0FURSB8fFxuICAgIHBheWxvYWQudHlwZSA9PT0gQUNUSU9OX1JFU1RPUkVcbiAgKSB7XG4gICAgLy8gTmF2aWdhdGlvbnMgKGluY2x1ZGluZyBiYWNrL2ZvcndhcmQpIHRha2UgcHJpb3JpdHkgb3ZlciBhbnkgcGVuZGluZyBhY3Rpb25zLlxuICAgIC8vIE1hcmsgdGhlIHBlbmRpbmcgYWN0aW9uIGFzIGRpc2NhcmRlZCAoc28gdGhlIHN0YXRlIGlzIG5ldmVyIGFwcGxpZWQpIGFuZCBzdGFydCB0aGUgbmF2aWdhdGlvbiBhY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAgYWN0aW9uUXVldWUucGVuZGluZy5kaXNjYXJkZWQgPSB0cnVlXG5cbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgY3VycmVudCBxdWV1ZSBzaG91bGQgc3RpbGwgZXhlY3V0ZSBhZnRlciB0aGlzIG5hdmlnYXRpb24uXG4gICAgLy8gKE5vdGUgdGhhdCBpdCBjYW4ndCBjb250YWluIGFueSBlYXJsaWVyIG5hdmlnYXRpb25zLCBiZWNhdXNlIHdlIGFsd2F5cyBwdXQgdGhvc2UgaW50byBgYWN0aW9uUXVldWUucGVuZGluZ2AgYnkgY2FsbGluZyBgcnVuQWN0aW9uYClcbiAgICBuZXdBY3Rpb24ubmV4dCA9IGFjdGlvblF1ZXVlLnBlbmRpbmcubmV4dFxuXG4gICAgcnVuQWN0aW9uKHtcbiAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgYWN0aW9uOiBuZXdBY3Rpb24sXG4gICAgICBzZXRTdGF0ZSxcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBub3QgZW1wdHksIHNvIGFkZCB0aGUgYWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG4gICAgLy8gSXQgd2lsbCBiZSBzdGFydGVkIGJ5IHJ1blJlbWFpbmluZ0FjdGlvbnMgYWZ0ZXIgdGhlIHByZXZpb3VzIGFjdGlvbiBmaW5pc2hlc1xuICAgIGlmIChhY3Rpb25RdWV1ZS5sYXN0ICE9PSBudWxsKSB7XG4gICAgICBhY3Rpb25RdWV1ZS5sYXN0Lm5leHQgPSBuZXdBY3Rpb25cbiAgICB9XG4gICAgYWN0aW9uUXVldWUubGFzdCA9IG5ld0FjdGlvblxuICB9XG59XG5cbmxldCBnbG9iYWxBY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUgfCBudWxsID0gbnVsbFxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlKFxuICBpbml0aWFsU3RhdGU6IEFwcFJvdXRlclN0YXRlLFxuICBpbnN0cnVtZW50YXRpb25Ib29rczogQ2xpZW50SW5zdHJ1bWVudGF0aW9uSG9va3MgfCBudWxsXG4pOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSB7XG4gIGNvbnN0IGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSA9IHtcbiAgICBzdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgIGRpc3BhdGNoOiAocGF5bG9hZDogUmVkdWNlckFjdGlvbnMsIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZSkgPT5cbiAgICAgIGRpc3BhdGNoQWN0aW9uKGFjdGlvblF1ZXVlLCBwYXlsb2FkLCBzZXRTdGF0ZSksXG4gICAgYWN0aW9uOiBhc3luYyAoc3RhdGU6IEFwcFJvdXRlclN0YXRlLCBhY3Rpb246IFJlZHVjZXJBY3Rpb25zKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSxcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQ6XG4gICAgICBpbnN0cnVtZW50YXRpb25Ib29rcyAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIGluc3RydW1lbnRhdGlvbkhvb2tzLm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gLy8gVGhpcyBwcm9maWxpbmcgaG9vayB3aWxsIGJlIGNhbGxlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgbmF2aWdhdGlvbi5cbiAgICAgICAgICBpbnN0cnVtZW50YXRpb25Ib29rcy5vblJvdXRlclRyYW5zaXRpb25TdGFydFxuICAgICAgICA6IG51bGwsXG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUaGUgYWN0aW9uIHF1ZXVlIGlzIGxhemlseSBjcmVhdGVkIG9uIGh5ZHJhdGlvbiwgYnV0IGFmdGVyIHRoYXQgcG9pbnRcbiAgICAvLyBpdCBkb2Vzbid0IGNoYW5nZS4gU28gd2UgY2FuIHN0b3JlIGl0IGluIGEgZ2xvYmFsIHJhdGhlciB0aGFuIHBhc3NcbiAgICAvLyBpdCBhcm91bmQgZXZlcnl3aGVyZSB2aWEgcHJvcHMvY29udGV4dC5cbiAgICBpZiAoZ2xvYmFsQWN0aW9uUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludGVybmFsIE5leHQuanMgRXJyb3I6IGNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSB3YXMgY2FsbGVkIG1vcmUgJyArXG4gICAgICAgICAgJ3RoYW4gb25jZSdcbiAgICAgIClcbiAgICB9XG4gICAgZ2xvYmFsQWN0aW9uUXVldWUgPSBhY3Rpb25RdWV1ZVxuICB9XG5cbiAgcmV0dXJuIGFjdGlvblF1ZXVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUoKTogQXBwUm91dGVyU3RhdGUgfCBudWxsIHtcbiAgcmV0dXJuIGdsb2JhbEFjdGlvblF1ZXVlICE9PSBudWxsID8gZ2xvYmFsQWN0aW9uUXVldWUuc3RhdGUgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGdldEFwcFJvdXRlckFjdGlvblF1ZXVlKCk6IEFwcFJvdXRlckFjdGlvblF1ZXVlIHtcbiAgaWYgKGdsb2JhbEFjdGlvblF1ZXVlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludGVybmFsIE5leHQuanMgZXJyb3I6IFJvdXRlciBhY3Rpb24gZGlzcGF0Y2hlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24uJ1xuICAgIClcbiAgfVxuICByZXR1cm4gZ2xvYmFsQWN0aW9uUXVldWVcbn1cblxuZnVuY3Rpb24gZ2V0UHJvZmlsaW5nSG9va0Zvck9uTmF2aWdhdGlvblN0YXJ0KCkge1xuICBpZiAoZ2xvYmFsQWN0aW9uUXVldWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2xvYmFsQWN0aW9uUXVldWUub25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbihcbiAgaHJlZjogc3RyaW5nLFxuICBuYXZpZ2F0ZVR5cGU6IE5hdmlnYXRlQWN0aW9uWyduYXZpZ2F0ZVR5cGUnXSxcbiAgc2hvdWxkU2Nyb2xsOiBib29sZWFuLFxuICBsaW5rSW5zdGFuY2VSZWY6IExpbmtJbnN0YW5jZSB8IG51bGxcbik6IHZvaWQge1xuICAvLyBUT0RPOiBUaGlzIHN0dWZmIGNvdWxkIGp1c3QgZ28gaW50byB0aGUgcmVkdWNlci4gTGVhdmluZyBhcy1pcyBmb3Igbm93XG4gIC8vIHNpbmNlIHdlJ3JlIGFib3V0IHRvIHJld3JpdGUgYWxsIHRoZSByb3V0ZXIgcmVkdWNlciBzdHVmZiBhbnl3YXkuXG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoYWRkQmFzZVBhdGgoaHJlZiksIGxvY2F0aW9uLmhyZWYpXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgd2luZG93Lm5leHQuX19wZW5kaW5nVXJsID0gdXJsXG4gIH1cblxuICBzZXRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24obGlua0luc3RhbmNlUmVmKVxuXG4gIGNvbnN0IG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ID0gZ2V0UHJvZmlsaW5nSG9va0Zvck9uTmF2aWdhdGlvblN0YXJ0KClcbiAgaWYgKG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ICE9PSBudWxsKSB7XG4gICAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQoaHJlZiwgbmF2aWdhdGVUeXBlKVxuICB9XG5cbiAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgIHR5cGU6IEFDVElPTl9OQVZJR0FURSxcbiAgICB1cmwsXG4gICAgaXNFeHRlcm5hbFVybDogaXNFeHRlcm5hbFVSTCh1cmwpLFxuICAgIGxvY2F0aW9uU2VhcmNoOiBsb2NhdGlvbi5zZWFyY2gsXG4gICAgc2hvdWxkU2Nyb2xsLFxuICAgIG5hdmlnYXRlVHlwZSxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3BhdGNoVHJhdmVyc2VBY3Rpb24oXG4gIGhyZWY6IHN0cmluZyxcbiAgaGlzdG9yeVN0YXRlOiBBcHBIaXN0b3J5U3RhdGUgfCB1bmRlZmluZWRcbikge1xuICBjb25zdCBvblJvdXRlclRyYW5zaXRpb25TdGFydCA9IGdldFByb2ZpbGluZ0hvb2tGb3JPbk5hdmlnYXRpb25TdGFydCgpXG4gIGlmIChvblJvdXRlclRyYW5zaXRpb25TdGFydCAhPT0gbnVsbCkge1xuICAgIG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0KGhyZWYsICd0cmF2ZXJzZScpXG4gIH1cbiAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgIHVybDogbmV3IFVSTChocmVmKSxcbiAgICBoaXN0b3J5U3RhdGUsXG4gIH0pXG59XG5cbi8qKlxuICogVGhlIGFwcCByb3V0ZXIgdGhhdCBpcyBleHBvc2VkIHRocm91Z2ggYHVzZVJvdXRlcmAuIFRoZXNlIGFyZSBwdWJsaWMgQVBJXG4gKiBtZXRob2RzLiBJbnRlcm5hbCBOZXh0LmpzIGNvZGUgc2hvdWxkIGNhbGwgdGhlIGxvd2VyIGxldmVsIG1ldGhvZHMgZGlyZWN0bHlcbiAqIChhbHRob3VnaCB0aGVyZSdzIGxvdHMgb2YgZXhpc3RpbmcgY29kZSB0aGF0IGRvZXNuJ3QgZG8gdGhhdCkuXG4gKi9cbmV4cG9ydCBjb25zdCBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZTogQXBwUm91dGVySW5zdGFuY2UgPSB7XG4gIGJhY2s6ICgpID0+IHdpbmRvdy5oaXN0b3J5LmJhY2soKSxcbiAgZm9yd2FyZDogKCkgPT4gd2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpLFxuICBwcmVmZXRjaDpcbiAgICAvLyBVbmxpa2UgdGhlIG9sZCBpbXBsZW1lbnRhdGlvbiwgdGhlIFNlZ21lbnQgQ2FjaGUgZG9lc24ndCBzdG9yZSBpdHNcbiAgICAvLyBkYXRhIGluIHRoZSByb3V0ZXIgcmVkdWNlciBzdGF0ZTsgaXQgd3JpdGVzIGludG8gYSBnbG9iYWwgbXV0YWJsZVxuICAgIC8vIGNhY2hlLiBTbyB3ZSBkb24ndCBuZWVkIHRvIGRpc3BhdGNoIGFuIGFjdGlvbi5cbiAgICAoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogUHJlZmV0Y2hPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBhY3Rpb25RdWV1ZSA9IGdldEFwcFJvdXRlckFjdGlvblF1ZXVlKClcbiAgICAgIGNvbnN0IHByZWZldGNoS2luZCA9IG9wdGlvbnM/LmtpbmQgPz8gUHJlZmV0Y2hLaW5kLkFVVE9cblxuICAgICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IG9mZmVyIGEgd2F5IHRvIGlzc3VlIGEgcnVudGltZSBwcmVmZXRjaCB2aWEgYHJvdXRlci5wcmVmZXRjaCgpYC5cbiAgICAgIC8vIFRoaXMgd2lsbCBiZSBwb3NzaWJsZSB3aGVuIHdlIHVwZGF0ZSBpdHMgQVBJIHRvIG5vdCB0YWtlIGEgUHJlZmV0Y2hLaW5kLlxuICAgICAgbGV0IGZldGNoU3RyYXRlZ3k6IFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3lcbiAgICAgIHN3aXRjaCAocHJlZmV0Y2hLaW5kKSB7XG4gICAgICAgIGNhc2UgUHJlZmV0Y2hLaW5kLkFVVE86IHtcbiAgICAgICAgICAvLyBXZSBkZWZhdWx0IHRvIFBQUi4gV2UnbGwgZGlzY292ZXIgd2hldGhlciBvciBub3QgdGhlIHJvdXRlIHN1cHBvcnRzIGl0IHdpdGggdGhlIGluaXRpYWwgcHJlZmV0Y2guXG4gICAgICAgICAgZmV0Y2hTdHJhdGVneSA9IEZldGNoU3RyYXRlZ3kuUFBSXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFByZWZldGNoS2luZC5GVUxMOiB7XG4gICAgICAgICAgZmV0Y2hTdHJhdGVneSA9IEZldGNoU3RyYXRlZ3kuRnVsbFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHByZWZldGNoS2luZCBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgICAgICAvLyBEZXNwaXRlIHR5cGVzY3JpcHQgdGhpbmtpbmcgdGhhdCB0aGlzIGNhbid0IGhhcHBlbixcbiAgICAgICAgICAvLyB3ZSBtaWdodCBnZXQgYW4gdW5leHBlY3RlZCB2YWx1ZSBmcm9tIHVzZXIgY29kZS5cbiAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHdoYXQgdGhleSB3YW50LCBidXQgd2Uga25vdyB0aGV5IHdhbnQgYSBwcmVmZXRjaCxcbiAgICAgICAgICAvLyBzbyB1c2UgdGhlIGRlZmF1bHQuXG4gICAgICAgICAgZmV0Y2hTdHJhdGVneSA9IEZldGNoU3RyYXRlZ3kuUFBSXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlKFxuICAgICAgICBocmVmLFxuICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZS5uZXh0VXJsLFxuICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZS50cmVlLFxuICAgICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgICBvcHRpb25zPy5vbkludmFsaWRhdGUgPz8gbnVsbFxuICAgICAgKVxuICAgIH0sXG4gIHJlcGxhY2U6IChocmVmOiBzdHJpbmcsIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbihocmVmLCAncmVwbGFjZScsIG9wdGlvbnM/LnNjcm9sbCA/PyB0cnVlLCBudWxsKVxuICAgIH0pXG4gIH0sXG4gIHB1c2g6IChocmVmOiBzdHJpbmcsIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbihocmVmLCAncHVzaCcsIG9wdGlvbnM/LnNjcm9sbCA/PyB0cnVlLCBudWxsKVxuICAgIH0pXG4gIH0sXG4gIHJlZnJlc2g6ICgpID0+IHtcbiAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiBBQ1RJT05fUkVGUkVTSCxcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgaG1yUmVmcmVzaDogKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaG1yUmVmcmVzaCBjYW4gb25seSBiZSB1c2VkIGluIGRldmVsb3BtZW50IG1vZGUuIFBsZWFzZSB1c2UgcmVmcmVzaCBpbnN0ZWFkLidcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9LFxufVxuXG4vLyBFeGlzdHMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gRG9uJ3QgdXNlIGluIGFwcGxpY2F0aW9uIGNvZGUuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5leHQpIHtcbiAgd2luZG93Lm5leHQucm91dGVyID0gcHVibGljQXBwUm91dGVySW5zdGFuY2Vcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUiLCJkaXNwYXRjaE5hdmlnYXRlQWN0aW9uIiwiZGlzcGF0Y2hUcmF2ZXJzZUFjdGlvbiIsImdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSIsInB1YmxpY0FwcFJvdXRlckluc3RhbmNlIiwicnVuUmVtYWluaW5nQWN0aW9ucyIsImFjdGlvblF1ZXVlIiwic2V0U3RhdGUiLCJwZW5kaW5nIiwibmV4dCIsInJ1bkFjdGlvbiIsImFjdGlvbiIsIm5lZWRzUmVmcmVzaCIsImRpc3BhdGNoIiwidHlwZSIsIkFDVElPTl9SRUZSRVNIIiwicHJldlN0YXRlIiwic3RhdGUiLCJwYXlsb2FkIiwiYWN0aW9uUmVzdWx0IiwiaGFuZGxlUmVzdWx0IiwibmV4dFN0YXRlIiwiZGlzY2FyZGVkIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJkaWRSZXZhbGlkYXRlIiwicmVzb2x2ZSIsImlzVGhlbmFibGUiLCJ0aGVuIiwiZXJyIiwicmVqZWN0IiwiZGlzcGF0Y2hBY3Rpb24iLCJyZXNvbHZlcnMiLCJBQ1RJT05fUkVTVE9SRSIsImRlZmVycmVkUHJvbWlzZSIsIlByb21pc2UiLCJzdGFydFRyYW5zaXRpb24iLCJuZXdBY3Rpb24iLCJsYXN0IiwiQUNUSU9OX05BVklHQVRFIiwiZ2xvYmFsQWN0aW9uUXVldWUiLCJpbml0aWFsU3RhdGUiLCJpbnN0cnVtZW50YXRpb25Ib29rcyIsInJlc3VsdCIsInJlZHVjZXIiLCJvblJvdXRlclRyYW5zaXRpb25TdGFydCIsIndpbmRvdyIsIkVycm9yIiwiZ2V0QXBwUm91dGVyQWN0aW9uUXVldWUiLCJnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQiLCJocmVmIiwibmF2aWdhdGVUeXBlIiwic2hvdWxkU2Nyb2xsIiwibGlua0luc3RhbmNlUmVmIiwidXJsIiwiVVJMIiwiYWRkQmFzZVBhdGgiLCJsb2NhdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HIiwiX19wZW5kaW5nVXJsIiwic2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJpc0V4dGVybmFsVXJsIiwiaXNFeHRlcm5hbFVSTCIsImxvY2F0aW9uU2VhcmNoIiwic2VhcmNoIiwiaGlzdG9yeVN0YXRlIiwiYmFjayIsImhpc3RvcnkiLCJmb3J3YXJkIiwicHJlZmV0Y2giLCJvcHRpb25zIiwicHJlZmV0Y2hLaW5kIiwia2luZCIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJmZXRjaFN0cmF0ZWd5IiwiRmV0Y2hTdHJhdGVneSIsIlBQUiIsIkZVTEwiLCJGdWxsIiwicHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlIiwibmV4dFVybCIsInRyZWUiLCJvbkludmFsaWRhdGUiLCJyZXBsYWNlIiwic2Nyb2xsIiwicHVzaCIsInJlZnJlc2giLCJobXJSZWZyZXNoIiwiTk9ERV9FTlYiLCJBQ1RJT05fSE1SX1JFRlJFU0giLCJyb3V0ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/app-router-instance.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router-utils.js":
/*!***********************************************************************!*\
  !*** ../node_modules/next/dist/client/components/app-router-utils.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    isExternalURL: function() {\n        return isExternalURL;\n    }\n});\nconst _isbot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/../node_modules/next/dist/client/add-base-path.js\");\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw Object.defineProperty(new Error(`Cannot prefetch '${href}' because it cannot be converted to a URL.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E234\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (true) {\n        return null;\n    }\n    // External urls can't be prefetched in the same way.\n    if (isExternalURL(url)) {\n        return null;\n    }\n    return url;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBY2dCQSxpQkFBaUI7ZUFBakJBOztJQVhBQyxhQUFhO2VBQWJBOzs7bUNBSE07eUNBQ007QUFFckIsU0FBU0EsY0FBY0MsR0FBUTtJQUNwQyxPQUFPQSxJQUFJQyxNQUFNLEtBQUtDLE9BQU9DLFFBQVEsQ0FBQ0YsTUFBTTtBQUM5QztBQVNPLFNBQVNILGtCQUFrQk0sSUFBWTtJQUM1QyxrREFBa0Q7SUFDbEQsSUFBSUMsQ0FBQUEsR0FBQUEsT0FBQUEsS0FBSyxFQUFDSCxPQUFPSSxTQUFTLENBQUNDLFNBQVMsR0FBRztRQUNyQyxPQUFPO0lBQ1Q7SUFFQSxJQUFJUDtJQUNKLElBQUk7UUFDRkEsTUFBTSxJQUFJUSxJQUFJQyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFBQSxFQUFZTCxPQUFPRixPQUFPQyxRQUFRLENBQUNDLElBQUk7SUFDdkQsRUFBRSxPQUFPTSxHQUFHO1FBQ1YsMkVBQTJFO1FBQzNFLGtEQUFrRDtRQUNsRCxNQUFNLHFCQUVMLENBRkssSUFBSUMsTUFDUixDQUFDLGlCQUFpQixFQUFFUCxLQUFLLDBDQUEwQyxDQUFDLEdBRGhFO21CQUFBO3dCQUFBOzBCQUFBO1FBRU47SUFDRjtJQUVBLHVFQUF1RTtJQUN2RSxJQUFJUSxJQUFvQixFQUFvQjtRQUMxQyxPQUFPO0lBQ1Q7SUFFQSxxREFBcUQ7SUFDckQsSUFBSWIsY0FBY0MsTUFBTTtRQUN0QixPQUFPO0lBQ1Q7SUFFQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvdml0YWxpeXVsaXRvdnNreS9zcmMvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0JvdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWJvdCdcbmltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi4vYWRkLWJhc2UtcGF0aCdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxVUkwodXJsOiBVUkwpIHtcbiAgcmV0dXJuIHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpbmsgaHJlZiwgY29uc3RydWN0cyB0aGUgVVJMIHRoYXQgc2hvdWxkIGJlIHByZWZldGNoZWQuIFJldHVybnMgbnVsbFxuICogaW4gY2FzZXMgd2hlcmUgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkLCBsaWtlIGV4dGVybmFsIFVSTHMsIG9yXG4gKiBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gKiBAcGFyYW0gaHJlZiBUaGUgaHJlZiBwYXNzZWQgdG8gPExpbms+LCByb3V0ZXIucHJlZmV0Y2goKSwgb3Igc2ltaWxhclxuICogQHJldHVybnMgQSBVUkwgb2JqZWN0IHRvIHByZWZldGNoLCBvciBudWxsIGlmIHByZWZldGNoaW5nIHNob3VsZCBiZSBkaXNhYmxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hVUkwoaHJlZjogc3RyaW5nKTogVVJMIHwgbnVsbCB7XG4gIC8vIERvbid0IHByZWZldGNoIGZvciBib3RzIGFzIHRoZXkgZG9uJ3QgbmF2aWdhdGUuXG4gIGlmIChpc0JvdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IHVybDogVVJMXG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChhZGRCYXNlUGF0aChocmVmKSwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBUT0RPOiBEb2VzIHRoaXMgbmVlZCB0byB0aHJvdyBvciBjYW4gd2UganVzdCBjb25zb2xlLmVycm9yIGluc3RlYWQ/IERvZXNcbiAgICAvLyBhbnlvbmUgcmVseSBvbiB0aGlzIHRocm93aW5nPyAoU2VlbXMgdW5saWtlbHkuKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgcHJlZmV0Y2ggJyR7aHJlZn0nIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFVSTC5gXG4gICAgKVxuICB9XG5cbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZHVyaW5nIGRldmVsb3BtZW50IChpbXByb3ZlcyBjb21waWxhdGlvbiBwZXJmb3JtYW5jZSlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEV4dGVybmFsIHVybHMgY2FuJ3QgYmUgcHJlZmV0Y2hlZCBpbiB0aGUgc2FtZSB3YXkuXG4gIGlmIChpc0V4dGVybmFsVVJMKHVybCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHVybFxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZVByZWZldGNoVVJMIiwiaXNFeHRlcm5hbFVSTCIsInVybCIsIm9yaWdpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiVVJMIiwiYWRkQmFzZVBhdGgiLCJfIiwiRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/app-router-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/app-router.js":
/*!*****************************************************************!*\
  !*** ../node_modules/next/dist/client/components/app-router.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return AppRouter;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _createhreffromurl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/../node_modules/next/dist/client/components/use-action-queue.js\");\nconst _approuterannouncer = __webpack_require__(/*! ./app-router-announcer */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-announcer.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/../node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _findheadincache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/../node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _removebasepath = __webpack_require__(/*! ../remove-base-path */ \"(app-pages-browser)/../node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../has-base-path */ \"(app-pages-browser)/../node_modules/next/dist/client/has-base-path.js\");\nconst _computechangedpath = __webpack_require__(/*! ./router-reducer/compute-changed-path */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _navfailurehandler = __webpack_require__(/*! ./nav-failure-handler */ \"(app-pages-browser)/../node_modules/next/dist/client/components/nav-failure-handler.js\");\nconst _approuterinstance = __webpack_require__(/*! ./app-router-instance */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-instance.js\");\nconst _redirect = __webpack_require__(/*! ./redirect */ \"(app-pages-browser)/../node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ./redirect-error */ \"(app-pages-browser)/../node_modules/next/dist/client/components/redirect-error.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/../node_modules/next/dist/client/components/links.js\");\nconst _rooterrorboundary = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./errors/root-error-boundary */ \"(app-pages-browser)/../node_modules/next/dist/client/components/errors/root-error-boundary.js\"));\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./builtin/global-error */ \"(app-pages-browser)/../node_modules/next/dist/client/components/builtin/global-error.js\"));\nconst _boundarycomponents = __webpack_require__(/*! ../../lib/framework/boundary-components */ \"(app-pages-browser)/../node_modules/next/dist/lib/framework/boundary-components.js\");\nconst _deploymentid = __webpack_require__(/*! ../../shared/lib/deployment-id */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/deployment-id.js\");\nconst globalMutable = {};\nfunction HistoryUpdater({ appRouterState }) {\n    (0, _react.useInsertionEffect)(()=>{\n        if (false) {}\n        const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState;\n        const appHistoryState = {\n            tree,\n            renderedSearch\n        };\n        // TODO: Use Navigation API if available\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    (0, _react.useEffect)(()=>{\n        // The Next-Url and the base tree may affect the result of a prefetch\n        // task. Re-prefetch all visible links with the updated values. In most\n        // cases, this will not result in any new network requests, only if\n        // the prefetch result actually varies on one of these inputs.\n        (0, _links.pingVisibleLinks)(appRouterState.nextUrl, appRouterState.tree);\n    }, [\n        appRouterState.nextUrl,\n        appRouterState.tree\n    ]);\n    return null;\n}\n_c = HistoryUpdater;\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState?.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head({ headCacheNode }) {\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n_c1 = Head;\n/**\n * The global router that wraps the application components.\n */ function Router({ actionQueue, globalError, webSocket, staticIndicatorState }) {\n    const state = (0, _useactionqueue.useActionQueue)(actionQueue);\n    const { canonicalUrl } = state;\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    if (true) {\n        const { cache, tree } = state;\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: _approuterinstance.publicAppRouterInstance,\n                cache,\n                tree\n            };\n        }, [\n            cache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            if (!event.persisted || !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, []);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                // TODO: This should access the router methods directly, rather than\n                // go through the public interface.\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    _approuterinstance.publicAppRouterInstance.push(url, {});\n                } else {\n                    _approuterinstance.publicAppRouterInstance.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, []);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = state;\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location = window.location;\n            if (pushRef.pendingPush) {\n                location.assign(canonicalUrl);\n            } else {\n                location.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        // NOTE: This is intentionally using `throw` instead of `use` because we're\n        // inside an externally mutable condition (pushRef.mpaNavigation), which\n        // violates the rules of hooks.\n        throw _unresolvedthenable.unresolvedThenable;\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            const href = window.location.href;\n            const appHistoryState = window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url ?? href, href),\n                    historyState: appHistoryState\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if (data?.__NA || data?._N) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if (data?.__NA || data?._N) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                (0, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, []);\n    const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state;\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    // Create instrumented promises for navigation hooks (dev-only)\n    // These are specially instrumented promises to show in the Suspense DevTools\n    // Promises are cached outside of render to survive suspense retries.\n    let instrumentedNavigationPromises = null;\n    if (true) {\n        const { createRootNavigationPromises } = __webpack_require__(/*! ./navigation-devtools */ \"(app-pages-browser)/../node_modules/next/dist/client/components/navigation-devtools.js\");\n        instrumentedNavigationPromises = createRootNavigationPromises(tree, pathname, searchParams, pathParams);\n    }\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            parentTree: tree,\n            parentCacheNode: cache,\n            parentSegmentPath: null,\n            parentParams: {},\n            // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n            // It represents the root of the app.\n            debugNameContext: '/',\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl,\n            // Root segment is always active\n            isActive: true\n        };\n    }, [\n        tree,\n        cache,\n        canonicalUrl\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            tree,\n            focusAndScrollRef,\n            nextUrl,\n            previousNextUrl\n        };\n    }, [\n        tree,\n        focusAndScrollRef,\n        nextUrl,\n        previousNextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        },  false ? 0 : headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_boundarycomponents.RootLayoutBoundary, {\n                children: cache.rsc\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (true) {\n        // In development, we apply few error boundaries and hot-reloader:\n        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n        // - HotReloader:\n        //  - hot-reload the app when the code changes\n        //  - render dev overlay\n        //  - catch runtime errors and display global-error when necessary\n        if (true) {\n            const { DevRootHTTPAccessFallbackBoundary } = __webpack_require__(/*! ./dev-root-http-access-fallback-boundary */ \"(app-pages-browser)/../node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js\");\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = (__webpack_require__(/*! ../dev/hot-reloader/app/hot-reloader-app */ \"(app-pages-browser)/../node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js\")[\"default\"]);\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            globalError: globalError,\n            webSocket: webSocket,\n            staticIndicatorState: staticIndicatorState,\n            children: content\n        });\n    } else {}\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: state\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.NavigationPromisesContext.Provider, {\n                value: instrumentedNavigationPromises,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                    value: pathParams,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                        value: pathname,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                            value: searchParams,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                                value: globalLayoutRouterContext,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                    value: _approuterinstance.publicAppRouterInstance,\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                        value: layoutRouterContext,\n                                        children: content\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\n_c2 = Router;\nfunction AppRouter({ actionQueue, globalErrorState, webSocket, staticIndicatorState }) {\n    (0, _navfailurehandler.useNavFailureHandler)();\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n        actionQueue: actionQueue,\n        globalError: globalErrorState,\n        webSocket: webSocket,\n        staticIndicatorState: staticIndicatorState\n    });\n    // At the very top level, use the default GlobalError component as the final fallback.\n    // When the app router itself fails, which means the framework itself fails, we show the default error.\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_rooterrorboundary.default, {\n        errorComponent: _globalerror.default,\n        children: router\n    });\n}\n_c3 = AppRouter;\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    _s();\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId = (0, _deploymentid.getDeploymentIdQueryOrEmptyString)();\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: `${href}${dplId}`,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\n_s(RuntimeStyles, \"Eht7Kgdrrgt5B4LSklQ7qDPo8Aw=\");\n_c4 = RuntimeStyles;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"HistoryUpdater\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Router\");\n$RefreshReg$(_c3, \"AppRouter\");\n$RefreshReg$(_c4, \"RuntimeStyles\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OzJDQXlpQkE7OztlQUF3QkE7Ozs7Ozs2RUFuaUJqQjsyREFLQTtnREFFd0I7K0NBS0c7NkRBTzNCOzRDQUNpRDtnREFDckI7OENBQ0Y7NkNBQ0Q7Z0RBQ0c7NENBQ0o7eUNBQ0g7Z0RBQ007K0NBQ0c7K0NBTTlCO3NDQUMyRDsyQ0FDcEI7bUNBQ2I7d0ZBQ0g7a0ZBQ0M7Z0RBQ0k7MENBRWU7QUFFbEQsTUFBTUMsZ0JBRUYsQ0FBQztBQUVMLHdCQUF3QixFQUN0QkUsY0FBYyxFQUdmO0lBQ0NDLENBQUFBLEdBQUFBLE9BQUFBLGtCQUFBQSxFQUFtQjtRQUNqQixJQUFJQyxLQUF3QyxFQUFFLEVBSTdDO1FBRUQsTUFBTSxFQUFFTyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsWUFBWSxFQUFFQyxjQUFjLEVBQUUsR0FBR1o7UUFFeEQsTUFBTWEsa0JBQW1DO1lBQ3ZDSjtZQUNBRztRQUNGO1FBRUEsd0NBQXdDO1FBQ3hDLE1BQU1FLGVBQWU7WUFDbkIsR0FBSUosUUFBUUssMEJBQTBCLEdBQUdWLE9BQU9XLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHLENBQUMsQ0FBQztZQUNsRSx5Q0FBeUM7WUFDekMsa0ZBQWtGO1lBQ2xGLGlGQUFpRjtZQUNqRkMsTUFBTTtZQUNOQyxpQ0FBaUNOO1FBQ25DO1FBQ0EsSUFDRUgsUUFBUVUsV0FBVyxJQUNuQiwrRkFBK0Y7UUFDL0YsMkRBQTJEO1FBQzNEQyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCLElBQUlDLElBQUlqQixPQUFPa0IsUUFBUSxDQUFDQyxJQUFJLE9BQU9iLGNBQ3JEO1lBQ0EscUpBQXFKO1lBQ3JKRCxRQUFRVSxXQUFXLEdBQUc7WUFDdEJmLE9BQU9XLE9BQU8sQ0FBQ1MsU0FBUyxDQUFDWCxjQUFjLElBQUlIO1FBQzdDLE9BQU87WUFD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TztZQUNMZCxvQkFBb0JnQixNQUFNLENBQUNGO1FBQzdCO0lBQ0YsR0FBRztRQUFDRDtRQUFvQkg7S0FBWTtJQUVwQyxNQUFNTyxRQUFRQyxDQUFBQSxHQUFBQSxjQUFBQSxpQ0FBQUE7SUFDZCxPQUFPO1dBQUlwQjtLQUFjLENBQUNxQixHQUFHLENBQUMsQ0FBQ2pJLE1BQU1rSSxJQUFBQSxXQUFBQSxHQUNuQyxxQkFBQ0MsUUFBQUE7WUFFQ0MsS0FBSTtZQUNKcEksTUFBTSxHQUFHQSxPQUFPK0gsT0FBTztZQUN2QixhQUFhO1lBQ2JNLFlBQVc7V0FKTkg7QUFVWDs7TUEzQlNuQyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpdGFsaXl1bGl0b3Zza3kvc3JjL2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge1xuICB1c2VFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHN0YXJ0VHJhbnNpdGlvbixcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0LFxuICB1c2VEZWZlcnJlZFZhbHVlLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIEFwcFJvdXRlckNvbnRleHQsXG4gIExheW91dFJvdXRlckNvbnRleHQsXG4gIEdsb2JhbExheW91dFJvdXRlckNvbnRleHQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItdHlwZXMnXG5pbXBvcnQgeyBBQ1RJT05fUkVTVE9SRSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIEFwcEhpc3RvcnlTdGF0ZSxcbiAgQXBwUm91dGVyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQge1xuICBTZWFyY2hQYXJhbXNDb250ZXh0LFxuICBQYXRobmFtZUNvbnRleHQsXG4gIFBhdGhQYXJhbXNDb250ZXh0LFxuICBOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0LFxuICB0eXBlIE5hdmlnYXRpb25Qcm9taXNlcyxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uLCB1c2VBY3Rpb25RdWV1ZSB9IGZyb20gJy4vdXNlLWFjdGlvbi1xdWV1ZSdcbmltcG9ydCB7IEFwcFJvdXRlckFubm91bmNlciB9IGZyb20gJy4vYXBwLXJvdXRlci1hbm5vdW5jZXInXG5pbXBvcnQgeyBSZWRpcmVjdEJvdW5kYXJ5IH0gZnJvbSAnLi9yZWRpcmVjdC1ib3VuZGFyeSdcbmltcG9ydCB7IGZpbmRIZWFkSW5DYWNoZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlJ1xuaW1wb3J0IHsgdW5yZXNvbHZlZFRoZW5hYmxlIH0gZnJvbSAnLi91bnJlc29sdmVkLXRoZW5hYmxlJ1xuaW1wb3J0IHsgcmVtb3ZlQmFzZVBhdGggfSBmcm9tICcuLi9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgZ2V0U2VsZWN0ZWRQYXJhbXMgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2NvbXB1dGUtY2hhbmdlZC1wYXRoJ1xuaW1wb3J0IHsgdXNlTmF2RmFpbHVyZUhhbmRsZXIgfSBmcm9tICcuL25hdi1mYWlsdXJlLWhhbmRsZXInXG5pbXBvcnQge1xuICBkaXNwYXRjaFRyYXZlcnNlQWN0aW9uLFxuICBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgdHlwZSBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSxcbiAgdHlwZSBHbG9iYWxFcnJvclN0YXRlLFxufSBmcm9tICcuL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IsIGdldFVSTEZyb21SZWRpcmVjdEVycm9yIH0gZnJvbSAnLi9yZWRpcmVjdCdcbmltcG9ydCB7IGlzUmVkaXJlY3RFcnJvciwgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcbmltcG9ydCB7IHBpbmdWaXNpYmxlTGlua3MgfSBmcm9tICcuL2xpbmtzJ1xuaW1wb3J0IFJvb3RFcnJvckJvdW5kYXJ5IGZyb20gJy4vZXJyb3JzL3Jvb3QtZXJyb3ItYm91bmRhcnknXG5pbXBvcnQgRGVmYXVsdEdsb2JhbEVycm9yIGZyb20gJy4vYnVpbHRpbi9nbG9iYWwtZXJyb3InXG5pbXBvcnQgeyBSb290TGF5b3V0Qm91bmRhcnkgfSBmcm9tICcuLi8uLi9saWIvZnJhbWV3b3JrL2JvdW5kYXJ5LWNvbXBvbmVudHMnXG5pbXBvcnQgdHlwZSB7IFN0YXRpY0luZGljYXRvclN0YXRlIH0gZnJvbSAnLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCdcbmltcG9ydCB7IGdldERlcGxveW1lbnRJZFF1ZXJ5T3JFbXB0eVN0cmluZyB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvZGVwbG95bWVudC1pZCdcblxuY29uc3QgZ2xvYmFsTXV0YWJsZToge1xuICBwZW5kaW5nTXBhUGF0aD86IHN0cmluZ1xufSA9IHt9XG5cbmZ1bmN0aW9uIEhpc3RvcnlVcGRhdGVyKHtcbiAgYXBwUm91dGVyU3RhdGUsXG59OiB7XG4gIGFwcFJvdXRlclN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxufSkge1xuICB1c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgICAvLyBjbGVhciBwZW5kaW5nIFVSTCBhcyBuYXZpZ2F0aW9uIGlzIG5vIGxvbmdlclxuICAgICAgLy8gaW4gZmxpZ2h0XG4gICAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCB7IHRyZWUsIHB1c2hSZWYsIGNhbm9uaWNhbFVybCwgcmVuZGVyZWRTZWFyY2ggfSA9IGFwcFJvdXRlclN0YXRlXG5cbiAgICBjb25zdCBhcHBIaXN0b3J5U3RhdGU6IEFwcEhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgIHRyZWUsXG4gICAgICByZW5kZXJlZFNlYXJjaCxcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgTmF2aWdhdGlvbiBBUEkgaWYgYXZhaWxhYmxlXG4gICAgY29uc3QgaGlzdG9yeVN0YXRlID0ge1xuICAgICAgLi4uKHB1c2hSZWYucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPyB3aW5kb3cuaGlzdG9yeS5zdGF0ZSA6IHt9KSxcbiAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAvLyBfX04gaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgb2xkIHJvdXRlci5cbiAgICAgIF9fTkE6IHRydWUsXG4gICAgICBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFOiBhcHBIaXN0b3J5U3RhdGUsXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHB1c2hSZWYucGVuZGluZ1B1c2ggJiZcbiAgICAgIC8vIFNraXAgcHVzaGluZyBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkgaWYgdGhlIGNhbm9uaWNhbFVybCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB1cmwuXG4gICAgICAvLyBUaGlzIG1pcnJvcnMgdGhlIGJyb3dzZXIgYmVoYXZpb3IgZm9yIG5vcm1hbCBuYXZpZ2F0aW9uLlxuICAgICAgY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmxcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2VcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpXG4gICAgfVxuICB9LCBbYXBwUm91dGVyU3RhdGVdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVGhlIE5leHQtVXJsIGFuZCB0aGUgYmFzZSB0cmVlIG1heSBhZmZlY3QgdGhlIHJlc3VsdCBvZiBhIHByZWZldGNoXG4gICAgLy8gdGFzay4gUmUtcHJlZmV0Y2ggYWxsIHZpc2libGUgbGlua3Mgd2l0aCB0aGUgdXBkYXRlZCB2YWx1ZXMuIEluIG1vc3RcbiAgICAvLyBjYXNlcywgdGhpcyB3aWxsIG5vdCByZXN1bHQgaW4gYW55IG5ldyBuZXR3b3JrIHJlcXVlc3RzLCBvbmx5IGlmXG4gICAgLy8gdGhlIHByZWZldGNoIHJlc3VsdCBhY3R1YWxseSB2YXJpZXMgb24gb25lIG9mIHRoZXNlIGlucHV0cy5cbiAgICBwaW5nVmlzaWJsZUxpbmtzKGFwcFJvdXRlclN0YXRlLm5leHRVcmwsIGFwcFJvdXRlclN0YXRlLnRyZWUpXG4gIH0sIFthcHBSb3V0ZXJTdGF0ZS5uZXh0VXJsLCBhcHBSb3V0ZXJTdGF0ZS50cmVlXSlcblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YTogYW55KSB7XG4gIGlmIChkYXRhID09IG51bGwpIGRhdGEgPSB7fVxuICBjb25zdCBjdXJyZW50U3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICBjb25zdCBfX05BID0gY3VycmVudFN0YXRlPy5fX05BXG4gIGlmIChfX05BKSB7XG4gICAgZGF0YS5fX05BID0gX19OQVxuICB9XG4gIGNvbnN0IF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUgPVxuICAgIGN1cnJlbnRTdGF0ZT8uX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICBpZiAoX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSkge1xuICAgIGRhdGEuX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSA9IF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgfVxuXG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIEhlYWQoe1xuICBoZWFkQ2FjaGVOb2RlLFxufToge1xuICBoZWFkQ2FjaGVOb2RlOiBDYWNoZU5vZGUgfCBudWxsXG59KTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgLy8gSWYgdGhpcyBzZWdtZW50IGhhcyBhIGBwcmVmZXRjaEhlYWRgLCBpdCdzIHRoZSBzdGF0aWNhbGx5IHByZWZldGNoZWQgZGF0YS5cbiAgLy8gV2Ugc2hvdWxkIHVzZSB0aGF0IG9uIGluaXRpYWwgcmVuZGVyIGluc3RlYWQgb2YgYGhlYWRgLiBUaGVuIHdlJ2xsIHN3aXRjaFxuICAvLyB0byBgaGVhZGAgd2hlbiB0aGUgZHluYW1pYyByZXNwb25zZSBzdHJlYW1zIGluLlxuICBjb25zdCBoZWFkID0gaGVhZENhY2hlTm9kZSAhPT0gbnVsbCA/IGhlYWRDYWNoZU5vZGUuaGVhZCA6IG51bGxcbiAgY29uc3QgcHJlZmV0Y2hIZWFkID1cbiAgICBoZWFkQ2FjaGVOb2RlICE9PSBudWxsID8gaGVhZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQgOiBudWxsXG5cbiAgLy8gSWYgbm8gcHJlZmV0Y2ggZGF0YSBpcyBhdmFpbGFibGUsIHRoZW4gd2UgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIGBoZWFkYC5cbiAgY29uc3QgcmVzb2x2ZWRQcmVmZXRjaFJzYyA9IHByZWZldGNoSGVhZCAhPT0gbnVsbCA/IHByZWZldGNoSGVhZCA6IGhlYWRcblxuICAvLyBXZSB1c2UgYHVzZURlZmVycmVkVmFsdWVgIHRvIGhhbmRsZSBzd2l0Y2hpbmcgYmV0d2VlbiB0aGUgcHJlZmV0Y2hlZCBhbmRcbiAgLy8gZmluYWwgdmFsdWVzLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHJldHVybmVkIG9uIGluaXRpYWwgcmVuZGVyLCB0aGVuIGl0XG4gIC8vIHJlLXJlbmRlcnMgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQuXG4gIHJldHVybiB1c2VEZWZlcnJlZFZhbHVlKGhlYWQsIHJlc29sdmVkUHJlZmV0Y2hSc2MpXG59XG5cbi8qKlxuICogVGhlIGdsb2JhbCByb3V0ZXIgdGhhdCB3cmFwcyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gUm91dGVyKHtcbiAgYWN0aW9uUXVldWUsXG4gIGdsb2JhbEVycm9yLFxuICB3ZWJTb2NrZXQsXG4gIHN0YXRpY0luZGljYXRvclN0YXRlLFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgZ2xvYmFsRXJyb3I6IEdsb2JhbEVycm9yU3RhdGVcbiAgd2ViU29ja2V0OiBXZWJTb2NrZXQgfCB1bmRlZmluZWRcbiAgc3RhdGljSW5kaWNhdG9yU3RhdGU6IFN0YXRpY0luZGljYXRvclN0YXRlIHwgdW5kZWZpbmVkXG59KSB7XG4gIGNvbnN0IHN0YXRlID0gdXNlQWN0aW9uUXVldWUoYWN0aW9uUXVldWUpXG4gIGNvbnN0IHsgY2Fub25pY2FsVXJsIH0gPSBzdGF0ZVxuICAvLyBBZGQgbWVtb2l6ZWQgcGF0aG5hbWUvcXVlcnkgZm9yIHVzZVNlYXJjaFBhcmFtcyBhbmQgdXNlUGF0aG5hbWUuXG4gIGNvbnN0IHsgc2VhcmNoUGFyYW1zLCBwYXRobmFtZSB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoaXMgaXMgdHVybmVkIGludG8gYSByZWFkb25seSBjbGFzcyBpbiBgdXNlU2VhcmNoUGFyYW1zYFxuICAgICAgc2VhcmNoUGFyYW1zOiB1cmwuc2VhcmNoUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGhhc0Jhc2VQYXRoKHVybC5wYXRobmFtZSlcbiAgICAgICAgPyByZW1vdmVCYXNlUGF0aCh1cmwucGF0aG5hbWUpXG4gICAgICAgIDogdXJsLnBhdGhuYW1lLFxuICAgIH1cbiAgfSwgW2Nhbm9uaWNhbFVybF0pXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IGNhY2hlLCB0cmVlIH0gPSBzdGF0ZVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gQWRkIGB3aW5kb3cubmRgIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgICAvLyBUaGlzIGlzIG5vdCBtZWFudCBmb3IgdXNlIGluIGFwcGxpY2F0aW9ucyBhcyBjb25jdXJyZW50IHJlbmRlcmluZyB3aWxsIGFmZmVjdCB0aGUgY2FjaGUvdHJlZS9yb3V0ZXIuXG4gICAgICAvLyBAdHMtaWdub3JlIHRoaXMgaXMgZm9yIGRlYnVnZ2luZ1xuICAgICAgd2luZG93Lm5kID0ge1xuICAgICAgICByb3V0ZXI6IHB1YmxpY0FwcFJvdXRlckluc3RhbmNlLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgdHJlZSxcbiAgICAgIH1cbiAgICB9LCBbY2FjaGUsIHRyZWVdKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgYXBwIGlzIHJlc3RvcmVkIGZyb20gYmZjYWNoZSwgaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgLy8gcHVzaFJlZi5tcGFOYXZpZ2F0aW9uIGlzIHRydWUsIHdoaWNoIHdvdWxkIG1lYW4gdGhhdCBhbnkgcmUtcmVuZGVyIG9mIHRoaXMgY29tcG9uZW50XG4gICAgLy8gd291bGQgdHJpZ2dlciB0aGUgbXBhIG5hdmlnYXRpb24gbG9naWMgYWdhaW4gZnJvbSB0aGUgbGluZXMgYmVsb3cuXG4gICAgLy8gVGhpcyB3aWxsIHJlc3RvcmUgdGhlIHJvdXRlciB0byB0aGUgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgYXBwIGlzIHJlc3RvcmVkIGZyb20gYmZjYWNoZS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQYWdlU2hvdyhldmVudDogUGFnZVRyYW5zaXRpb25FdmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAhZXZlbnQucGVyc2lzdGVkIHx8XG4gICAgICAgICF3aW5kb3cuaGlzdG9yeS5zdGF0ZT8uX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciB0aGUgcGVuZGluZ01wYVBhdGggdmFsdWUgc28gdGhhdCBhIHN1YnNlcXVlbnQgTVBBIG5hdmlnYXRpb24gdG8gdGhlIHNhbWUgVVJMIGNhbiBiZSB0cmlnZ2VyZWQuXG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGlmIHRoZSBicm93c2VyIHJlc3RvcmVkIGZyb20gYmZjYWNoZSwgdGhlIHBlbmRpbmdNcGFQYXRoIHdvdWxkIHN0aWxsIGJlIHNldCB0byB0aGUgdmFsdWVcbiAgICAgIC8vIG9mIHRoZSBsYXN0IE1QQSBuYXZpZ2F0aW9uLlxuICAgICAgZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgICAgICB1cmw6IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLFxuICAgICAgICBoaXN0b3J5U3RhdGU6IHdpbmRvdy5oaXN0b3J5LnN0YXRlLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGhhbmRsZVBhZ2VTaG93KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGhhbmRsZVBhZ2VTaG93KVxuICAgIH1cbiAgfSwgW10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBFbnN1cmUgdGhhdCBhbnkgcmVkaXJlY3QgZXJyb3JzIHRoYXQgYnViYmxlIHVwIG91dHNpZGUgb2YgdGhlIFJlZGlyZWN0Qm91bmRhcnlcbiAgICAvLyBhcmUgY2F1Z2h0IGFuZCBoYW5kbGVkIGJ5IHRoZSByb3V0ZXIuXG4gICAgZnVuY3Rpb24gaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QoXG4gICAgICBldmVudDogRXJyb3JFdmVudCB8IFByb21pc2VSZWplY3Rpb25FdmVudFxuICAgICkge1xuICAgICAgY29uc3QgZXJyb3IgPSAncmVhc29uJyBpbiBldmVudCA/IGV2ZW50LnJlYXNvbiA6IGV2ZW50LmVycm9yXG4gICAgICBpZiAoaXNSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IHVybCA9IGdldFVSTEZyb21SZWRpcmVjdEVycm9yKGVycm9yKVxuICAgICAgICBjb25zdCByZWRpcmVjdFR5cGUgPSBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IoZXJyb3IpXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGFjY2VzcyB0aGUgcm91dGVyIG1ldGhvZHMgZGlyZWN0bHksIHJhdGhlciB0aGFuXG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09IFJlZGlyZWN0VHlwZS5wdXNoKSB7XG4gICAgICAgICAgcHVibGljQXBwUm91dGVySW5zdGFuY2UucHVzaCh1cmwsIHt9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1YmxpY0FwcFJvdXRlckluc3RhbmNlLnJlcGxhY2UodXJsLCB7fSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBXaGVuIG1wYU5hdmlnYXRpb24gZmxhZyBpcyBzZXQgZG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIG5ldyB1cmwuXG4gIC8vIEluZmluaXRlbHkgc3VzcGVuZCBiZWNhdXNlIHdlIGRvbid0IGFjdHVhbGx5IHdhbnQgdG8gcmVyZW5kZXIgYW55IGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCB0aGUgbmV3IFVSTCBhbmQgYW55IGVudGFuZ2xlZCBzdGF0ZSB1cGRhdGVzIHNob3VsZG4ndFxuICAvLyBjb21taXQgZWl0aGVyIChlZzogdXNlVHJhbnNpdGlvbiBpc1BlbmRpbmcgc2hvdWxkIHN0YXkgdHJ1ZSB1bnRpbCB0aGUgcGFnZVxuICAvLyB1bmxvYWRzKS5cbiAgLy9cbiAgLy8gVGhpcyBpcyBhIHNpZGUgZWZmZWN0IGluIHJlbmRlci4gRG9uJ3QgdHJ5IHRoaXMgYXQgaG9tZSwga2lkcy4gSXQnc1xuICAvLyBwcm9iYWJseSBzYWZlIGJlY2F1c2Ugd2Uga25vdyB0aGlzIGlzIGEgc2luZ2xldG9uIGNvbXBvbmVudCBhbmQgaXQncyBuZXZlclxuICAvLyBpbiA8T2Zmc2NyZWVuPi4gQXQgbGVhc3QgSSBob3BlIHNvLiAoSXQgd2lsbCBydW4gdHdpY2UgaW4gZGV2IHN0cmljdCBtb2RlLFxuICAvLyBidXQgdGhhdCdzLi4uIGZpbmU/KVxuICBjb25zdCB7IHB1c2hSZWYgfSA9IHN0YXRlXG4gIGlmIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pIHtcbiAgICAvLyBpZiB0aGVyZSdzIGEgcmUtcmVuZGVyLCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYW5vdGhlciByZWRpcmVjdCBpZiBvbmUgaXMgYWxyZWFkeSBpbiBmbGlnaHQgdG8gdGhlIHNhbWUgVVJMXG4gICAgaWYgKGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggIT09IGNhbm9uaWNhbFVybCkge1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb25cbiAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoKSB7XG4gICAgICAgIGxvY2F0aW9uLmFzc2lnbihjYW5vbmljYWxVcmwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKGNhbm9uaWNhbFVybClcbiAgICAgIH1cblxuICAgICAgZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCA9IGNhbm9uaWNhbFVybFxuICAgIH1cbiAgICAvLyBUT0RPLUFQUDogU2hvdWxkIHdlIGxpc3RlbiB0byBuYXZpZ2F0ZWVycm9yIGhlcmUgdG8gY2F0Y2ggZmFpbGVkXG4gICAgLy8gbmF2aWdhdGlvbnMgc29tZWhvdz8gQW5kIHNob3VsZCB3ZSBjYWxsIHdpbmRvdy5zdG9wKCkgaWYgYSBTUEEgbmF2aWdhdGlvblxuICAgIC8vIHNob3VsZCBpbnRlcnJ1cHQgYW4gTVBBIG9uZT9cbiAgICAvLyBOT1RFOiBUaGlzIGlzIGludGVudGlvbmFsbHkgdXNpbmcgYHRocm93YCBpbnN0ZWFkIG9mIGB1c2VgIGJlY2F1c2Ugd2UncmVcbiAgICAvLyBpbnNpZGUgYW4gZXh0ZXJuYWxseSBtdXRhYmxlIGNvbmRpdGlvbiAocHVzaFJlZi5tcGFOYXZpZ2F0aW9uKSwgd2hpY2hcbiAgICAvLyB2aW9sYXRlcyB0aGUgcnVsZXMgb2YgaG9va3MuXG4gICAgdGhyb3cgdW5yZXNvbHZlZFRoZW5hYmxlXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsUHVzaFN0YXRlID0gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlLmJpbmQod2luZG93Lmhpc3RvcnkpXG4gICAgY29uc3Qgb3JpZ2luYWxSZXBsYWNlU3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUuYmluZChcbiAgICAgIHdpbmRvdy5oaXN0b3J5XG4gICAgKVxuXG4gICAgLy8gRW5zdXJlIHRoZSBjYW5vbmljYWwgVVJMIGluIHRoZSBOZXh0LmpzIFJvdXRlciBpcyB1cGRhdGVkIHdoZW4gdGhlIFVSTCBpcyBjaGFuZ2VkIHNvIHRoYXQgYHVzZVBhdGhuYW1lYCBhbmQgYHVzZVNlYXJjaFBhcmFtc2AgaG9sZCB0aGUgcHVzaGVkIHZhbHVlcy5cbiAgICBjb25zdCBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UgPSAoXG4gICAgICB1cmw6IHN0cmluZyB8IFVSTCB8IG51bGwgfCB1bmRlZmluZWRcbiAgICApID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgY29uc3QgYXBwSGlzdG9yeVN0YXRlOiBBcHBIaXN0b3J5U3RhdGUgfCB1bmRlZmluZWQgPVxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5zdGF0ZT8uX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuXG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgICAgICAgdHlwZTogQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgICAgdXJsOiBuZXcgVVJMKHVybCA/PyBocmVmLCBocmVmKSxcbiAgICAgICAgICBoaXN0b3J5U3RhdGU6IGFwcEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0Y2ggcHVzaFN0YXRlIHRvIGVuc3VyZSBleHRlcm5hbCBjaGFuZ2VzIHRvIHRoZSBoaXN0b3J5IGFyZSByZWZsZWN0ZWQgaW4gdGhlIE5leHQuanMgUm91dGVyLlxuICAgICAqIEVuc3VyZXMgTmV4dC5qcyBpbnRlcm5hbCBoaXN0b3J5IHN0YXRlIGlzIGNvcGllZCB0byB0aGUgbmV3IGhpc3RvcnkgZW50cnkuXG4gICAgICogRW5zdXJlcyB1c2VQYXRobmFtZSBhbmQgdXNlU2VhcmNoUGFyYW1zIGhvbGQgdGhlIG5ld2x5IHByb3ZpZGVkIHVybC5cbiAgICAgKi9cbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbiBwdXNoU3RhdGUoXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBfdW51c2VkOiBzdHJpbmcsXG4gICAgICB1cmw/OiBzdHJpbmcgfCBVUkwgfCBudWxsXG4gICAgKTogdm9pZCB7XG4gICAgICAvLyBUT0RPOiBXYXJuIHdoZW4gTmF2aWdhdGlvbiBBUEkgaXMgYXZhaWxhYmxlIChuYXZpZ2F0aW9uLm5hdmlnYXRlKCkgc2hvdWxkIGJlIHVzZWQpXG4gICAgICAvLyBBdm9pZCBhIGxvb3Agd2hlbiBOZXh0LmpzIGludGVybmFscyB0cmlnZ2VyIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGVcbiAgICAgIGlmIChkYXRhPy5fX05BIHx8IGRhdGE/Ll9OKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFB1c2hTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YSlcblxuICAgICAgaWYgKHVybCkge1xuICAgICAgICBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UodXJsKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JpZ2luYWxQdXNoU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoIHJlcGxhY2VTdGF0ZSB0byBlbnN1cmUgZXh0ZXJuYWwgY2hhbmdlcyB0byB0aGUgaGlzdG9yeSBhcmUgcmVmbGVjdGVkIGluIHRoZSBOZXh0LmpzIFJvdXRlci5cbiAgICAgKiBFbnN1cmVzIE5leHQuanMgaW50ZXJuYWwgaGlzdG9yeSBzdGF0ZSBpcyBjb3BpZWQgdG8gdGhlIG5ldyBoaXN0b3J5IGVudHJ5LlxuICAgICAqIEVuc3VyZXMgdXNlUGF0aG5hbWUgYW5kIHVzZVNlYXJjaFBhcmFtcyBob2xkIHRoZSBuZXdseSBwcm92aWRlZCB1cmwuXG4gICAgICovXG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgX3VudXNlZDogc3RyaW5nLFxuICAgICAgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbFxuICAgICk6IHZvaWQge1xuICAgICAgLy8gVE9ETzogV2FybiB3aGVuIE5hdmlnYXRpb24gQVBJIGlzIGF2YWlsYWJsZSAobmF2aWdhdGlvbi5uYXZpZ2F0ZSgpIHNob3VsZCBiZSB1c2VkKVxuICAgICAgLy8gQXZvaWQgYSBsb29wIHdoZW4gTmV4dC5qcyBpbnRlcm5hbHMgdHJpZ2dlciBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlXG4gICAgICBpZiAoZGF0YT8uX19OQSB8fCBkYXRhPy5fTikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXBsYWNlU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgICAgfVxuICAgICAgZGF0YSA9IGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhKVxuXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSh1cmwpXG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxSZXBsYWNlU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwb3BzdGF0ZSBldmVudCwgdGhpcyBpcyB1c2VkIHRvIGhhbmRsZSBiYWNrL2ZvcndhcmQgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQnkgZGVmYXVsdCBkaXNwYXRjaGVzIEFDVElPTl9SRVNUT1JFLCBob3dldmVyIGlmIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBub3QgcHVzaGVkL3JlcGxhY2VkIGJ5IGFwcC1yb3V0ZXIgaXQgd2lsbCByZWxvYWQgdGhlIHBhZ2UuXG4gICAgICogVGhhdCBjYXNlIGNhbiBoYXBwZW4gd2hlbiB0aGUgb2xkIHJvdXRlciBpbmplY3RlZCB0aGUgaGlzdG9yeSBlbnRyeS5cbiAgICAgKi9cbiAgICBjb25zdCBvblBvcFN0YXRlID0gKGV2ZW50OiBQb3BTdGF0ZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LnN0YXRlKSB7XG4gICAgICAgIC8vIFRPRE8tQVBQOiB0aGlzIGNhc2Ugb25seSBoYXBwZW5zIHdoZW4gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSB3YXMgY2FsbGVkIG91dHNpZGUgb2YgTmV4dC5qcy4gSXQgc2hvdWxkIHByb2JhYmx5IHJlbG9hZCB0aGUgcGFnZSBpbiB0aGlzIGNhc2UuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBwdXNoZWQgYnkgdGhlIGBwYWdlc2Agcm91dGVyLlxuICAgICAgaWYgKCFldmVudC5zdGF0ZS5fX05BKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETy1BUFA6IElkZWFsbHkgdGhlIGJhY2sgYnV0dG9uIHNob3VsZCBub3QgdXNlIHN0YXJ0VHJhbnNpdGlvbiBhcyBpdCBzaG91bGQgYXBwbHkgdGhlIHVwZGF0ZXMgc3luY2hyb25vdXNseVxuICAgICAgLy8gV2l0aG91dCBzdGFydFRyYW5zaXRpb24gd29ya3MgaWYgdGhlIGNhY2hlIGlzIHRoZXJlIGZvciB0aGlzIHBhdGhcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoVHJhdmVyc2VBY3Rpb24oXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgZXZlbnQuc3RhdGUuX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIHBvcHN0YXRlIGV2ZW50IHRvIGNhbGwgb25Qb3BzdGF0ZS5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPSBvcmlnaW5hbFB1c2hTdGF0ZVxuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gb3JpZ2luYWxSZXBsYWNlU3RhdGVcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpXG4gICAgfVxuICB9LCBbXSlcblxuICBjb25zdCB7IGNhY2hlLCB0cmVlLCBuZXh0VXJsLCBmb2N1c0FuZFNjcm9sbFJlZiwgcHJldmlvdXNOZXh0VXJsIH0gPSBzdGF0ZVxuXG4gIGNvbnN0IG1hdGNoaW5nSGVhZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBmaW5kSGVhZEluQ2FjaGUoY2FjaGUsIHRyZWVbMV0pXG4gIH0sIFtjYWNoZSwgdHJlZV0pXG5cbiAgLy8gQWRkIG1lbW9pemVkIHBhdGhQYXJhbXMgZm9yIHVzZVBhcmFtcy5cbiAgY29uc3QgcGF0aFBhcmFtcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBnZXRTZWxlY3RlZFBhcmFtcyh0cmVlKVxuICB9LCBbdHJlZV0pXG5cbiAgLy8gQ3JlYXRlIGluc3RydW1lbnRlZCBwcm9taXNlcyBmb3IgbmF2aWdhdGlvbiBob29rcyAoZGV2LW9ubHkpXG4gIC8vIFRoZXNlIGFyZSBzcGVjaWFsbHkgaW5zdHJ1bWVudGVkIHByb21pc2VzIHRvIHNob3cgaW4gdGhlIFN1c3BlbnNlIERldlRvb2xzXG4gIC8vIFByb21pc2VzIGFyZSBjYWNoZWQgb3V0c2lkZSBvZiByZW5kZXIgdG8gc3Vydml2ZSBzdXNwZW5zZSByZXRyaWVzLlxuICBsZXQgaW5zdHJ1bWVudGVkTmF2aWdhdGlvblByb21pc2VzOiBOYXZpZ2F0aW9uUHJvbWlzZXMgfCBudWxsID0gbnVsbFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHsgY3JlYXRlUm9vdE5hdmlnYXRpb25Qcm9taXNlcyB9ID1cbiAgICAgIHJlcXVpcmUoJy4vbmF2aWdhdGlvbi1kZXZ0b29scycpIGFzIHR5cGVvZiBpbXBvcnQoJy4vbmF2aWdhdGlvbi1kZXZ0b29scycpXG5cbiAgICBpbnN0cnVtZW50ZWROYXZpZ2F0aW9uUHJvbWlzZXMgPSBjcmVhdGVSb290TmF2aWdhdGlvblByb21pc2VzKFxuICAgICAgdHJlZSxcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgcGF0aFBhcmFtc1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxheW91dFJvdXRlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50VHJlZTogdHJlZSxcbiAgICAgIHBhcmVudENhY2hlTm9kZTogY2FjaGUsXG4gICAgICBwYXJlbnRTZWdtZW50UGF0aDogbnVsbCxcbiAgICAgIHBhcmVudFBhcmFtczoge30sXG4gICAgICAvLyBUaGlzIGlzIHRoZSA8QWN0aXZpdHk+IFwibmFtZVwiIHRoYXQgc2hvd3MgdXAgaW4gdGhlIFN1c3BlbnNlIERldlRvb2xzLlxuICAgICAgLy8gSXQgcmVwcmVzZW50cyB0aGUgcm9vdCBvZiB0aGUgYXBwLlxuICAgICAgZGVidWdOYW1lQ29udGV4dDogJy8nLFxuICAgICAgLy8gUm9vdCBub2RlIGFsd2F5cyBoYXMgYHVybGBcbiAgICAgIC8vIFByb3ZpZGVkIGluIEFwcFRyZWVDb250ZXh0IHRvIGVuc3VyZSBpdCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gbGF5b3V0LXJvdXRlclxuICAgICAgdXJsOiBjYW5vbmljYWxVcmwsXG4gICAgICAvLyBSb290IHNlZ21lbnQgaXMgYWx3YXlzIGFjdGl2ZVxuICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgfVxuICB9LCBbdHJlZSwgY2FjaGUsIGNhbm9uaWNhbFVybF0pXG5cbiAgY29uc3QgZ2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0cmVlLFxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICBuZXh0VXJsLFxuICAgICAgcHJldmlvdXNOZXh0VXJsLFxuICAgIH1cbiAgfSwgW3RyZWUsIGZvY3VzQW5kU2Nyb2xsUmVmLCBuZXh0VXJsLCBwcmV2aW91c05leHRVcmxdKVxuXG4gIGxldCBoZWFkXG4gIGlmIChtYXRjaGluZ0hlYWQgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgaGVhZCBpcyB3cmFwcGVkIGluIGFuIGV4dHJhIGNvbXBvbmVudCBzbyB3ZSBjYW4gdXNlXG4gICAgLy8gYHVzZURlZmVycmVkVmFsdWVgIHRvIHN3YXAgYmV0d2VlbiB0aGUgcHJlZmV0Y2hlZCBhbmQgZmluYWwgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgaGVhZC4gKFRoaXMgaXMgd2hhdCBMYXlvdXRSb3V0ZXIgZG9lcyBmb3Igc2VnbWVudCBkYXRhLCB0b28uKVxuICAgIC8vXG4gICAgLy8gVGhlIGBrZXlgIGlzIHVzZWQgdG8gcmVtb3VudCB0aGUgY29tcG9uZW50IHdoZW5ldmVyIHRoZSBoZWFkIG1vdmVzIHRvXG4gICAgLy8gYSBkaWZmZXJlbnQgc2VnbWVudC5cbiAgICBjb25zdCBbaGVhZENhY2hlTm9kZSwgaGVhZEtleSwgaGVhZEtleVdpdGhvdXRTZWFyY2hQYXJhbXNdID0gbWF0Y2hpbmdIZWFkXG5cbiAgICBoZWFkID0gKFxuICAgICAgPEhlYWRcbiAgICAgICAga2V5PXtcbiAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIFBQUjogb21pdCBzZWFyY2ggcGFyYW1zIGZyb20gdGhlIGtleSB0byBtYXRjaCBwcmVyZW5kZXJlZCBrZXlzXG4gICAgICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBoZWFkS2V5V2l0aG91dFNlYXJjaFBhcmFtcyA6IGhlYWRLZXlcbiAgICAgICAgfVxuICAgICAgICBoZWFkQ2FjaGVOb2RlPXtoZWFkQ2FjaGVOb2RlfVxuICAgICAgLz5cbiAgICApXG4gIH0gZWxzZSB7XG4gICAgaGVhZCA9IG51bGxcbiAgfVxuXG4gIGxldCBjb250ZW50ID0gKFxuICAgIDxSZWRpcmVjdEJvdW5kYXJ5PlxuICAgICAge2hlYWR9XG4gICAgICB7LyogUm9vdExheW91dEJvdW5kYXJ5IGVuYWJsZXMgZGV0ZWN0aW9uIG9mIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJvdW5kIHRoZSByb290IGxheW91dC5cbiAgICAgICAgICBXaGVuIHVzZXJzIHdyYXAgdGhlaXIgbGF5b3V0IGluIDxTdXNwZW5zZT4sIHRoaXMgY3JlYXRlcyB0aGUgY29tcG9uZW50IHN0YWNrIHBhdHRlcm5cbiAgICAgICAgICBcIlN1c3BlbnNlIC0+IFJvb3RMYXlvdXRCb3VuZGFyeVwiIHdoaWNoIGR5bmFtaWMtcmVuZGVyaW5nLnRzIHVzZXMgdG8gYWxsb3cgZHluYW1pYyByZW5kZXJpbmcuICovfVxuICAgICAgPFJvb3RMYXlvdXRCb3VuZGFyeT57Y2FjaGUucnNjfTwvUm9vdExheW91dEJvdW5kYXJ5PlxuICAgICAgPEFwcFJvdXRlckFubm91bmNlciB0cmVlPXt0cmVlfSAvPlxuICAgIDwvUmVkaXJlY3RCb3VuZGFyeT5cbiAgKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIGFwcGx5IGZldyBlcnJvciBib3VuZGFyaWVzIGFuZCBob3QtcmVsb2FkZXI6XG4gICAgLy8gLSBEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk6IGF2b2lkIHVzaW5nIG5hdmlnYXRpb24gQVBJIGxpa2Ugbm90Rm91bmQoKSBpbiByb290IGxheW91dFxuICAgIC8vIC0gSG90UmVsb2FkZXI6XG4gICAgLy8gIC0gaG90LXJlbG9hZCB0aGUgYXBwIHdoZW4gdGhlIGNvZGUgY2hhbmdlc1xuICAgIC8vICAtIHJlbmRlciBkZXYgb3ZlcmxheVxuICAgIC8vICAtIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIGFuZCBkaXNwbGF5IGdsb2JhbC1lcnJvciB3aGVuIG5lY2Vzc2FyeVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgeyBEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkgfSA9XG4gICAgICAgIHJlcXVpcmUoJy4vZGV2LXJvb3QtaHR0cC1hY2Nlc3MtZmFsbGJhY2stYm91bmRhcnknKSBhcyB0eXBlb2YgaW1wb3J0KCcuL2Rldi1yb290LWh0dHAtYWNjZXNzLWZhbGxiYWNrLWJvdW5kYXJ5JylcbiAgICAgIGNvbnRlbnQgPSAoXG4gICAgICAgIDxEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk+XG4gICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgIDwvRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5PlxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBIb3RSZWxvYWRlcjogdHlwZW9mIGltcG9ydCgnLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpLmRlZmF1bHQgPVxuICAgICAgKFxuICAgICAgICByZXF1aXJlKCcuLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpXG4gICAgICApLmRlZmF1bHRcblxuICAgIGNvbnRlbnQgPSAoXG4gICAgICA8SG90UmVsb2FkZXJcbiAgICAgICAgZ2xvYmFsRXJyb3I9e2dsb2JhbEVycm9yfVxuICAgICAgICB3ZWJTb2NrZXQ9e3dlYlNvY2tldH1cbiAgICAgICAgc3RhdGljSW5kaWNhdG9yU3RhdGU9e3N0YXRpY0luZGljYXRvclN0YXRlfVxuICAgICAgPlxuICAgICAgICB7Y29udGVudH1cbiAgICAgIDwvSG90UmVsb2FkZXI+XG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGNvbnRlbnQgPSAoXG4gICAgICA8Um9vdEVycm9yQm91bmRhcnlcbiAgICAgICAgZXJyb3JDb21wb25lbnQ9e2dsb2JhbEVycm9yWzBdfVxuICAgICAgICBlcnJvclN0eWxlcz17Z2xvYmFsRXJyb3JbMV19XG4gICAgICA+XG4gICAgICAgIHtjb250ZW50fVxuICAgICAgPC9Sb290RXJyb3JCb3VuZGFyeT5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8SGlzdG9yeVVwZGF0ZXIgYXBwUm91dGVyU3RhdGU9e3N0YXRlfSAvPlxuICAgICAgPFJ1bnRpbWVTdHlsZXMgLz5cbiAgICAgIDxOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgIHZhbHVlPXtpbnN0cnVtZW50ZWROYXZpZ2F0aW9uUHJvbWlzZXN9XG4gICAgICA+XG4gICAgICAgIDxQYXRoUGFyYW1zQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cGF0aFBhcmFtc30+XG4gICAgICAgICAgPFBhdGhuYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cGF0aG5hbWV9PlxuICAgICAgICAgICAgPFNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3NlYXJjaFBhcmFtc30+XG4gICAgICAgICAgICAgIDxHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgICAgICAgdmFsdWU9e2dsb2JhbExheW91dFJvdXRlckNvbnRleHR9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7LyogVE9ETzogV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY29udGV4dC4gdXNlUm91dGVyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZCBpbXBvcnQgZnJvbSBhcHAtcm91dGVyLWluc3RhbmNlIGluc3RlYWQuIEl0J3Mgb25seVxuICAgICAgICAgICAgICAgICAgICBuZWNlc3NhcnkgYmVjYXVzZSB1c2VSb3V0ZXIgaXMgc2hhcmVkIGJldHdlZW4gUGFnZXMgYW5kXG4gICAgICAgICAgICAgICAgICAgIEFwcCBSb3V0ZXIuIFdlIHNob3VsZCBmb3JrIHRoYXQgbW9kdWxlLCB0aGVuIHJlbW92ZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgcHJvdmlkZXIuICovfVxuICAgICAgICAgICAgICAgIDxBcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZX0+XG4gICAgICAgICAgICAgICAgICA8TGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bGF5b3V0Um91dGVyQ29udGV4dH0+XG4gICAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgICAgPC9MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgICAgIDwvQXBwUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgPC9HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgPC9TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvUGF0aG5hbWVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L1BhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9OYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvPlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcFJvdXRlcih7XG4gIGFjdGlvblF1ZXVlLFxuICBnbG9iYWxFcnJvclN0YXRlLFxuICB3ZWJTb2NrZXQsXG4gIHN0YXRpY0luZGljYXRvclN0YXRlLFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgZ2xvYmFsRXJyb3JTdGF0ZTogR2xvYmFsRXJyb3JTdGF0ZVxuICB3ZWJTb2NrZXQ/OiBXZWJTb2NrZXRcbiAgc3RhdGljSW5kaWNhdG9yU3RhdGU/OiBTdGF0aWNJbmRpY2F0b3JTdGF0ZVxufSkge1xuICB1c2VOYXZGYWlsdXJlSGFuZGxlcigpXG5cbiAgY29uc3Qgcm91dGVyID0gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGFjdGlvblF1ZXVlPXthY3Rpb25RdWV1ZX1cbiAgICAgIGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvclN0YXRlfVxuICAgICAgd2ViU29ja2V0PXt3ZWJTb2NrZXR9XG4gICAgICBzdGF0aWNJbmRpY2F0b3JTdGF0ZT17c3RhdGljSW5kaWNhdG9yU3RhdGV9XG4gICAgLz5cbiAgKVxuXG4gIC8vIEF0IHRoZSB2ZXJ5IHRvcCBsZXZlbCwgdXNlIHRoZSBkZWZhdWx0IEdsb2JhbEVycm9yIGNvbXBvbmVudCBhcyB0aGUgZmluYWwgZmFsbGJhY2suXG4gIC8vIFdoZW4gdGhlIGFwcCByb3V0ZXIgaXRzZWxmIGZhaWxzLCB3aGljaCBtZWFucyB0aGUgZnJhbWV3b3JrIGl0c2VsZiBmYWlscywgd2Ugc2hvdyB0aGUgZGVmYXVsdCBlcnJvci5cbiAgcmV0dXJuIChcbiAgICA8Um9vdEVycm9yQm91bmRhcnkgZXJyb3JDb21wb25lbnQ9e0RlZmF1bHRHbG9iYWxFcnJvcn0+XG4gICAgICB7cm91dGVyfVxuICAgIDwvUm9vdEVycm9yQm91bmRhcnk+XG4gIClcbn1cblxuY29uc3QgcnVudGltZVN0eWxlcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG5sZXQgcnVudGltZVN0eWxlQ2hhbmdlZCA9IG5ldyBTZXQ8KCkgPT4gdm9pZD4oKVxuXG5nbG9iYWxUaGlzLl9OX0VfU1RZTEVfTE9BRCA9IGZ1bmN0aW9uIChocmVmOiBzdHJpbmcpIHtcbiAgbGV0IGxlbiA9IHJ1bnRpbWVTdHlsZXMuc2l6ZVxuICBydW50aW1lU3R5bGVzLmFkZChocmVmKVxuICBpZiAocnVudGltZVN0eWxlcy5zaXplICE9PSBsZW4pIHtcbiAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmZvckVhY2goKGNiKSA9PiBjYigpKVxuICB9XG4gIC8vIFRPRE8gZmlndXJlIG91dCBob3cgdG8gZ2V0IGEgcHJvbWlzZSBoZXJlXG4gIC8vIEJ1dCBtYXliZSBpdCdzIG5vdCBuZWNlc3NhcnkgYXMgcmVhY3Qgd291bGQgYmxvY2sgcmVuZGVyaW5nIHVudGlsIGl0J3MgbG9hZGVkXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxufVxuXG5mdW5jdGlvbiBSdW50aW1lU3R5bGVzKCkge1xuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgwKVxuICBjb25zdCByZW5kZXJlZFN0eWxlc1NpemUgPSBydW50aW1lU3R5bGVzLnNpemVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjaGFuZ2VkID0gKCkgPT4gZm9yY2VVcGRhdGUoKGMpID0+IGMgKyAxKVxuICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuYWRkKGNoYW5nZWQpXG4gICAgaWYgKHJlbmRlcmVkU3R5bGVzU2l6ZSAhPT0gcnVudGltZVN0eWxlcy5zaXplKSB7XG4gICAgICBjaGFuZ2VkKClcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuZGVsZXRlKGNoYW5nZWQpXG4gICAgfVxuICB9LCBbcmVuZGVyZWRTdHlsZXNTaXplLCBmb3JjZVVwZGF0ZV0pXG5cbiAgY29uc3QgZHBsSWQgPSBnZXREZXBsb3ltZW50SWRRdWVyeU9yRW1wdHlTdHJpbmcoKVxuICByZXR1cm4gWy4uLnJ1bnRpbWVTdHlsZXNdLm1hcCgoaHJlZiwgaSkgPT4gKFxuICAgIDxsaW5rXG4gICAgICBrZXk9e2l9XG4gICAgICByZWw9XCJzdHlsZXNoZWV0XCJcbiAgICAgIGhyZWY9e2Ake2hyZWZ9JHtkcGxJZH1gfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcHJlY2VkZW5jZT1cIm5leHRcIlxuICAgICAgLy8gVE9ETyBmaWd1cmUgb3V0IGNyb3NzT3JpZ2luIGFuZCBub25jZVxuICAgICAgLy8gY3Jvc3NPcmlnaW49e1RPRE99XG4gICAgICAvLyBub25jZT17VE9ET31cbiAgICAvPlxuICApKVxufVxuIl0sIm5hbWVzIjpbIkFwcFJvdXRlciIsImdsb2JhbE11dGFibGUiLCJIaXN0b3J5VXBkYXRlciIsImFwcFJvdXRlclN0YXRlIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkciLCJ3aW5kb3ciLCJuZXh0IiwiX19wZW5kaW5nVXJsIiwidW5kZWZpbmVkIiwidHJlZSIsInB1c2hSZWYiLCJjYW5vbmljYWxVcmwiLCJyZW5kZXJlZFNlYXJjaCIsImFwcEhpc3RvcnlTdGF0ZSIsImhpc3RvcnlTdGF0ZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGlzdG9yeSIsInN0YXRlIiwiX19OQSIsIl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUiLCJwZW5kaW5nUHVzaCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiVVJMIiwibG9jYXRpb24iLCJocmVmIiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwidXNlRWZmZWN0IiwicGluZ1Zpc2libGVMaW5rcyIsIm5leHRVcmwiLCJjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUiLCJkYXRhIiwiY3VycmVudFN0YXRlIiwiSGVhZCIsImhlYWRDYWNoZU5vZGUiLCJoZWFkIiwicHJlZmV0Y2hIZWFkIiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInVzZURlZmVycmVkVmFsdWUiLCJSb3V0ZXIiLCJhY3Rpb25RdWV1ZSIsImdsb2JhbEVycm9yIiwid2ViU29ja2V0Iiwic3RhdGljSW5kaWNhdG9yU3RhdGUiLCJ1c2VBY3Rpb25RdWV1ZSIsInNlYXJjaFBhcmFtcyIsInBhdGhuYW1lIiwidXNlTWVtbyIsInVybCIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJOT0RFX0VOViIsImNhY2hlIiwibmQiLCJyb3V0ZXIiLCJwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSIsImhhbmRsZVBhZ2VTaG93IiwiZXZlbnQiLCJwZXJzaXN0ZWQiLCJwZW5kaW5nTXBhUGF0aCIsImRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIiwidHlwZSIsIkFDVElPTl9SRVNUT1JFIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdCIsImVycm9yIiwicmVhc29uIiwiaXNSZWRpcmVjdEVycm9yIiwicHJldmVudERlZmF1bHQiLCJnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciIsInJlZGlyZWN0VHlwZSIsImdldFJlZGlyZWN0VHlwZUZyb21FcnJvciIsIlJlZGlyZWN0VHlwZSIsInB1c2giLCJyZXBsYWNlIiwibXBhTmF2aWdhdGlvbiIsImFzc2lnbiIsInVucmVzb2x2ZWRUaGVuYWJsZSIsIm9yaWdpbmFsUHVzaFN0YXRlIiwiYmluZCIsIm9yaWdpbmFsUmVwbGFjZVN0YXRlIiwiYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlIiwic3RhcnRUcmFuc2l0aW9uIiwiX3VudXNlZCIsIl9OIiwib25Qb3BTdGF0ZSIsInJlbG9hZCIsImRpc3BhdGNoVHJhdmVyc2VBY3Rpb24iLCJmb2N1c0FuZFNjcm9sbFJlZiIsInByZXZpb3VzTmV4dFVybCIsIm1hdGNoaW5nSGVhZCIsImZpbmRIZWFkSW5DYWNoZSIsInBhdGhQYXJhbXMiLCJnZXRTZWxlY3RlZFBhcmFtcyIsImluc3RydW1lbnRlZE5hdmlnYXRpb25Qcm9taXNlcyIsImNyZWF0ZVJvb3ROYXZpZ2F0aW9uUHJvbWlzZXMiLCJyZXF1aXJlIiwibGF5b3V0Um91dGVyQ29udGV4dCIsInBhcmVudFRyZWUiLCJwYXJlbnRDYWNoZU5vZGUiLCJwYXJlbnRTZWdtZW50UGF0aCIsInBhcmVudFBhcmFtcyIsImRlYnVnTmFtZUNvbnRleHQiLCJpc0FjdGl2ZSIsImdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJoZWFkS2V5IiwiaGVhZEtleVdpdGhvdXRTZWFyY2hQYXJhbXMiLCJjb250ZW50IiwiUmVkaXJlY3RCb3VuZGFyeSIsIlJvb3RMYXlvdXRCb3VuZGFyeSIsInJzYyIsIkFwcFJvdXRlckFubm91bmNlciIsIkRldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsIkhvdFJlbG9hZGVyIiwiZGVmYXVsdCIsIlJvb3RFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJlcnJvclN0eWxlcyIsIlJ1bnRpbWVTdHlsZXMiLCJOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlBhdGhQYXJhbXNDb250ZXh0IiwiUGF0aG5hbWVDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsImdsb2JhbEVycm9yU3RhdGUiLCJ1c2VOYXZGYWlsdXJlSGFuZGxlciIsIkRlZmF1bHRHbG9iYWxFcnJvciIsInJ1bnRpbWVTdHlsZXMiLCJTZXQiLCJydW50aW1lU3R5bGVDaGFuZ2VkIiwiZ2xvYmFsVGhpcyIsIl9OX0VfU1RZTEVfTE9BRCIsImxlbiIsInNpemUiLCJhZGQiLCJmb3JFYWNoIiwiY2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsImZvcmNlVXBkYXRlIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsInJlbmRlcmVkU3R5bGVzU2l6ZSIsImNoYW5nZWQiLCJjIiwiZGVsZXRlIiwiZHBsSWQiLCJnZXREZXBsb3ltZW50SWRRdWVyeU9yRW1wdHlTdHJpbmciLCJtYXAiLCJpIiwibGluayIsInJlbCIsInByZWNlZGVuY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/http-access-fallback/error-boundary.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/next/dist/client/components/http-access-fallback/error-boundary.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", ({\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _navigationuntracked = __webpack_require__(/*! ../navigation-untracked */ \"(app-pages-browser)/../node_modules/next/dist/client/components/navigation-untracked.js\");\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback */ \"(app-pages-browser)/../node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\nconst _warnonce = __webpack_require__(/*! ../../../shared/lib/utils/warn-once */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n    componentDidCatch() {\n        if ( true && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>`@${slot}`).join(', ');\n            warningMessage += 'Missing slots: ' + formattedSlots;\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                     true && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"boundary-next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n}\nfunction HTTPAccessFallbackBoundary({ notFound, forbidden, unauthorized, children }) {\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = HTTPAccessFallbackBoundary;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c;\n$RefreshReg$(_c, \"HTTPAccessFallbackBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2Vycm9yLWJvdW5kYXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OERBd0pnQkE7OztlQUFBQTs7Ozs7NkVBM0lrQjtpREFDRztnREFNOUI7c0NBQ2tCOzJEQUNVO0FBc0JuQyxNQUFNQyx3Q0FBd0NDLE9BQUFBLE9BQUssQ0FBQ0MsU0FBUztJQUkzREMsWUFBWUMsS0FBMkMsQ0FBRTtRQUN2RCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDWEMsaUJBQWlCQztZQUNqQkMsa0JBQWtCSixNQUFNSyxRQUFRO1FBQ2xDO0lBQ0Y7SUFFQUMsb0JBQTBCO1FBQ3hCLElBQ0VDLEtBQW9CLElBQ3BCLElBQUksQ0FBQ1AsS0FBSyxDQUFDVSxZQUFZLElBQ3ZCLElBQUksQ0FBQ1YsS0FBSyxDQUFDVSxZQUFZLENBQUNDLElBQUksR0FBRyxLQUMvQiw0RUFBNEU7UUFDNUUsQ0FBQyxJQUFJLENBQUNYLEtBQUssQ0FBQ1UsWUFBWSxDQUFDRSxHQUFHLENBQUMsYUFDN0I7WUFDQSxJQUFJQyxpQkFDRiw0SEFDQTtZQUVGLE1BQU1DLGlCQUFpQkMsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ2hCLEtBQUssQ0FBQ1UsWUFBWSxFQUN0RE8sSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVFLGFBQWEsQ0FBQ0QsSUFDL0JFLEdBQUcsQ0FBQyxDQUFDQyxPQUFTLENBQUMsQ0FBQyxFQUFFQSxNQUFNLEVBQ3hCQyxJQUFJLENBQUM7WUFFUlYsa0JBQWtCLG9CQUFvQkM7WUFFdENVLENBQUFBLEdBQUFBLFVBQUFBLFFBQUFBLEVBQVNYO1FBQ1g7SUFDRjtJQUVBLE9BQU9ZLHlCQUF5QkMsS0FBVSxFQUFFO1FBQzFDLElBQUlDLENBQUFBLEdBQUFBLG9CQUFBQSx5QkFBQUEsRUFBMEJELFFBQVE7WUFDcEMsTUFBTUUsYUFBYUMsQ0FBQUEsR0FBQUEsb0JBQUFBLDJCQUFBQSxFQUE0Qkg7WUFDL0MsT0FBTztnQkFDTHhCLGlCQUFpQjBCO1lBQ25CO1FBQ0Y7UUFDQSxtQ0FBbUM7UUFDbkMsTUFBTUY7SUFDUjtJQUVBLE9BQU9JLHlCQUNMOUIsS0FBMkMsRUFDM0NDLEtBQThCLEVBQ0U7UUFDaEM7Ozs7O0tBS0MsR0FDRCxJQUFJRCxNQUFNSyxRQUFRLEtBQUtKLE1BQU1HLGdCQUFnQixJQUFJSCxNQUFNQyxlQUFlLEVBQUU7WUFDdEUsT0FBTztnQkFDTEEsaUJBQWlCQztnQkFDakJDLGtCQUFrQkosTUFBTUssUUFBUTtZQUNsQztRQUNGO1FBQ0EsT0FBTztZQUNMSCxpQkFBaUJELE1BQU1DLGVBQWU7WUFDdENFLGtCQUFrQkosTUFBTUssUUFBUTtRQUNsQztJQUNGO0lBRUEwQixTQUFTO1FBQ1AsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFQyxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUNuQyxLQUFLO1FBQ2xFLE1BQU0sRUFBRUUsZUFBZSxFQUFFLEdBQUcsSUFBSSxDQUFDRCxLQUFLO1FBQ3RDLE1BQU1tQyxrQkFBa0I7WUFDdEIsQ0FBQ0Msb0JBQUFBLHFCQUFxQixDQUFDQyxTQUFTLENBQUMsRUFBRU47WUFDbkMsQ0FBQ0ssb0JBQUFBLHFCQUFxQixDQUFDRSxTQUFTLENBQUMsRUFBRU47WUFDbkMsQ0FBQ0ksb0JBQUFBLHFCQUFxQixDQUFDRyxZQUFZLENBQUMsRUFBRU47UUFDeEM7UUFFQSxJQUFJaEMsaUJBQWlCO1lBQ25CLE1BQU11QyxhQUNKdkMsb0JBQW9CbUMsb0JBQUFBLHFCQUFxQixDQUFDQyxTQUFTLElBQUlOO1lBQ3pELE1BQU1VLGNBQ0p4QyxvQkFBb0JtQyxvQkFBQUEscUJBQXFCLENBQUNFLFNBQVMsSUFBSU47WUFDekQsTUFBTVUsaUJBQ0p6QyxvQkFBb0JtQyxvQkFBQUEscUJBQXFCLENBQUNHLFlBQVksSUFBSU47WUFFNUQsa0dBQWtHO1lBQ2xHLElBQUksQ0FBRU8sQ0FBQUEsY0FBY0MsZUFBZUMsY0FBQUEsQ0FBYSxFQUFJO2dCQUNsRCxPQUFPUjtZQUNUO1lBRUEscUJBQ0U7O2tDQUNFLHFCQUFDUyxRQUFBQTt3QkFBS0MsTUFBSzt3QkFBU0MsU0FBUTs7b0JBUGhDLEtBUTJDLElBQWIsY0FDeEIscUJBQUNGLFFBQUFBO3dCQUNDQyxNQUFLO3dCQUNMQyxTQUFTQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0NBQUFBLEVBQW1DN0M7O29CQUcvQ2tDLGVBQWUsQ0FBQ2xDLGdCQUFnQjs7O1FBR3ZDO1FBRUEsT0FBT2lDO0lBQ1Q7QUFDRjtBQUVPLG9DQUFvQyxFQUN6Q0gsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFlBQVksRUFDWkMsUUFBUSxFQUN3QjtJQUNoQyw2RUFBNkU7SUFDN0UscUVBQXFFO0lBQ3JFLHdFQUF3RTtJQUN4RSxtRUFBbUU7SUFDbkUsTUFBTTlCLFdBQVcyQyxDQUFBQSxHQUFBQSxxQkFBQUEsb0JBQUFBO0lBQ2pCLE1BQU10QyxlQUFldUMsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0MsK0JBQUFBLGtCQUFrQjtJQUNsRCxNQUFNQyxtQkFBbUIsQ0FBQyxDQUFFbkIsQ0FBQUEsWUFBWUMsYUFBYUMsWUFBQUEsQ0FBVztJQUVoRSxJQUFJaUIsa0JBQWtCO1FBQ3BCLHFCQUNFLHFCQUFDdkQsaUNBQUFBO1lBQ0NTLFVBQVVBO1lBQ1YyQixVQUFVQTtZQUNWQyxXQUFXQTtZQUNYQyxjQUFjQTtZQUNkeEIsY0FBY0E7c0JBRWJ5Qjs7SUFHUDtJQUVBLHFCQUFPO2tCQUFHQTs7QUFDWjtLQTdCZ0J4QyIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9jbGllbnQvY29tcG9uZW50cy9odHRwLWFjY2Vzcy1mYWxsYmFjay9lcnJvci1ib3VuZGFyeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8qKlxuICogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkgaXMgYSBib3VuZGFyeSB0aGF0IGNhdGNoZXMgZXJyb3JzIGFuZCByZW5kZXJzIGFcbiAqIGZhbGxiYWNrIGNvbXBvbmVudCBmb3IgSFRUUCBlcnJvcnMuXG4gKlxuICogSXQgcmVjZWl2ZXMgdGhlIHN0YXR1cyBjb2RlLCBhbmQgZGV0ZXJtaW5lIGlmIGl0IHNob3VsZCByZW5kZXIgZmFsbGJhY2tzIGZvciBmZXcgSFRUUCA0eHggZXJyb3JzLlxuICpcbiAqIGUuZy4gNDA0XG4gKiA0MDQgcmVwcmVzZW50cyBub3QgZm91bmQsIGFuZCB0aGUgZmFsbGJhY2sgY29tcG9uZW50IHBhaXIgY29udGFpbnMgdGhlIGNvbXBvbmVudCBhbmQgaXRzIHN0eWxlcy5cbiAqXG4gKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVVudHJhY2tlZFBhdGhuYW1lIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi11bnRyYWNrZWQnXG5pbXBvcnQge1xuICBIVFRQQWNjZXNzRXJyb3JTdGF0dXMsXG4gIGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyxcbiAgZ2V0QWNjZXNzRmFsbGJhY2tFcnJvclR5cGVCeVN0YXR1cyxcbiAgaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcixcbn0gZnJvbSAnLi9odHRwLWFjY2Vzcy1mYWxsYmFjaydcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgeyBNaXNzaW5nU2xvdENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5UHJvcHMge1xuICBub3RGb3VuZD86IFJlYWN0LlJlYWN0Tm9kZVxuICBmb3JiaWRkZW4/OiBSZWFjdC5SZWFjdE5vZGVcbiAgdW5hdXRob3JpemVkPzogUmVhY3QuUmVhY3ROb2RlXG4gIC8vIFRPRE86IE1ha2UgdGhpcyByZXF1aXJlZCBvbmNlIGBSZWFjdC5jcmVhdGVFbGVtZW50YCB1bmRlcnN0YW5kcyB0aGF0IHBvc2l0aW9uYWwgYXJncyBnbyBpbnRvIGNoaWxkcmVuXG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlXG4gIG1pc3NpbmdTbG90cz86IFNldDxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHNcbiAgZXh0ZW5kcyBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzIHtcbiAgcGF0aG5hbWU6IHN0cmluZyB8IG51bGxcbiAgbWlzc2luZ1Nsb3RzPzogU2V0PHN0cmluZz5cbn1cblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlIHtcbiAgdHJpZ2dlcmVkU3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgcHJldmlvdXNQYXRobmFtZTogc3RyaW5nIHwgbnVsbFxufVxuXG5jbGFzcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB0cmlnZ2VyZWRTdGF0dXM6IHVuZGVmaW5lZCxcbiAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB0aGlzLnByb3BzLm1pc3NpbmdTbG90cyAmJlxuICAgICAgdGhpcy5wcm9wcy5taXNzaW5nU2xvdHMuc2l6ZSA+IDAgJiZcbiAgICAgIC8vIEEgbWlzc2luZyBjaGlsZHJlbiBzbG90IGlzIHRoZSB0eXBpY2FsIG5vdC1mb3VuZCBjYXNlLCBzbyBubyBuZWVkIHRvIHdhcm5cbiAgICAgICF0aGlzLnByb3BzLm1pc3NpbmdTbG90cy5oYXMoJ2NoaWxkcmVuJylcbiAgICApIHtcbiAgICAgIGxldCB3YXJuaW5nTWVzc2FnZSA9XG4gICAgICAgICdObyBkZWZhdWx0IGNvbXBvbmVudCB3YXMgZm91bmQgZm9yIGEgcGFyYWxsZWwgcm91dGUgcmVuZGVyZWQgb24gdGhpcyBwYWdlLiBGYWxsaW5nIGJhY2sgdG8gbmVhcmVzdCBOb3RGb3VuZCBib3VuZGFyeS5cXG4nICtcbiAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcGFyYWxsZWwtcm91dGVzI2RlZmF1bHRqc1xcblxcbidcblxuICAgICAgY29uc3QgZm9ybWF0dGVkU2xvdHMgPSBBcnJheS5mcm9tKHRoaXMucHJvcHMubWlzc2luZ1Nsb3RzKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKVxuICAgICAgICAubWFwKChzbG90KSA9PiBgQCR7c2xvdH1gKVxuICAgICAgICAuam9pbignLCAnKVxuXG4gICAgICB3YXJuaW5nTWVzc2FnZSArPSAnTWlzc2luZyBzbG90czogJyArIGZvcm1hdHRlZFNsb3RzXG5cbiAgICAgIHdhcm5PbmNlKHdhcm5pbmdNZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIGlmIChpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKGVycm9yKSkge1xuICAgICAgY29uc3QgaHR0cFN0YXR1cyA9IGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyhlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1czogaHR0cFN0YXR1cyxcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICBwcm9wczogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzLFxuICAgIHN0YXRlOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZVxuICApOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZSB8IG51bGwge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzZXQgb2YgdGhlIGVycm9yIGJvdW5kYXJ5IHdoZW4gYSBuYXZpZ2F0aW9uIGhhcHBlbnMuXG4gICAgICogRW5zdXJlcyB0aGUgZXJyb3IgYm91bmRhcnkgZG9lcyBub3Qgc3RheSBlbmFibGVkIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLlxuICAgICAqIEFwcHJvYWNoIG9mIHNldFN0YXRlIGluIHJlbmRlciBpcyBzYWZlIGFzIGl0IGNoZWNrcyB0aGUgcHJldmlvdXMgcGF0aG5hbWUgYW5kIHRoZW4gb3ZlcnJpZGVzXG4gICAgICogaXQgYXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZVN0YXRlI3N0b3JpbmctaW5mb3JtYXRpb24tZnJvbS1wcmV2aW91cy1yZW5kZXJzXG4gICAgICovXG4gICAgaWYgKHByb3BzLnBhdGhuYW1lICE9PSBzdGF0ZS5wcmV2aW91c1BhdGhuYW1lICYmIHN0YXRlLnRyaWdnZXJlZFN0YXR1cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJpZ2dlcmVkU3RhdHVzOiBzdGF0ZS50cmlnZ2VyZWRTdGF0dXMsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBub3RGb3VuZCwgZm9yYmlkZGVuLCB1bmF1dGhvcml6ZWQsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyB0cmlnZ2VyZWRTdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBlcnJvckNvbXBvbmVudHMgPSB7XG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLk5PVF9GT1VORF06IG5vdEZvdW5kLFxuICAgICAgW0hUVFBBY2Nlc3NFcnJvclN0YXR1cy5GT1JCSURERU5dOiBmb3JiaWRkZW4sXG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLlVOQVVUSE9SSVpFRF06IHVuYXV0aG9yaXplZCxcbiAgICB9XG5cbiAgICBpZiAodHJpZ2dlcmVkU3RhdHVzKSB7XG4gICAgICBjb25zdCBpc05vdEZvdW5kID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuTk9UX0ZPVU5EICYmIG5vdEZvdW5kXG4gICAgICBjb25zdCBpc0ZvcmJpZGRlbiA9XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1cyA9PT0gSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLkZPUkJJRERFTiAmJiBmb3JiaWRkZW5cbiAgICAgIGNvbnN0IGlzVW5hdXRob3JpemVkID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuVU5BVVRIT1JJWkVEICYmIHVuYXV0aG9yaXplZFxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoZWQgYm91bmRhcnkgaW4gdGhpcyBsYXllciwga2VlcCB0aHJvd2luZyB0aGUgZXJyb3IgYnkgcmVuZGVyaW5nIHRoZSBjaGlsZHJlblxuICAgICAgaWYgKCEoaXNOb3RGb3VuZCB8fCBpc0ZvcmJpZGRlbiB8fCBpc1VuYXV0aG9yaXplZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cInJvYm90c1wiIGNvbnRlbnQ9XCJub2luZGV4XCIgLz5cbiAgICAgICAgICB7cHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgKFxuICAgICAgICAgICAgPG1ldGFcbiAgICAgICAgICAgICAgbmFtZT1cImJvdW5kYXJ5LW5leHQtZXJyb3JcIlxuICAgICAgICAgICAgICBjb250ZW50PXtnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKHRyaWdnZXJlZFN0YXR1cyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAge2Vycm9yQ29tcG9uZW50c1t0cmlnZ2VyZWRTdGF0dXNdfVxuICAgICAgICA8Lz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkoe1xuICBub3RGb3VuZCxcbiAgZm9yYmlkZGVuLFxuICB1bmF1dGhvcml6ZWQsXG4gIGNoaWxkcmVuLFxufTogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcykge1xuICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwsIHRoaXMgd2lsbCByZXR1cm4gbnVsbC4gVGhpc1xuICAvLyBpcyBiZWNhdXNlIHdlIHdvbid0IGJlIHJlbmRlcmluZyBhbnkgbm90IGZvdW5kIGJvdW5kYXJpZXMgb3IgZXJyb3JcbiAgLy8gYm91bmRhcmllcyBmb3IgdGhlIG1pc3NpbmcgcGFyYW1zIHNoZWxsLiBXaGVuIHRoaXMgcnVucyBvbiB0aGUgY2xpZW50XG4gIC8vICh3aGVyZSB0aGVzZSBlcnJvciBjYW4gb2NjdXIpLCB3ZSB3aWxsIGdldCB0aGUgY29ycmVjdCBwYXRobmFtZS5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VVbnRyYWNrZWRQYXRobmFtZSgpXG4gIGNvbnN0IG1pc3NpbmdTbG90cyA9IHVzZUNvbnRleHQoTWlzc2luZ1Nsb3RDb250ZXh0KVxuICBjb25zdCBoYXNFcnJvckZhbGxiYWNrID0gISEobm90Rm91bmQgfHwgZm9yYmlkZGVuIHx8IHVuYXV0aG9yaXplZClcblxuICBpZiAoaGFzRXJyb3JGYWxsYmFjaykge1xuICAgIHJldHVybiAoXG4gICAgICA8SFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVxuICAgICAgICBwYXRobmFtZT17cGF0aG5hbWV9XG4gICAgICAgIG5vdEZvdW5kPXtub3RGb3VuZH1cbiAgICAgICAgZm9yYmlkZGVuPXtmb3JiaWRkZW59XG4gICAgICAgIHVuYXV0aG9yaXplZD17dW5hdXRob3JpemVkfVxuICAgICAgICBtaXNzaW5nU2xvdHM9e21pc3NpbmdTbG90c31cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9IVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cbiJdLCJuYW1lcyI6WyJIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsIkhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnkiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzdGF0ZSIsInRyaWdnZXJlZFN0YXR1cyIsInVuZGVmaW5lZCIsInByZXZpb3VzUGF0aG5hbWUiLCJwYXRobmFtZSIsImNvbXBvbmVudERpZENhdGNoIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibWlzc2luZ1Nsb3RzIiwic2l6ZSIsImhhcyIsIndhcm5pbmdNZXNzYWdlIiwiZm9ybWF0dGVkU2xvdHMiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwibWFwIiwic2xvdCIsImpvaW4iLCJ3YXJuT25jZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImVycm9yIiwiaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciIsImh0dHBTdGF0dXMiLCJnZXRBY2Nlc3NGYWxsYmFja0hUVFBTdGF0dXMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJyZW5kZXIiLCJub3RGb3VuZCIsImZvcmJpZGRlbiIsInVuYXV0aG9yaXplZCIsImNoaWxkcmVuIiwiZXJyb3JDb21wb25lbnRzIiwiSFRUUEFjY2Vzc0Vycm9yU3RhdHVzIiwiTk9UX0ZPVU5EIiwiRk9SQklEREVOIiwiVU5BVVRIT1JJWkVEIiwiaXNOb3RGb3VuZCIsImlzRm9yYmlkZGVuIiwiaXNVbmF1dGhvcml6ZWQiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzIiwidXNlVW50cmFja2VkUGF0aG5hbWUiLCJ1c2VDb250ZXh0IiwiTWlzc2luZ1Nsb3RDb250ZXh0IiwiaGFzRXJyb3JGYWxsYmFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/navigation-devtools.js":
/*!**************************************************************************!*\
  !*** ../node_modules/next/dist/client/components/navigation-devtools.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createNestedLayoutNavigationPromises: function() {\n        return createNestedLayoutNavigationPromises;\n    },\n    createRootNavigationPromises: function() {\n        return createRootNavigationPromises;\n    }\n});\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _segment = __webpack_require__(/*! ../../shared/lib/segment */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/segment.js\");\nconst layoutSegmentPromisesCache = new WeakMap();\n/**\n * Creates instrumented promises for layout segment hooks at a given tree level.\n * This is dev-only code for React Suspense DevTools instrumentation.\n */ function createLayoutSegmentPromises(tree) {\n    if (false) {}\n    // Check if we already have cached promises for this tree\n    const cached = layoutSegmentPromisesCache.get(tree);\n    if (cached) {\n        return cached;\n    }\n    // Create new promises and cache them\n    const segmentPromises = new Map();\n    const segmentsPromises = new Map();\n    const parallelRoutes = tree[1];\n    for (const parallelRouteKey of Object.keys(parallelRoutes)){\n        const segments = (0, _segment.getSelectedLayoutSegmentPath)(tree, parallelRouteKey);\n        // Use the shared logic to compute the segment value\n        const segment = (0, _segment.computeSelectedLayoutSegment)(segments, parallelRouteKey);\n        segmentPromises.set(parallelRouteKey, (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSelectedLayoutSegment', segment));\n        segmentsPromises.set(parallelRouteKey, (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSelectedLayoutSegments', segments));\n    }\n    const result = {\n        selectedLayoutSegmentPromises: segmentPromises,\n        selectedLayoutSegmentsPromises: segmentsPromises\n    };\n    // Cache the result for future renders\n    layoutSegmentPromisesCache.set(tree, result);\n    return result;\n}\nconst rootNavigationPromisesCache = new WeakMap();\nfunction createRootNavigationPromises(tree, pathname, searchParams, pathParams) {\n    if (false) {}\n    // Create stable cache keys from the values\n    const searchParamsString = searchParams.toString();\n    const pathParamsString = JSON.stringify(pathParams);\n    const cacheKey = `${pathname}:${searchParamsString}:${pathParamsString}`;\n    // Get or create the cache for this tree\n    let treeCache = rootNavigationPromisesCache.get(tree);\n    if (!treeCache) {\n        treeCache = new Map();\n        rootNavigationPromisesCache.set(tree, treeCache);\n    }\n    // Check if we have cached promises for this combination\n    const cached = treeCache.get(cacheKey);\n    if (cached) {\n        return cached;\n    }\n    const readonlySearchParams = new _hooksclientcontextsharedruntime.ReadonlyURLSearchParams(searchParams);\n    const layoutSegmentPromises = createLayoutSegmentPromises(tree);\n    const promises = {\n        pathname: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('usePathname', pathname),\n        searchParams: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useSearchParams', readonlySearchParams),\n        params: (0, _hooksclientcontextsharedruntime.createDevToolsInstrumentedPromise)('useParams', pathParams),\n        ...layoutSegmentPromises\n    };\n    treeCache.set(cacheKey, promises);\n    return promises;\n}\nconst nestedLayoutPromisesCache = new WeakMap();\nfunction createNestedLayoutNavigationPromises(tree, parentNavPromises) {\n    if (false) {}\n    const parallelRoutes = tree[1];\n    const parallelRouteKeys = Object.keys(parallelRoutes);\n    // Only create promises if there are parallel routes at this level\n    if (parallelRouteKeys.length === 0) {\n        return null;\n    }\n    // Get or create the cache for this tree\n    let treeCache = nestedLayoutPromisesCache.get(tree);\n    if (!treeCache) {\n        treeCache = new Map();\n        nestedLayoutPromisesCache.set(tree, treeCache);\n    }\n    // Check if we have cached promises for this parent combination\n    const cached = treeCache.get(parentNavPromises);\n    if (cached) {\n        return cached;\n    }\n    // Create merged promises\n    const layoutSegmentPromises = createLayoutSegmentPromises(tree);\n    const promises = {\n        ...parentNavPromises,\n        ...layoutSegmentPromises\n    };\n    treeCache.set(parentNavPromises, promises);\n    return promises;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation-devtools.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24tZGV2dG9vbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBMklnQkEsb0NBQW9DO2VBQXBDQTs7SUF4REFDLDRCQUE0QjtlQUE1QkE7Ozs2REE1RVQ7cUNBSUE7QUFVUCxNQUFNQyw2QkFBNkIsSUFBSUM7QUFLdkM7OztDQUdDLEdBQ0QsU0FBU0MsNEJBQ1BDLElBQXVCO0lBRXZCLElBQUlDLEtBQW9CLEVBQW1CLEVBRTFDO0lBRUQseURBQXlEO0lBQ3pELE1BQU1HLFNBQVNQLDJCQUEyQlEsR0FBRyxDQUFDTDtJQUM5QyxJQUFJSSxRQUFRO1FBQ1YsT0FBT0E7SUFDVDtJQUVBLHFDQUFxQztJQUNyQyxNQUFNRSxrQkFBa0IsSUFBSUM7SUFDNUIsTUFBTUMsbUJBQW1CLElBQUlEO0lBRTdCLE1BQU1FLGlCQUFpQlQsSUFBSSxDQUFDLEVBQUU7SUFDOUIsS0FBSyxNQUFNVSxvQkFBb0JDLE9BQU9DLElBQUksQ0FBQ0gsZ0JBQWlCO1FBQzFELE1BQU1JLFdBQVdDLENBQUFBLEdBQUFBLFNBQUFBLDRCQUFBQSxFQUE2QmQsTUFBTVU7UUFFcEQsb0RBQW9EO1FBQ3BELE1BQU1LLFVBQVVDLENBQUFBLEdBQUFBLFNBQUFBLDRCQUFBQSxFQUE2QkgsVUFBVUg7UUFFdkRKLGdCQUFnQlcsR0FBRyxDQUNqQlAsa0JBQ0FRLENBQUFBLEdBQUFBLGlDQUFBQSxpQ0FBQUEsRUFBa0MsNEJBQTRCSDtRQUVoRVAsaUJBQWlCUyxHQUFHLENBQ2xCUCxrQkFDQVEsQ0FBQUEsR0FBQUEsaUNBQUFBLGlDQUFBQSxFQUFrQyw2QkFBNkJMO0lBRW5FO0lBRUEsTUFBTU0sU0FBcUM7UUFDekNDLCtCQUErQmQ7UUFDL0JlLGdDQUFnQ2I7SUFDbEM7SUFFQSxzQ0FBc0M7SUFDdENYLDJCQUEyQm9CLEdBQUcsQ0FBQ2pCLE1BQU1tQjtJQUVyQyxPQUFPQTtBQUNUO0FBRUEsTUFBTUcsOEJBQThCLElBQUl4QjtBQVFqQyxTQUFTRiw2QkFDZEksSUFBdUIsRUFDdkJ1QixRQUFnQixFQUNoQkMsWUFBNkIsRUFDN0JDLFVBQWtCO0lBRWxCLElBQUl4QixLQUFvQixFQUFtQixFQUUxQztJQUVELDJDQUEyQztJQUMzQyxNQUFNeUIscUJBQXFCRixhQUFhRyxRQUFRO0lBQ2hELE1BQU1DLG1CQUFtQkMsS0FBS0MsU0FBUyxDQUFDTDtJQUN4QyxNQUFNTSxXQUFXLEdBQUdSLFNBQVMsQ0FBQyxFQUFFRyxtQkFBbUIsQ0FBQyxFQUFFRSxrQkFBa0I7SUFFeEUsd0NBQXdDO0lBQ3hDLElBQUlJLFlBQVlWLDRCQUE0QmpCLEdBQUcsQ0FBQ0w7SUFDaEQsSUFBSSxDQUFDZ0MsV0FBVztRQUNkQSxZQUFZLElBQUl6QjtRQUNoQmUsNEJBQTRCTCxHQUFHLENBQUNqQixNQUFNZ0M7SUFDeEM7SUFFQSx3REFBd0Q7SUFDeEQsTUFBTTVCLFNBQVM0QixVQUFVM0IsR0FBRyxDQUFDMEI7SUFDN0IsSUFBSTNCLFFBQVE7UUFDVixPQUFPQTtJQUNUO0lBRUEsTUFBTTZCLHVCQUF1QixJQUFJQyxpQ0FBQUEsdUJBQXVCLENBQUNWO0lBRXpELE1BQU1XLHdCQUF3QnBDLDRCQUE0QkM7SUFFMUQsTUFBTW9DLFdBQStCO1FBQ25DYixVQUFVTCxDQUFBQSxHQUFBQSxpQ0FBQUEsaUNBQUFBLEVBQWtDLGVBQWVLO1FBQzNEQyxjQUFjTixDQUFBQSxHQUFBQSxpQ0FBQUEsaUNBQUFBLEVBQ1osbUJBQ0FlO1FBRUZJLFFBQVFuQixDQUFBQSxHQUFBQSxpQ0FBQUEsaUNBQUFBLEVBQWtDLGFBQWFPO1FBQ3ZELEdBQUdVLHFCQUFxQjtJQUMxQjtJQUVBSCxVQUFVZixHQUFHLENBQUNjLFVBQVVLO0lBRXhCLE9BQU9BO0FBQ1Q7QUFFQSxNQUFNRSw0QkFBNEIsSUFBSXhDO0FBUy9CLFNBQVNILHFDQUNkSyxJQUF1QixFQUN2QnVDLGlCQUE0QztJQUU1QyxJQUFJdEMsS0FBb0IsRUFBbUIsRUFFMUM7SUFFRCxNQUFNUSxpQkFBaUJULElBQUksQ0FBQyxFQUFFO0lBQzlCLE1BQU13QyxvQkFBb0I3QixPQUFPQyxJQUFJLENBQUNIO0lBRXRDLGtFQUFrRTtJQUNsRSxJQUFJK0Isa0JBQWtCQyxNQUFNLEtBQUssR0FBRztRQUNsQyxPQUFPO0lBQ1Q7SUFFQSx3Q0FBd0M7SUFDeEMsSUFBSVQsWUFBWU0sMEJBQTBCakMsR0FBRyxDQUFDTDtJQUM5QyxJQUFJLENBQUNnQyxXQUFXO1FBQ2RBLFlBQVksSUFBSXpCO1FBQ2hCK0IsMEJBQTBCckIsR0FBRyxDQUFDakIsTUFBTWdDO0lBQ3RDO0lBRUEsK0RBQStEO0lBQy9ELE1BQU01QixTQUFTNEIsVUFBVTNCLEdBQUcsQ0FBQ2tDO0lBQzdCLElBQUluQyxRQUFRO1FBQ1YsT0FBT0E7SUFDVDtJQUVBLHlCQUF5QjtJQUN6QixNQUFNK0Isd0JBQXdCcEMsNEJBQTRCQztJQUMxRCxNQUFNb0MsV0FBK0I7UUFDbkMsR0FBR0csaUJBQWlCO1FBQ3BCLEdBQUdKLHFCQUFxQjtJQUMxQjtJQUVBSCxVQUFVZixHQUFHLENBQUNzQixtQkFBbUJIO0lBRWpDLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aXRhbGl5dWxpdG92c2t5L3NyYy9jbGllbnQvY29tcG9uZW50cy9uYXZpZ2F0aW9uLWRldnRvb2xzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcbmltcG9ydCB7XG4gIGNyZWF0ZURldlRvb2xzSW5zdHJ1bWVudGVkUHJvbWlzZSxcbiAgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMsXG4gIHR5cGUgSW5zdHJ1bWVudGVkUHJvbWlzZSxcbiAgdHlwZSBOYXZpZ2F0aW9uUHJvbWlzZXMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQge1xuICBjb21wdXRlU2VsZWN0ZWRMYXlvdXRTZWdtZW50LFxuICBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5cbi8qKlxuICogUHJvbWlzZXMgYXJlIGNhY2hlZCBieSB0cmVlIHRvIGVuc3VyZSBzdGFiaWxpdHkgYWNyb3NzIHN1c3BlbnNlIHJldHJpZXMuXG4gKi9cbnR5cGUgTGF5b3V0U2VnbWVudFByb21pc2VzQ2FjaGUgPSB7XG4gIHNlbGVjdGVkTGF5b3V0U2VnbWVudFByb21pc2VzOiBNYXA8c3RyaW5nLCBJbnN0cnVtZW50ZWRQcm9taXNlPHN0cmluZyB8IG51bGw+PlxuICBzZWxlY3RlZExheW91dFNlZ21lbnRzUHJvbWlzZXM6IE1hcDxzdHJpbmcsIEluc3RydW1lbnRlZFByb21pc2U8c3RyaW5nW10+PlxufVxuXG5jb25zdCBsYXlvdXRTZWdtZW50UHJvbWlzZXNDYWNoZSA9IG5ldyBXZWFrTWFwPFxuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgTGF5b3V0U2VnbWVudFByb21pc2VzQ2FjaGVcbj4oKVxuXG4vKipcbiAqIENyZWF0ZXMgaW5zdHJ1bWVudGVkIHByb21pc2VzIGZvciBsYXlvdXQgc2VnbWVudCBob29rcyBhdCBhIGdpdmVuIHRyZWUgbGV2ZWwuXG4gKiBUaGlzIGlzIGRldi1vbmx5IGNvZGUgZm9yIFJlYWN0IFN1c3BlbnNlIERldlRvb2xzIGluc3RydW1lbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGF5b3V0U2VnbWVudFByb21pc2VzKFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogTGF5b3V0U2VnbWVudFByb21pc2VzQ2FjaGUgfCBudWxsIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGNhY2hlZCBwcm9taXNlcyBmb3IgdGhpcyB0cmVlXG4gIGNvbnN0IGNhY2hlZCA9IGxheW91dFNlZ21lbnRQcm9taXNlc0NhY2hlLmdldCh0cmVlKVxuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZFxuICB9XG5cbiAgLy8gQ3JlYXRlIG5ldyBwcm9taXNlcyBhbmQgY2FjaGUgdGhlbVxuICBjb25zdCBzZWdtZW50UHJvbWlzZXMgPSBuZXcgTWFwPHN0cmluZywgSW5zdHJ1bWVudGVkUHJvbWlzZTxzdHJpbmcgfCBudWxsPj4oKVxuICBjb25zdCBzZWdtZW50c1Byb21pc2VzID0gbmV3IE1hcDxzdHJpbmcsIEluc3RydW1lbnRlZFByb21pc2U8c3RyaW5nW10+PigpXG5cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSB0cmVlWzFdXG4gIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBvZiBPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IGdldFNlbGVjdGVkTGF5b3V0U2VnbWVudFBhdGgodHJlZSwgcGFyYWxsZWxSb3V0ZUtleSlcblxuICAgIC8vIFVzZSB0aGUgc2hhcmVkIGxvZ2ljIHRvIGNvbXB1dGUgdGhlIHNlZ21lbnQgdmFsdWVcbiAgICBjb25zdCBzZWdtZW50ID0gY29tcHV0ZVNlbGVjdGVkTGF5b3V0U2VnbWVudChzZWdtZW50cywgcGFyYWxsZWxSb3V0ZUtleSlcblxuICAgIHNlZ21lbnRQcm9taXNlcy5zZXQoXG4gICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgY3JlYXRlRGV2VG9vbHNJbnN0cnVtZW50ZWRQcm9taXNlKCd1c2VTZWxlY3RlZExheW91dFNlZ21lbnQnLCBzZWdtZW50KVxuICAgIClcbiAgICBzZWdtZW50c1Byb21pc2VzLnNldChcbiAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICBjcmVhdGVEZXZUb29sc0luc3RydW1lbnRlZFByb21pc2UoJ3VzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHMnLCBzZWdtZW50cylcbiAgICApXG4gIH1cblxuICBjb25zdCByZXN1bHQ6IExheW91dFNlZ21lbnRQcm9taXNlc0NhY2hlID0ge1xuICAgIHNlbGVjdGVkTGF5b3V0U2VnbWVudFByb21pc2VzOiBzZWdtZW50UHJvbWlzZXMsXG4gICAgc2VsZWN0ZWRMYXlvdXRTZWdtZW50c1Byb21pc2VzOiBzZWdtZW50c1Byb21pc2VzLFxuICB9XG5cbiAgLy8gQ2FjaGUgdGhlIHJlc3VsdCBmb3IgZnV0dXJlIHJlbmRlcnNcbiAgbGF5b3V0U2VnbWVudFByb21pc2VzQ2FjaGUuc2V0KHRyZWUsIHJlc3VsdClcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IHJvb3ROYXZpZ2F0aW9uUHJvbWlzZXNDYWNoZSA9IG5ldyBXZWFrTWFwPFxuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgTWFwPHN0cmluZywgTmF2aWdhdGlvblByb21pc2VzPlxuPigpXG5cbi8qKlxuICogQ3JlYXRlcyBpbnN0cnVtZW50ZWQgbmF2aWdhdGlvbiBwcm9taXNlcyBmb3IgdGhlIHJvb3QgYXBwLXJvdXRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvb3ROYXZpZ2F0aW9uUHJvbWlzZXMoXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcyxcbiAgcGF0aFBhcmFtczogUGFyYW1zXG4pOiBOYXZpZ2F0aW9uUHJvbWlzZXMgfCBudWxsIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQ3JlYXRlIHN0YWJsZSBjYWNoZSBrZXlzIGZyb20gdGhlIHZhbHVlc1xuICBjb25zdCBzZWFyY2hQYXJhbXNTdHJpbmcgPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKVxuICBjb25zdCBwYXRoUGFyYW1zU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkocGF0aFBhcmFtcylcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHtwYXRobmFtZX06JHtzZWFyY2hQYXJhbXNTdHJpbmd9OiR7cGF0aFBhcmFtc1N0cmluZ31gXG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgY2FjaGUgZm9yIHRoaXMgdHJlZVxuICBsZXQgdHJlZUNhY2hlID0gcm9vdE5hdmlnYXRpb25Qcm9taXNlc0NhY2hlLmdldCh0cmVlKVxuICBpZiAoIXRyZWVDYWNoZSkge1xuICAgIHRyZWVDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBOYXZpZ2F0aW9uUHJvbWlzZXM+KClcbiAgICByb290TmF2aWdhdGlvblByb21pc2VzQ2FjaGUuc2V0KHRyZWUsIHRyZWVDYWNoZSlcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIGhhdmUgY2FjaGVkIHByb21pc2VzIGZvciB0aGlzIGNvbWJpbmF0aW9uXG4gIGNvbnN0IGNhY2hlZCA9IHRyZWVDYWNoZS5nZXQoY2FjaGVLZXkpXG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkXG4gIH1cblxuICBjb25zdCByZWFkb25seVNlYXJjaFBhcmFtcyA9IG5ldyBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpXG5cbiAgY29uc3QgbGF5b3V0U2VnbWVudFByb21pc2VzID0gY3JlYXRlTGF5b3V0U2VnbWVudFByb21pc2VzKHRyZWUpXG5cbiAgY29uc3QgcHJvbWlzZXM6IE5hdmlnYXRpb25Qcm9taXNlcyA9IHtcbiAgICBwYXRobmFtZTogY3JlYXRlRGV2VG9vbHNJbnN0cnVtZW50ZWRQcm9taXNlKCd1c2VQYXRobmFtZScsIHBhdGhuYW1lKSxcbiAgICBzZWFyY2hQYXJhbXM6IGNyZWF0ZURldlRvb2xzSW5zdHJ1bWVudGVkUHJvbWlzZShcbiAgICAgICd1c2VTZWFyY2hQYXJhbXMnLFxuICAgICAgcmVhZG9ubHlTZWFyY2hQYXJhbXNcbiAgICApLFxuICAgIHBhcmFtczogY3JlYXRlRGV2VG9vbHNJbnN0cnVtZW50ZWRQcm9taXNlKCd1c2VQYXJhbXMnLCBwYXRoUGFyYW1zKSxcbiAgICAuLi5sYXlvdXRTZWdtZW50UHJvbWlzZXMsXG4gIH1cblxuICB0cmVlQ2FjaGUuc2V0KGNhY2hlS2V5LCBwcm9taXNlcylcblxuICByZXR1cm4gcHJvbWlzZXNcbn1cblxuY29uc3QgbmVzdGVkTGF5b3V0UHJvbWlzZXNDYWNoZSA9IG5ldyBXZWFrTWFwPFxuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgTWFwPE5hdmlnYXRpb25Qcm9taXNlcyB8IG51bGwsIE5hdmlnYXRpb25Qcm9taXNlcz5cbj4oKVxuXG4vKipcbiAqIENyZWF0ZXMgbWVyZ2VkIG5hdmlnYXRpb24gcHJvbWlzZXMgZm9yIG5lc3RlZCBsYXlvdXRzLlxuICogTWVyZ2VzIHBhcmVudCBwcm9taXNlcyB3aXRoIGxheW91dC1zcGVjaWZpYyBzZWdtZW50IHByb21pc2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTmVzdGVkTGF5b3V0TmF2aWdhdGlvblByb21pc2VzKFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcGFyZW50TmF2UHJvbWlzZXM6IE5hdmlnYXRpb25Qcm9taXNlcyB8IG51bGxcbik6IE5hdmlnYXRpb25Qcm9taXNlcyB8IG51bGwge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IHRyZWVbMV1cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleXMgPSBPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcylcblxuICAvLyBPbmx5IGNyZWF0ZSBwcm9taXNlcyBpZiB0aGVyZSBhcmUgcGFyYWxsZWwgcm91dGVzIGF0IHRoaXMgbGV2ZWxcbiAgaWYgKHBhcmFsbGVsUm91dGVLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBjYWNoZSBmb3IgdGhpcyB0cmVlXG4gIGxldCB0cmVlQ2FjaGUgPSBuZXN0ZWRMYXlvdXRQcm9taXNlc0NhY2hlLmdldCh0cmVlKVxuICBpZiAoIXRyZWVDYWNoZSkge1xuICAgIHRyZWVDYWNoZSA9IG5ldyBNYXA8TmF2aWdhdGlvblByb21pc2VzIHwgbnVsbCwgTmF2aWdhdGlvblByb21pc2VzPigpXG4gICAgbmVzdGVkTGF5b3V0UHJvbWlzZXNDYWNoZS5zZXQodHJlZSwgdHJlZUNhY2hlKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBjYWNoZWQgcHJvbWlzZXMgZm9yIHRoaXMgcGFyZW50IGNvbWJpbmF0aW9uXG4gIGNvbnN0IGNhY2hlZCA9IHRyZWVDYWNoZS5nZXQocGFyZW50TmF2UHJvbWlzZXMpXG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkXG4gIH1cblxuICAvLyBDcmVhdGUgbWVyZ2VkIHByb21pc2VzXG4gIGNvbnN0IGxheW91dFNlZ21lbnRQcm9taXNlcyA9IGNyZWF0ZUxheW91dFNlZ21lbnRQcm9taXNlcyh0cmVlKVxuICBjb25zdCBwcm9taXNlczogTmF2aWdhdGlvblByb21pc2VzID0ge1xuICAgIC4uLnBhcmVudE5hdlByb21pc2VzISxcbiAgICAuLi5sYXlvdXRTZWdtZW50UHJvbWlzZXMsXG4gIH1cblxuICB0cmVlQ2FjaGUuc2V0KHBhcmVudE5hdlByb21pc2VzLCBwcm9taXNlcylcblxuICByZXR1cm4gcHJvbWlzZXNcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVOZXN0ZWRMYXlvdXROYXZpZ2F0aW9uUHJvbWlzZXMiLCJjcmVhdGVSb290TmF2aWdhdGlvblByb21pc2VzIiwibGF5b3V0U2VnbWVudFByb21pc2VzQ2FjaGUiLCJXZWFrTWFwIiwiY3JlYXRlTGF5b3V0U2VnbWVudFByb21pc2VzIiwidHJlZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNhY2hlZCIsImdldCIsInNlZ21lbnRQcm9taXNlcyIsIk1hcCIsInNlZ21lbnRzUHJvbWlzZXMiLCJwYXJhbGxlbFJvdXRlcyIsInBhcmFsbGVsUm91dGVLZXkiLCJPYmplY3QiLCJrZXlzIiwic2VnbWVudHMiLCJnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoIiwic2VnbWVudCIsImNvbXB1dGVTZWxlY3RlZExheW91dFNlZ21lbnQiLCJzZXQiLCJjcmVhdGVEZXZUb29sc0luc3RydW1lbnRlZFByb21pc2UiLCJyZXN1bHQiLCJzZWxlY3RlZExheW91dFNlZ21lbnRQcm9taXNlcyIsInNlbGVjdGVkTGF5b3V0U2VnbWVudHNQcm9taXNlcyIsInJvb3ROYXZpZ2F0aW9uUHJvbWlzZXNDYWNoZSIsInBhdGhuYW1lIiwic2VhcmNoUGFyYW1zIiwicGF0aFBhcmFtcyIsInNlYXJjaFBhcmFtc1N0cmluZyIsInRvU3RyaW5nIiwicGF0aFBhcmFtc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJjYWNoZUtleSIsInRyZWVDYWNoZSIsInJlYWRvbmx5U2VhcmNoUGFyYW1zIiwiUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMiLCJsYXlvdXRTZWdtZW50UHJvbWlzZXMiLCJwcm9taXNlcyIsInBhcmFtcyIsIm5lc3RlZExheW91dFByb21pc2VzQ2FjaGUiLCJwYXJlbnROYXZQcm9taXNlcyIsInBhcmFsbGVsUm91dGVLZXlzIiwibGVuZ3RoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/navigation-devtools.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/navigation.js":
/*!*****************************************************************!*\
  !*** ../node_modules/next/dist/client/components/navigation.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    // We need the same class that was used to instantiate the context value\n    // Otherwise instanceof checks will fail in usercode\n    ReadonlyURLSearchParams: function() {\n        return _hooksclientcontextsharedruntime.ReadonlyURLSearchParams;\n    },\n    RedirectType: function() {\n        return _navigationreactserver.RedirectType;\n    },\n    ServerInsertedHTMLContext: function() {\n        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;\n    },\n    forbidden: function() {\n        return _navigationreactserver.forbidden;\n    },\n    notFound: function() {\n        return _navigationreactserver.notFound;\n    },\n    permanentRedirect: function() {\n        return _navigationreactserver.permanentRedirect;\n    },\n    redirect: function() {\n        return _navigationreactserver.redirect;\n    },\n    unauthorized: function() {\n        return _navigationreactserver.unauthorized;\n    },\n    unstable_isUnrecognizedActionError: function() {\n        return _unrecognizedactionerror.unstable_isUnrecognizedActionError;\n    },\n    unstable_rethrow: function() {\n        return _navigationreactserver.unstable_rethrow;\n    },\n    useParams: function() {\n        return useParams;\n    },\n    usePathname: function() {\n        return usePathname;\n    },\n    useRouter: function() {\n        return useRouter;\n    },\n    useSearchParams: function() {\n        return useSearchParams;\n    },\n    useSelectedLayoutSegment: function() {\n        return useSelectedLayoutSegment;\n    },\n    useSelectedLayoutSegments: function() {\n        return useSelectedLayoutSegments;\n    },\n    useServerInsertedHTML: function() {\n        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _segment = __webpack_require__(/*! ../../shared/lib/segment */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/segment.js\");\nconst _serverinsertedhtmlsharedruntime = __webpack_require__(/*! ../../shared/lib/server-inserted-html.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js\");\nconst _unrecognizedactionerror = __webpack_require__(/*! ./unrecognized-action-error */ \"(app-pages-browser)/../node_modules/next/dist/client/components/unrecognized-action-error.js\");\nconst _navigationreactserver = __webpack_require__(/*! ./navigation.react-server */ \"(app-pages-browser)/../node_modules/next/dist/client/components/navigation.react-server.js\");\nconst useDynamicRouteParams =  false ? 0 : undefined;\nconst useDynamicSearchParams =  false ? 0 : undefined;\nfunction useSearchParams() {\n    useDynamicSearchParams?.('useSearchParams()');\n    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);\n    // In the case where this is `null`, the compat types added in\n    // `next-env.d.ts` will add a new overload that changes the return type to\n    // include `null`.\n    const readonlySearchParams = (0, _react.useMemo)(()=>{\n        if (!searchParams) {\n            // When the router is not ready in pages, we won't have the search params\n            // available.\n            return null;\n        }\n        return new _hooksclientcontextsharedruntime.ReadonlyURLSearchParams(searchParams);\n    }, [\n        searchParams\n    ]);\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.searchParams);\n        }\n    }\n    return readonlySearchParams;\n}\nfunction usePathname() {\n    useDynamicRouteParams?.('usePathname()');\n    // In the case where this is `null`, the compat types added in `next-env.d.ts`\n    // will add a new overload that changes the return type to include `null`.\n    const pathname = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.pathname);\n        }\n    }\n    return pathname;\n}\nfunction useRouter() {\n    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);\n    if (router === null) {\n        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E238\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return router;\n}\nfunction useParams() {\n    useDynamicRouteParams?.('useParams()');\n    const params = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            return (0, _react.use)(navigationPromises.params);\n        }\n    }\n    return params;\n}\nfunction useSelectedLayoutSegments(parallelRouteKey = 'children') {\n    useDynamicRouteParams?.('useSelectedLayoutSegments()');\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n    if (!context) return null;\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && 'use' in _react.default) {\n        const navigationPromises = (0, _react.use)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n        if (navigationPromises) {\n            const promise = navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey);\n            if (promise) {\n                // We should always have a promise here, but if we don't, it's not worth erroring over.\n                // We just won't be able to instrument it, but can still provide the value.\n                return (0, _react.use)(promise);\n            }\n        }\n    }\n    return (0, _segment.getSelectedLayoutSegmentPath)(context.parentTree, parallelRouteKey);\n}\nfunction useSelectedLayoutSegment(parallelRouteKey = 'children') {\n    _s();\n    useDynamicRouteParams?.('useSelectedLayoutSegment()');\n    const navigationPromises = (0, _react.useContext)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\n    // Instrument with Suspense DevTools (dev-only)\n    if ( true && navigationPromises && 'use' in _react.default) {\n        const promise = navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey);\n        if (promise) {\n            // We should always have a promise here, but if we don't, it's not worth erroring over.\n            // We just won't be able to instrument it, but can still provide the value.\n            return (0, _react.use)(promise);\n        }\n    }\n    return (0, _segment.computeSelectedLayoutSegment)(selectedLayoutSegments, parallelRouteKey);\n}\n_s(useSelectedLayoutSegment, \"rc1U92JxkDTv7MNGlutCvlwOCmc=\", false, function() {\n    return [\n        useSelectedLayoutSegments\n    ];\n});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFnU0Usd0VBQXdFO0lBQ3hFLG9EQUFvRDtJQUNwREEsdUJBQXVCO2VBQXZCQSxpQ0FBQUEsdUJBQXVCOztJQVF2QkMsWUFBWTtlQUFaQSx1QkFBQUEsWUFBWTs7SUFoTFpDLHlCQUF5QjtlQUF6QkEsaUNBQUFBLHlCQUF5Qjs7SUE0S3pCQyxTQUFTO2VBQVRBLHVCQUFBQSxTQUFTOztJQURUQyxRQUFRO2VBQVJBLHVCQUFBQSxRQUFROztJQUlSQyxpQkFBaUI7ZUFBakJBLHVCQUFBQSxpQkFBaUI7O0lBRGpCQyxRQUFRO2VBQVJBLHVCQUFBQSxRQUFROztJQURSQyxZQUFZO2VBQVpBLHVCQUFBQSxZQUFZOztJQVhMQyxrQ0FBa0M7ZUFBbENBLHlCQUFBQSxrQ0FBa0M7O0lBZXpDQyxnQkFBZ0I7ZUFBaEJBLHVCQUFBQSxnQkFBZ0I7O0lBL0hGQyxTQUFTO2VBQVRBOztJQXRFQUMsV0FBVztlQUFYQTs7SUEyQ0FDLFNBQVM7ZUFBVEE7O0lBMUZBQyxlQUFlO2VBQWZBOztJQTRNQUMsd0JBQXdCO2VBQXhCQTs7SUE3Q0FDLHlCQUF5QjtlQUF6QkE7O0lBM0ZkQyxxQkFBcUI7ZUFBckJBLGlDQUFBQSxxQkFBcUI7Ozs7NkVBekh5QjsyREFLekM7NkRBT0E7cUNBSUE7NkRBMEdBO3FEQWdLNEM7bURBZ0I1QztBQXhSUCxNQUFNQyx3QkFDSixNQUE2QixHQUV2QkUsQ0FDcUIsR0FDdkJDO0FBRU4sTUFBTUMseUJBQ0osTUFBNkIsR0FFdkJGLENBQ3NCLEdBQ3hCQztBQXVCQyxTQUFTUDtJQUNkUSx5QkFBeUI7SUFFekIsTUFBTUMsZUFBZUMsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0MsaUNBQUFBLG1CQUFtQjtJQUVuRCw4REFBOEQ7SUFDOUQsMEVBQTBFO0lBQzFFLGtCQUFrQjtJQUNsQixNQUFNQyx1QkFBdUJDLENBQUFBLEdBQUFBLE9BQUFBLE9BQUFBLEVBQVE7UUFDbkMsSUFBSSxDQUFDSixjQUFjO1lBQ2pCLHlFQUF5RTtZQUN6RSxhQUFhO1lBQ2IsT0FBTztRQUNUO1FBRUEsT0FBTyxJQUFJdEIsaUNBQUFBLHVCQUF1QixDQUFDc0I7SUFDckMsR0FBRztRQUFDQTtLQUFhO0lBRWpCLCtDQUErQztJQUMvQyxJQUFJSyxLQUFvQixJQUFxQixTQUFTRyxPQUFBQSxPQUFLLEVBQUU7UUFDM0QsTUFBTUMscUJBQXFCQyxDQUFBQSxHQUFBQSxPQUFBQSxHQUFBQSxFQUFJQyxpQ0FBQUEseUJBQXlCO1FBQ3hELElBQUlGLG9CQUFvQjtZQUN0QixPQUFPQyxDQUFBQSxHQUFBQSxPQUFBQSxHQUFBQSxFQUFJRCxtQkFBbUJULFlBQVk7UUFDNUM7SUFDRjtJQUVBLE9BQU9HO0FBQ1Q7QUFvQk8sU0FBU2Q7SUFDZE0sd0JBQXdCO0lBRXhCLDhFQUE4RTtJQUM5RSwwRUFBMEU7SUFDMUUsTUFBTWlCLFdBQVdYLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQVdZLGlDQUFBQSxlQUFlO0lBRTNDLCtDQUErQztJQUMvQyxJQUFJUixLQUFvQixJQUFxQixTQUFTRyxPQUFBQSxPQUFLLEVBQUU7UUFDM0QsTUFBTUMscUJBQXFCQyxDQUFBQSxHQUFBQSxPQUFBQSxHQUFBQSxFQUFJQyxpQ0FBQUEseUJBQXlCO1FBQ3hELElBQUlGLG9CQUFvQjtZQUN0QixPQUFPQyxDQUFBQSxHQUFBQSxPQUFBQSxHQUFBQSxFQUFJRCxtQkFBbUJHLFFBQVE7UUFDeEM7SUFDRjtJQUVBLE9BQU9BO0FBQ1Q7QUEyQk8sU0FBU3RCO0lBQ2QsTUFBTXdCLFNBQVNiLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQVdjLCtCQUFBQSxnQkFBZ0I7SUFDMUMsSUFBSUQsV0FBVyxNQUFNO1FBQ25CLE1BQU0scUJBQXdELENBQXhELElBQUlFLE1BQU0sZ0RBQVY7bUJBQUE7d0JBQUE7MEJBQUE7UUFBdUQ7SUFDL0Q7SUFFQSxPQUFPRjtBQUNUO0FBb0JPLFNBQVMxQjtJQUNkTyx3QkFBd0I7SUFFeEIsTUFBTXNCLFNBQVNoQixDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUFXaUIsaUNBQUFBLGlCQUFpQjtJQUUzQywrQ0FBK0M7SUFDL0MsSUFBSWIsS0FBb0IsSUFBcUIsU0FBU0csT0FBQUEsT0FBSyxFQUFFO1FBQzNELE1BQU1DLHFCQUFxQkMsQ0FBQUEsR0FBQUEsT0FBQUEsR0FBQUEsRUFBSUMsaUNBQUFBLHlCQUF5QjtRQUN4RCxJQUFJRixvQkFBb0I7WUFDdEIsT0FBT0MsQ0FBQUEsR0FBQUEsT0FBQUEsR0FBQUEsRUFBSUQsbUJBQW1CUSxNQUFNO1FBQ3RDO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUO0FBNEJPLFNBQVN4QiwwQkFDZDBCLG1CQUEyQixVQUFVO0lBRXJDeEIsd0JBQXdCO0lBRXhCLE1BQU15QixVQUFVbkIsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV29CLCtCQUFBQSxtQkFBbUI7SUFDOUMsd0ZBQXdGO0lBQ3hGLElBQUksQ0FBQ0QsU0FBUyxPQUFPO0lBRXJCLCtDQUErQztJQUMvQyxJQUFJZixLQUFvQixJQUFxQixTQUFTRyxPQUFBQSxPQUFLLEVBQUU7UUFDM0QsTUFBTUMscUJBQXFCQyxDQUFBQSxHQUFBQSxPQUFBQSxHQUFBQSxFQUFJQyxpQ0FBQUEseUJBQXlCO1FBQ3hELElBQUlGLG9CQUFvQjtZQUN0QixNQUFNYSxVQUNKYixtQkFBbUJjLDhCQUE4QixFQUFFQyxJQUFJTDtZQUN6RCxJQUFJRyxTQUFTO2dCQUNYLHVGQUF1RjtnQkFDdkYsMkVBQTJFO2dCQUMzRSxPQUFPWixDQUFBQSxHQUFBQSxPQUFBQSxHQUFBQSxFQUFJWTtZQUNiO1FBQ0Y7SUFDRjtJQUVBLE9BQU9HLENBQUFBLEdBQUFBLFNBQUFBLDRCQUFBQSxFQUE2QkwsUUFBUU0sVUFBVSxFQUFFUDtBQUMxRDtBQXFCTyxrQ0FDTEEsbUJBQTJCLFVBQVU7O0lBRXJDeEIsd0JBQXdCO0lBQ3hCLE1BQU1jLHFCQUFxQlIsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV1UsaUNBQUFBLHlCQUF5QjtJQUMvRCxNQUFNZ0IsbURBQW1EUjtJQUV6RCwrQ0FBK0M7SUFDL0MsSUFDRWQsS0FBb0IsSUFDcEJJLHNCQUNBLFNBQVNELE9BQUFBLE9BQUssRUFDZDtRQUNBLE1BQU1jLFVBQ0piLG1CQUFtQm1CLDZCQUE2QixFQUFFSixJQUFJTDtRQUN4RCxJQUFJRyxTQUFTO1lBQ1gsdUZBQXVGO1lBQ3ZGLDJFQUEyRTtZQUMzRSxPQUFPWixDQUFBQSxHQUFBQSxPQUFBQSxHQUFBQSxFQUFJWTtRQUNiO0lBQ0Y7SUFFQSxPQUFPTyxDQUFBQSxHQUFBQSxTQUFBQSw0QkFBQUEsRUFBNkJGLHdCQUF3QlI7QUFDOUQ7R0F2QmdCM0I7O1FBS2lCQyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpdGFsaXl1bGl0b3Zza3kvc3JjL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0LCB1c2VNZW1vLCB1c2UgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIEFwcFJvdXRlckNvbnRleHQsXG4gIExheW91dFJvdXRlckNvbnRleHQsXG4gIHR5cGUgQXBwUm91dGVySW5zdGFuY2UsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dCxcbiAgUGF0aG5hbWVDb250ZXh0LFxuICBQYXRoUGFyYW1zQ29udGV4dCxcbiAgTmF2aWdhdGlvblByb21pc2VzQ29udGV4dCxcbiAgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQge1xuICBjb21wdXRlU2VsZWN0ZWRMYXlvdXRTZWdtZW50LFxuICBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5cbmNvbnN0IHVzZUR5bmFtaWNSb3V0ZVBhcmFtcyA9XG4gIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgPyAoXG4gICAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnKVxuICAgICAgKS51c2VEeW5hbWljUm91dGVQYXJhbXNcbiAgICA6IHVuZGVmaW5lZFxuXG5jb25zdCB1c2VEeW5hbWljU2VhcmNoUGFyYW1zID1cbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IChcbiAgICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZycpXG4gICAgICApLnVzZUR5bmFtaWNTZWFyY2hQYXJhbXNcbiAgICA6IHVuZGVmaW5lZFxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSAqcmVhZCogdGhlIGN1cnJlbnQgVVJMJ3Mgc2VhcmNoIHBhcmFtZXRlcnMuXG4gKlxuICogTGVhcm4gbW9yZSBhYm91dCBbYFVSTFNlYXJjaFBhcmFtc2Agb24gTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVVJMU2VhcmNoUGFyYW1zKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICogICBjb25zdCBzZWFyY2hQYXJhbXMgPSB1c2VTZWFyY2hQYXJhbXMoKVxuICogICBzZWFyY2hQYXJhbXMuZ2V0KCdmb28nKSAvLyByZXR1cm5zICdiYXInIHdoZW4gP2Zvbz1iYXJcbiAqICAgLy8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1c2VTZWFyY2hQYXJhbXNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXNlYXJjaC1wYXJhbXMpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcygpOiBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyB7XG4gIHVzZUR5bmFtaWNTZWFyY2hQYXJhbXM/LigndXNlU2VhcmNoUGFyYW1zKCknKVxuXG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZUNvbnRleHQoU2VhcmNoUGFyYW1zQ29udGV4dClcblxuICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIGlzIGBudWxsYCwgdGhlIGNvbXBhdCB0eXBlcyBhZGRlZCBpblxuICAvLyBgbmV4dC1lbnYuZC50c2Agd2lsbCBhZGQgYSBuZXcgb3ZlcmxvYWQgdGhhdCBjaGFuZ2VzIHRoZSByZXR1cm4gdHlwZSB0b1xuICAvLyBpbmNsdWRlIGBudWxsYC5cbiAgY29uc3QgcmVhZG9ubHlTZWFyY2hQYXJhbXMgPSB1c2VNZW1vKCgpOiBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyA9PiB7XG4gICAgaWYgKCFzZWFyY2hQYXJhbXMpIHtcbiAgICAgIC8vIFdoZW4gdGhlIHJvdXRlciBpcyBub3QgcmVhZHkgaW4gcGFnZXMsIHdlIHdvbid0IGhhdmUgdGhlIHNlYXJjaCBwYXJhbXNcbiAgICAgIC8vIGF2YWlsYWJsZS5cbiAgICAgIHJldHVybiBudWxsIVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zKVxuICB9LCBbc2VhcmNoUGFyYW1zXSlcblxuICAvLyBJbnN0cnVtZW50IHdpdGggU3VzcGVuc2UgRGV2VG9vbHMgKGRldi1vbmx5KVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAndXNlJyBpbiBSZWFjdCkge1xuICAgIGNvbnN0IG5hdmlnYXRpb25Qcm9taXNlcyA9IHVzZShOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0KVxuICAgIGlmIChuYXZpZ2F0aW9uUHJvbWlzZXMpIHtcbiAgICAgIHJldHVybiB1c2UobmF2aWdhdGlvblByb21pc2VzLnNlYXJjaFBhcmFtcylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZG9ubHlTZWFyY2hQYXJhbXNcbn1cblxuLyoqXG4gKiBBIFtDbGllbnQgQ29tcG9uZW50XShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvY2xpZW50LWNvbXBvbmVudHMpIGhvb2tcbiAqIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgY3VycmVudCBVUkwncyBwYXRobmFtZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIFwidXNlIGNsaWVudFwiXG4gKiBpbXBvcnQgeyB1c2VQYXRobmFtZSB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICogIGNvbnN0IHBhdGhuYW1lID0gdXNlUGF0aG5hbWUoKSAvLyByZXR1cm5zIFwiL2Rhc2hib2FyZFwiIG9uIC9kYXNoYm9hcmQ/Zm9vPWJhclxuICogIC8vIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdXNlUGF0aG5hbWVgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXBhdGhuYW1lKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXRobmFtZSgpOiBzdHJpbmcge1xuICB1c2VEeW5hbWljUm91dGVQYXJhbXM/LigndXNlUGF0aG5hbWUoKScpXG5cbiAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgdGhpcyBpcyBgbnVsbGAsIHRoZSBjb21wYXQgdHlwZXMgYWRkZWQgaW4gYG5leHQtZW52LmQudHNgXG4gIC8vIHdpbGwgYWRkIGEgbmV3IG92ZXJsb2FkIHRoYXQgY2hhbmdlcyB0aGUgcmV0dXJuIHR5cGUgdG8gaW5jbHVkZSBgbnVsbGAuXG4gIGNvbnN0IHBhdGhuYW1lID0gdXNlQ29udGV4dChQYXRobmFtZUNvbnRleHQpIGFzIHN0cmluZ1xuXG4gIC8vIEluc3RydW1lbnQgd2l0aCBTdXNwZW5zZSBEZXZUb29scyAoZGV2LW9ubHkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICd1c2UnIGluIFJlYWN0KSB7XG4gICAgY29uc3QgbmF2aWdhdGlvblByb21pc2VzID0gdXNlKE5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQpXG4gICAgaWYgKG5hdmlnYXRpb25Qcm9taXNlcykge1xuICAgICAgcmV0dXJuIHVzZShuYXZpZ2F0aW9uUHJvbWlzZXMucGF0aG5hbWUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lXG59XG5cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IHtcbiAgU2VydmVySW5zZXJ0ZWRIVE1MQ29udGV4dCxcbiAgdXNlU2VydmVySW5zZXJ0ZWRIVE1MLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3NlcnZlci1pbnNlcnRlZC1odG1sLnNoYXJlZC1ydW50aW1lJ1xuXG4vKipcbiAqXG4gKiBUaGlzIGhvb2sgYWxsb3dzIHlvdSB0byBwcm9ncmFtbWF0aWNhbGx5IGNoYW5nZSByb3V0ZXMgaW5zaWRlIFtDbGllbnQgQ29tcG9uZW50XShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvY2xpZW50LWNvbXBvbmVudHMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICogIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gKiAgLy8gLi4uXG4gKiAgcm91dGVyLnB1c2goJy9kYXNoYm9hcmQnKSAvLyBOYXZpZ2F0ZSB0byAvZGFzaGJvYXJkXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1c2VSb3V0ZXJgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXJvdXRlcilcbiAqL1xuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IEFwcFJvdXRlckluc3RhbmNlIHtcbiAgY29uc3Qgcm91dGVyID0gdXNlQ29udGV4dChBcHBSb3V0ZXJDb250ZXh0KVxuICBpZiAocm91dGVyID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZXhwZWN0ZWQgYXBwIHJvdXRlciB0byBiZSBtb3VudGVkJylcbiAgfVxuXG4gIHJldHVybiByb3V0ZXJcbn1cblxuLyoqXG4gKiBBIFtDbGllbnQgQ29tcG9uZW50XShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvY2xpZW50LWNvbXBvbmVudHMpIGhvb2tcbiAqIHRoYXQgbGV0cyB5b3UgcmVhZCBhIHJvdXRlJ3MgZHluYW1pYyBwYXJhbXMgZmlsbGVkIGluIGJ5IHRoZSBjdXJyZW50IFVSTC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIFwidXNlIGNsaWVudFwiXG4gKiBpbXBvcnQgeyB1c2VQYXJhbXMgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFnZSgpIHtcbiAqICAgLy8gb24gL2Rhc2hib2FyZC9bdGVhbV0gd2hlcmUgcGF0aG5hbWUgaXMgL2Rhc2hib2FyZC9uZXh0anNcbiAqICAgY29uc3QgeyB0ZWFtIH0gPSB1c2VQYXJhbXMoKSAvLyB0ZWFtID09PSBcIm5leHRqc1wiXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1c2VQYXJhbXNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXBhcmFtcylcbiAqL1xuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFyYW1zPFQgZXh0ZW5kcyBQYXJhbXMgPSBQYXJhbXM+KCk6IFQge1xuICB1c2VEeW5hbWljUm91dGVQYXJhbXM/LigndXNlUGFyYW1zKCknKVxuXG4gIGNvbnN0IHBhcmFtcyA9IHVzZUNvbnRleHQoUGF0aFBhcmFtc0NvbnRleHQpIGFzIFRcblxuICAvLyBJbnN0cnVtZW50IHdpdGggU3VzcGVuc2UgRGV2VG9vbHMgKGRldi1vbmx5KVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAndXNlJyBpbiBSZWFjdCkge1xuICAgIGNvbnN0IG5hdmlnYXRpb25Qcm9taXNlcyA9IHVzZShOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0KVxuICAgIGlmIChuYXZpZ2F0aW9uUHJvbWlzZXMpIHtcbiAgICAgIHJldHVybiB1c2UobmF2aWdhdGlvblByb21pc2VzLnBhcmFtcykgYXMgVFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJhbXNcbn1cblxuLyoqXG4gKiBBIFtDbGllbnQgQ29tcG9uZW50XShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvY2xpZW50LWNvbXBvbmVudHMpIGhvb2tcbiAqIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgYWN0aXZlIHJvdXRlIHNlZ21lbnRzICoqYmVsb3cqKiB0aGUgTGF5b3V0IGl0IGlzIGNhbGxlZCBmcm9tLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogJ3VzZSBjbGllbnQnXG4gKlxuICogaW1wb3J0IHsgdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFeGFtcGxlQ2xpZW50Q29tcG9uZW50KCkge1xuICogICBjb25zdCBzZWdtZW50cyA9IHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHMoKVxuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8dWw+XG4gKiAgICAgICB7c2VnbWVudHMubWFwKChzZWdtZW50LCBpbmRleCkgPT4gKFxuICogICAgICAgICA8bGkga2V5PXtpbmRleH0+e3NlZ21lbnR9PC9saT5cbiAqICAgICAgICkpfVxuICogICAgIDwvdWw+XG4gKiAgIClcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXNlbGVjdGVkLWxheW91dC1zZWdtZW50cylcbiAqL1xuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyhcbiAgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gJ2NoaWxkcmVuJ1xuKTogc3RyaW5nW10ge1xuICB1c2VEeW5hbWljUm91dGVQYXJhbXM/LigndXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cygpJylcblxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChMYXlvdXRSb3V0ZXJDb250ZXh0KVxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgb25seSBoYXBwZW5zIGluIGBwYWdlc2AuIFR5cGUgaXMgb3ZlcndyaXR0ZW4gaW4gbmF2aWdhdGlvbi5kLnRzXG4gIGlmICghY29udGV4dCkgcmV0dXJuIG51bGxcblxuICAvLyBJbnN0cnVtZW50IHdpdGggU3VzcGVuc2UgRGV2VG9vbHMgKGRldi1vbmx5KVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAndXNlJyBpbiBSZWFjdCkge1xuICAgIGNvbnN0IG5hdmlnYXRpb25Qcm9taXNlcyA9IHVzZShOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0KVxuICAgIGlmIChuYXZpZ2F0aW9uUHJvbWlzZXMpIHtcbiAgICAgIGNvbnN0IHByb21pc2UgPVxuICAgICAgICBuYXZpZ2F0aW9uUHJvbWlzZXMuc2VsZWN0ZWRMYXlvdXRTZWdtZW50c1Byb21pc2VzPy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgaGF2ZSBhIHByb21pc2UgaGVyZSwgYnV0IGlmIHdlIGRvbid0LCBpdCdzIG5vdCB3b3J0aCBlcnJvcmluZyBvdmVyLlxuICAgICAgICAvLyBXZSBqdXN0IHdvbid0IGJlIGFibGUgdG8gaW5zdHJ1bWVudCBpdCwgYnV0IGNhbiBzdGlsbCBwcm92aWRlIHRoZSB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIHVzZShwcm9taXNlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoKGNvbnRleHQucGFyZW50VHJlZSwgcGFyYWxsZWxSb3V0ZUtleSlcbn1cblxuLyoqXG4gKiBBIFtDbGllbnQgQ29tcG9uZW50XShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvY2xpZW50LWNvbXBvbmVudHMpIGhvb2tcbiAqIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgYWN0aXZlIHJvdXRlIHNlZ21lbnQgKipvbmUgbGV2ZWwgYmVsb3cqKiB0aGUgTGF5b3V0IGl0IGlzIGNhbGxlZCBmcm9tLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogJ3VzZSBjbGllbnQnXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RlZExheW91dFNlZ21lbnQgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXhhbXBsZUNsaWVudENvbXBvbmVudCgpIHtcbiAqICAgY29uc3Qgc2VnbWVudCA9IHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudCgpXG4gKlxuICogICByZXR1cm4gPHA+QWN0aXZlIHNlZ21lbnQ6IHtzZWdtZW50fTwvcD5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VsZWN0ZWQtbGF5b3V0LXNlZ21lbnQpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudChcbiAgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gJ2NoaWxkcmVuJ1xuKTogc3RyaW5nIHwgbnVsbCB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VTZWxlY3RlZExheW91dFNlZ21lbnQoKScpXG4gIGNvbnN0IG5hdmlnYXRpb25Qcm9taXNlcyA9IHVzZUNvbnRleHQoTmF2aWdhdGlvblByb21pc2VzQ29udGV4dClcbiAgY29uc3Qgc2VsZWN0ZWRMYXlvdXRTZWdtZW50cyA9IHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHMocGFyYWxsZWxSb3V0ZUtleSlcblxuICAvLyBJbnN0cnVtZW50IHdpdGggU3VzcGVuc2UgRGV2VG9vbHMgKGRldi1vbmx5KVxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIG5hdmlnYXRpb25Qcm9taXNlcyAmJlxuICAgICd1c2UnIGluIFJlYWN0XG4gICkge1xuICAgIGNvbnN0IHByb21pc2UgPVxuICAgICAgbmF2aWdhdGlvblByb21pc2VzLnNlbGVjdGVkTGF5b3V0U2VnbWVudFByb21pc2VzPy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICBpZiAocHJvbWlzZSkge1xuICAgICAgLy8gV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgcHJvbWlzZSBoZXJlLCBidXQgaWYgd2UgZG9uJ3QsIGl0J3Mgbm90IHdvcnRoIGVycm9yaW5nIG92ZXIuXG4gICAgICAvLyBXZSBqdXN0IHdvbid0IGJlIGFibGUgdG8gaW5zdHJ1bWVudCBpdCwgYnV0IGNhbiBzdGlsbCBwcm92aWRlIHRoZSB2YWx1ZS5cbiAgICAgIHJldHVybiB1c2UocHJvbWlzZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tcHV0ZVNlbGVjdGVkTGF5b3V0U2VnbWVudChzZWxlY3RlZExheW91dFNlZ21lbnRzLCBwYXJhbGxlbFJvdXRlS2V5KVxufVxuXG5leHBvcnQgeyB1bnN0YWJsZV9pc1VucmVjb2duaXplZEFjdGlvbkVycm9yIH0gZnJvbSAnLi91bnJlY29nbml6ZWQtYWN0aW9uLWVycm9yJ1xuXG4vLyBTaGFyZWQgY29tcG9uZW50cyBBUElzXG5leHBvcnQge1xuICAvLyBXZSBuZWVkIHRoZSBzYW1lIGNsYXNzIHRoYXQgd2FzIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIGNvbnRleHQgdmFsdWVcbiAgLy8gT3RoZXJ3aXNlIGluc3RhbmNlb2YgY2hlY2tzIHdpbGwgZmFpbCBpbiB1c2VyY29kZVxuICBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyxcbn1cbmV4cG9ydCB7XG4gIG5vdEZvdW5kLFxuICBmb3JiaWRkZW4sXG4gIHVuYXV0aG9yaXplZCxcbiAgcmVkaXJlY3QsXG4gIHBlcm1hbmVudFJlZGlyZWN0LFxuICBSZWRpcmVjdFR5cGUsXG4gIHVuc3RhYmxlX3JldGhyb3csXG59IGZyb20gJy4vbmF2aWdhdGlvbi5yZWFjdC1zZXJ2ZXInXG4iXSwibmFtZXMiOlsiUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMiLCJSZWRpcmVjdFR5cGUiLCJTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0IiwiZm9yYmlkZGVuIiwibm90Rm91bmQiLCJwZXJtYW5lbnRSZWRpcmVjdCIsInJlZGlyZWN0IiwidW5hdXRob3JpemVkIiwidW5zdGFibGVfaXNVbnJlY29nbml6ZWRBY3Rpb25FcnJvciIsInVuc3RhYmxlX3JldGhyb3ciLCJ1c2VQYXJhbXMiLCJ1c2VQYXRobmFtZSIsInVzZVJvdXRlciIsInVzZVNlYXJjaFBhcmFtcyIsInVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudCIsInVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHMiLCJ1c2VTZXJ2ZXJJbnNlcnRlZEhUTUwiLCJ1c2VEeW5hbWljUm91dGVQYXJhbXMiLCJ3aW5kb3ciLCJyZXF1aXJlIiwidW5kZWZpbmVkIiwidXNlRHluYW1pY1NlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInVzZUNvbnRleHQiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwicmVhZG9ubHlTZWFyY2hQYXJhbXMiLCJ1c2VNZW1vIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiUmVhY3QiLCJuYXZpZ2F0aW9uUHJvbWlzZXMiLCJ1c2UiLCJOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0IiwicGF0aG5hbWUiLCJQYXRobmFtZUNvbnRleHQiLCJyb3V0ZXIiLCJBcHBSb3V0ZXJDb250ZXh0IiwiRXJyb3IiLCJwYXJhbXMiLCJQYXRoUGFyYW1zQ29udGV4dCIsInBhcmFsbGVsUm91dGVLZXkiLCJjb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsInByb21pc2UiLCJzZWxlY3RlZExheW91dFNlZ21lbnRzUHJvbWlzZXMiLCJnZXQiLCJnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoIiwicGFyZW50VHJlZSIsInNlbGVjdGVkTGF5b3V0U2VnbWVudHMiLCJzZWxlY3RlZExheW91dFNlZ21lbnRQcm9taXNlcyIsImNvbXB1dGVTZWxlY3RlZExheW91dFNlZ21lbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    }\n});\nconst _client = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-headers.js\");\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ \"(app-pages-browser)/../node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../app-find-source-map-url */ \"(app-pages-browser)/../node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/../node_modules/next/dist/client/flight-data-helpers.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(app-pages-browser)/../node_modules/next/dist/client/app-build-id.js\");\nconst _setcachebustingsearchparam = __webpack_require__(/*! ./set-cache-busting-search-param */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\");\nconst _routeparams = __webpack_require__(/*! ../../route-params */ \"(app-pages-browser)/../node_modules/next/dist/client/route-params.js\");\nconst _deploymentid = __webpack_require__(/*! ../../../shared/lib/deployment-id */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/deployment-id.js\");\nconst createFromReadableStream = _client.createFromReadableStream;\nconst createFromFetch = _client.createFromFetch;\nlet createDebugChannel;\nif (false) {}\nfunction doMpaNavigation(url) {\n    return (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(url, location.origin)).toString();\n}\nlet isPageUnloading = false;\nif (true) {\n    // Track when the page is unloading, e.g. due to reloading the page or\n    // performing hard navigations. This allows us to suppress error logging when\n    // the browser cancels in-flight requests during page unload.\n    window.addEventListener('pagehide', ()=>{\n        isPageUnloading = true;\n    });\n    // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n    // execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        isPageUnloading = false;\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)\n    };\n    if ( true && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    // In static export mode, we need to modify the URL to request the .txt file,\n    // but we should preserve the original URL for the canonical URL and error handling.\n    const originalUrl = url;\n    try {\n        if (false) {}\n        // Typically, during a navigation, we decode the response using Flight's\n        // `createFromFetch` API, which accepts a `fetch` promise.\n        // TODO: Remove this check once the old PPR flag is removed\n        const isLegacyPPR =  false && 0;\n        const shouldImmediatelyDecode = !isLegacyPPR;\n        const res = await createFetch(url, headers, 'auto', shouldImmediatelyDecode);\n        const responseUrl = (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(res.url));\n        const canonicalUrl = res.redirected ? responseUrl : originalUrl;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!res.headers.get('vary')?.includes(_approuterheaders.NEXT_URL);\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        // TODO: This needs to happen in the Flight Client.\n        // Or Webpack needs to include the runtime update in the Flight response as\n        // a blocking script.\n        if (true) {\n            await (__webpack_require__(/*! ../../dev/hot-reloader/app/hot-reloader-app */ \"(app-pages-browser)/../node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js\").waitForWebpackRuntimeHotUpdate)();\n        }\n        let flightResponsePromise = res.flightResponse;\n        if (flightResponsePromise === null) {\n            // Typically, `createFetch` would have already started decoding the\n            // Flight response. If it hasn't, though, we need to decode it now.\n            // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n            // without Cache Components). Remove this branch once legacy PPR\n            // is deleted.\n            const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n            flightResponsePromise = createFromNextReadableStream(flightStream, headers);\n        }\n        const flightResponse = await flightResponsePromise;\n        if ((0, _appbuildid.getAppBuildId)() !== flightResponse.b) {\n            return doMpaNavigation(res.url);\n        }\n        const normalizedFlightData = (0, _flightdatahelpers.normalizeFlightData)(flightResponse.f);\n        if (typeof normalizedFlightData === 'string') {\n            return doMpaNavigation(normalizedFlightData);\n        }\n        return {\n            flightData: normalizedFlightData,\n            canonicalUrl: canonicalUrl,\n            renderedSearch: (0, _routeparams.getRenderedSearch)(res),\n            couldBeIntercepted: interception,\n            prerendered: flightResponse.S,\n            postponed,\n            staleTime,\n            debugInfo: flightResponsePromise._debugInfo ?? null\n        };\n    } catch (err) {\n        if (!isPageUnloading) {\n            console.error(`Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`, err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return originalUrl.toString();\n    }\n}\nasync function createFetch(url, headers, fetchPriority, shouldImmediatelyDecode, signal) {\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    if (false) {}\n    const deploymentId = (0, _deploymentid.getDeploymentId)();\n    if (deploymentId) {\n        headers['x-deployment-id'] = deploymentId;\n    }\n    if (true) {\n        if (self.__next_r) {\n            headers[_approuterheaders.NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[_approuterheaders.NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const fetchOptions = {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    };\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\n    // search param to it. This should not leak outside of this function, so we\n    // track them separately.\n    let fetchUrl = new URL(url);\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    let fetchPromise = fetch(fetchUrl, fetchOptions);\n    // Immediately pass the fetch promise to the Flight client so that the debug\n    // info includes the latency from the client to the server. The internal timer\n    // in React starts as soon as `createFromFetch` is called.\n    //\n    // The only case where we don't do this is during a prefetch, because we have\n    // to do some extra processing of the response stream (see\n    // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n    // prefetch response never blocks a navigation; if it hasn't already been\n    // written into the cache by the time the navigation happens, the router will\n    // go straight to a dynamic request.\n    let flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\n    let browserResponse = await fetchPromise;\n    // If the server responds with a redirect (e.g. 307), and the redirected\n    // location does not contain the cache busting search param set in the\n    // original request, the response is likely invalid  when following the\n    // redirect, the browser forwards the request headers, but since the cache\n    // busting search param is missing, the server will reject the request due to\n    // a mismatch.\n    //\n    // Ideally, we would be able to intercept the redirect response and perform it\n    // manually, instead of letting the browser automatically follow it, but this\n    // is not allowed by the fetch API.\n    //\n    // So instead, we must \"replay\" the redirect by fetching the new location\n    // again, but this time we'll append the cache busting search param to prevent\n    // a mismatch.\n    //\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n    // custom status code, to prevent the browser from automatically following it.\n    //\n    // This does not affect Server Action-based redirects; those are encoded\n    // differently, as part of the Flight body. It only affects redirects that\n    // occur in a middleware or a third-party proxy.\n    let redirected = browserResponse.redirected;\n    if (false) {}\n    // Remove the cache busting search param from the response URL, to prevent it\n    // from leaking outside of this function.\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\n    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    const rscResponse = {\n        url: responseUrl.href,\n        // This is true if any redirects occurred, either automatically by the\n        // browser, or manually by us. So it's different from\n        // `browserResponse.redirected`, which only tells us whether the browser\n        // followed a redirect, and only for the last response in the chain.\n        redirected,\n        // These can be copied from the last browser response we received. We\n        // intentionally only expose the subset of fields that are actually used\n        // elsewhere in the codebase.\n        ok: browserResponse.ok,\n        headers: browserResponse.headers,\n        body: browserResponse.body,\n        status: browserResponse.status,\n        // This is the exact promise returned by `createFromFetch`. It contains\n        // debug information that we need to transfer to any derived promises that\n        // are later rendered by React.\n        flightResponse: flightResponsePromise\n    };\n    return rscResponse;\n}\nfunction createFromNextReadableStream(flightStream, requestHeaders) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createFromNextFetch(promiseForResponse, requestHeaders) {\n    return createFromFetch(promiseForResponse, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF1U3NCQSxXQUFXO2VBQVhBOztJQTRKTkMsNEJBQTRCO2VBQTVCQTs7SUF2VU1DLG1CQUFtQjtlQUFuQkE7OztvQ0FySGY7OENBb0JBOzJDQUNvQjtpREFDTTsrQ0FLMUI7d0NBQ3VCO3dEQUNhO3lDQUlwQzswQ0FFeUI7QUFFaEMsTUFBTUMsMkJBQ0pDLFFBQUFBLHdCQUErQjtBQUNqQyxNQUFNQyxrQkFDSkMsUUFBQUEsZUFBc0I7QUFFeEIsSUFBSUM7QUFJSixJQUNFQyxLQUNzQyxFQUN0QyxFQUlEO0FBdUNELFNBQVNLLGdCQUFnQkMsR0FBVztJQUNsQyxPQUFPQyxDQUFBQSxHQUFBQSxhQUFBQSwyQkFBQUEsRUFBNEIsSUFBSUMsSUFBSUYsS0FBS0csU0FBU0MsTUFBTSxHQUFHQyxRQUFRO0FBQzVFO0FBRUEsSUFBSUMsa0JBQWtCO0FBRXRCLElBQUksSUFBNkIsRUFBRTtJQUNqQyxzRUFBc0U7SUFDdEUsNkVBQTZFO0lBQzdFLDZEQUE2RDtJQUM3REMsT0FBT0MsZ0JBQWdCLENBQUMsWUFBWTtRQUNsQ0Ysa0JBQWtCO0lBQ3BCO0lBRUEsMkVBQTJFO0lBQzNFLGdEQUFnRDtJQUNoREMsT0FBT0MsZ0JBQWdCLENBQUMsWUFBWTtRQUNsQ0Ysa0JBQWtCO0lBQ3BCO0FBQ0Y7QUFNTyxlQUFlbEIsb0JBQ3BCWSxHQUFRLEVBQ1JTLE9BQW1DO0lBRW5DLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUVDLE9BQU8sRUFBRSxHQUFHRjtJQUV2QyxNQUFNRyxVQUEwQjtRQUM5Qix5QkFBeUI7UUFDekIsQ0FBQ0Msa0JBQUFBLFVBQVUsQ0FBQyxFQUFFO1FBQ2QsbUNBQW1DO1FBQ25DLENBQUNDLGtCQUFBQSw2QkFBNkIsQ0FBQyxFQUFFQyxD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QUFLLEVBQUUsR0FBRyxNQUFNTixPQUFPTyxJQUFJO2dCQUN6QyxJQUFJLENBQUNGLE1BQU07b0JBQ1QsbUVBQW1FO29CQUNuRSxtQkFBbUI7b0JBQ25CRCxXQUFXSSxPQUFPLENBQUNGO29CQUNuQjtnQkFDRjtnQkFDQSxxRUFBcUU7Z0JBQ3JFLHFCQUFxQjtnQkFDckI7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIFRPRE86IEV4cGxpY2l0bHkgaW1wb3J0IGZyb20gY2xpZW50LmJyb3dzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB7XG4gIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSBhcyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyLFxuICBjcmVhdGVGcm9tRmV0Y2ggYXMgY3JlYXRlRnJvbUZldGNoQnJvd3Nlcixcbn0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcblxuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgTmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItdHlwZXMnXG5cbmltcG9ydCB7XG4gIHR5cGUgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICB0eXBlIE5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUixcbiAgTkVYVF9SU0NfVU5JT05fUVVFUlksXG4gIE5FWFRfVVJMLFxuICBSU0NfSEVBREVSLFxuICBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIsXG4gIE5FWFRfRElEX1BPU1RQT05FX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIsXG4gIE5FWFRfSFRNTF9SRVFVRVNUX0lEX0hFQURFUixcbiAgTkVYVF9SRVFVRVNUX0lEX0hFQURFUixcbn0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHsgY2FsbFNlcnZlciB9IGZyb20gJy4uLy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuLi8uLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUZsaWdodERhdGEsXG4gIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QsXG4gIHR5cGUgTm9ybWFsaXplZEZsaWdodERhdGEsXG59IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBnZXRBcHBCdWlsZElkIH0gZnJvbSAnLi4vLi4vYXBwLWJ1aWxkLWlkJ1xuaW1wb3J0IHsgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0gfSBmcm9tICcuL3NldC1jYWNoZS1idXN0aW5nLXNlYXJjaC1wYXJhbSdcbmltcG9ydCB7XG4gIGdldFJlbmRlcmVkU2VhcmNoLFxuICB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIsXG59IGZyb20gJy4uLy4uL3JvdXRlLXBhcmFtcydcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZFNlYXJjaCB9IGZyb20gJy4uL3NlZ21lbnQtY2FjaGUvY2FjaGUta2V5J1xuaW1wb3J0IHsgZ2V0RGVwbG95bWVudElkIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9kZXBsb3ltZW50LWlkJ1xuXG5jb25zdCBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gPVxuICBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIGFzICh0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmJyb3dzZXInKSlbJ2NyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSddXG5jb25zdCBjcmVhdGVGcm9tRmV0Y2ggPVxuICBjcmVhdGVGcm9tRmV0Y2hCcm93c2VyIGFzICh0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmJyb3dzZXInKSlbJ2NyZWF0ZUZyb21GZXRjaCddXG5cbmxldCBjcmVhdGVEZWJ1Z0NoYW5uZWw6XG4gIHwgdHlwZW9mIGltcG9ydCgnLi4vLi4vZGV2L2RlYnVnLWNoYW5uZWwnKS5jcmVhdGVEZWJ1Z0NoYW5uZWxcbiAgfCB1bmRlZmluZWRcblxuaWYgKFxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ERUJVR19DSEFOTkVMXG4pIHtcbiAgY3JlYXRlRGVidWdDaGFubmVsID0gKFxuICAgIHJlcXVpcmUoJy4uLy4uL2Rldi9kZWJ1Zy1jaGFubmVsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vZGV2L2RlYnVnLWNoYW5uZWwnKVxuICApLmNyZWF0ZURlYnVnQ2hhbm5lbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoU2VydmVyUmVzcG9uc2VPcHRpb25zIHtcbiAgcmVhZG9ubHkgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4gIHJlYWRvbmx5IG5leHRVcmw6IHN0cmluZyB8IG51bGxcbiAgcmVhZG9ubHkgaXNIbXJSZWZyZXNoPzogYm9vbGVhblxufVxuXG50eXBlIFNwYUZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQgPSB7XG4gIGZsaWdodERhdGE6IE5vcm1hbGl6ZWRGbGlnaHREYXRhW11cbiAgY2Fub25pY2FsVXJsOiBVUkxcbiAgcmVuZGVyZWRTZWFyY2g6IE5vcm1hbGl6ZWRTZWFyY2hcbiAgY291bGRCZUludGVyY2VwdGVkOiBib29sZWFuXG4gIHByZXJlbmRlcmVkOiBib29sZWFuXG4gIHBvc3Rwb25lZDogYm9vbGVhblxuICBzdGFsZVRpbWU6IG51bWJlclxuICBkZWJ1Z0luZm86IEFycmF5PGFueT4gfCBudWxsXG59XG5cbnR5cGUgTXBhRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCA9IHN0cmluZ1xuXG5leHBvcnQgdHlwZSBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0ID1cbiAgfCBNcGFGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0XG4gIHwgU3BhRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxuXG5leHBvcnQgdHlwZSBSZXF1ZXN0SGVhZGVycyA9IHtcbiAgW1JTQ19IRUFERVJdPzogJzEnXG4gIFtORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl0/OiBzdHJpbmdcbiAgW05FWFRfVVJMXT86IHN0cmluZ1xuICBbTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSXT86ICcxJyB8ICcyJ1xuICBbTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVJdPzogc3RyaW5nXG4gICd4LWRlcGxveW1lbnQtaWQnPzogc3RyaW5nXG4gIFtORVhUX0hNUl9SRUZSRVNIX0hFQURFUl0/OiAnMSdcbiAgLy8gQSBoZWFkZXIgdGhhdCBpcyBvbmx5IGFkZGVkIGluIHRlc3QgbW9kZSB0byBhc3NlcnQgb24gZmV0Y2ggcHJpb3JpdHlcbiAgJ05leHQtVGVzdC1GZXRjaC1Qcmlvcml0eSc/OiBSZXF1ZXN0SW5pdFsncHJpb3JpdHknXVxuICBbTkVYVF9IVE1MX1JFUVVFU1RfSURfSEVBREVSXT86IHN0cmluZyAvLyBkZXYtb25seVxuICBbTkVYVF9SRVFVRVNUX0lEX0hFQURFUl0/OiBzdHJpbmcgLy8gZGV2LW9ubHlcbn1cblxuZnVuY3Rpb24gZG9NcGFOYXZpZ2F0aW9uKHVybDogc3RyaW5nKTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB7XG4gIHJldHVybiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIobmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbikpLnRvU3RyaW5nKClcbn1cblxubGV0IGlzUGFnZVVubG9hZGluZyA9IGZhbHNlXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBUcmFjayB3aGVuIHRoZSBwYWdlIGlzIHVubG9hZGluZywgZS5nLiBkdWUgdG8gcmVsb2FkaW5nIHRoZSBwYWdlIG9yXG4gIC8vIHBlcmZvcm1pbmcgaGFyZCBuYXZpZ2F0aW9ucy4gVGhpcyBhbGxvd3MgdXMgdG8gc3VwcHJlc3MgZXJyb3IgbG9nZ2luZyB3aGVuXG4gIC8vIHRoZSBicm93c2VyIGNhbmNlbHMgaW4tZmxpZ2h0IHJlcXVlc3RzIGR1cmluZyBwYWdlIHVubG9hZC5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgKCkgPT4ge1xuICAgIGlzUGFnZVVubG9hZGluZyA9IHRydWVcbiAgfSlcblxuICAvLyBSZXNldCB0aGUgZmxhZyBvbiBwYWdlc2hvdywgZS5nLiB3aGVuIG5hdmlnYXRpbmcgYmFjayBhbmQgdGhlIEphdmFTY3JpcHRcbiAgLy8gZXhlY3V0aW9uIGNvbnRleHQgaXMgcmVzdG9yZWQgYnkgdGhlIGJyb3dzZXIuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsICgpID0+IHtcbiAgICBpc1BhZ2VVbmxvYWRpbmcgPSBmYWxzZVxuICB9KVxufVxuXG4vKipcbiAqIEZldGNoIHRoZSBmbGlnaHQgZGF0YSBmb3IgdGhlIHByb3ZpZGVkIHVybC4gVGFrZXMgaW4gdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gKiB0byBkZWNpZGUgd2hhdCB0byByZW5kZXIgc2VydmVyLXNpZGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZlclJlc3BvbnNlKFxuICB1cmw6IFVSTCxcbiAgb3B0aW9uczogRmV0Y2hTZXJ2ZXJSZXNwb25zZU9wdGlvbnNcbik6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD4ge1xuICBjb25zdCB7IGZsaWdodFJvdXRlclN0YXRlLCBuZXh0VXJsIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgLy8gRW5hYmxlIGZsaWdodCByZXNwb25zZVxuICAgIFtSU0NfSEVBREVSXTogJzEnLFxuICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTogcHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdChcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlLFxuICAgICAgb3B0aW9ucy5pc0htclJlZnJlc2hcbiAgICApLFxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIG9wdGlvbnMuaXNIbXJSZWZyZXNoKSB7XG4gICAgaGVhZGVyc1tORVhUX0hNUl9SRUZSRVNIX0hFQURFUl0gPSAnMSdcbiAgfVxuXG4gIGlmIChuZXh0VXJsKSB7XG4gICAgaGVhZGVyc1tORVhUX1VSTF0gPSBuZXh0VXJsXG4gIH1cblxuICAvLyBJbiBzdGF0aWMgZXhwb3J0IG1vZGUsIHdlIG5lZWQgdG8gbW9kaWZ5IHRoZSBVUkwgdG8gcmVxdWVzdCB0aGUgLnR4dCBmaWxlLFxuICAvLyBidXQgd2Ugc2hvdWxkIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBVUkwgZm9yIHRoZSBjYW5vbmljYWwgVVJMIGFuZCBlcnJvciBoYW5kbGluZy5cbiAgY29uc3Qgb3JpZ2luYWxVcmwgPSB1cmxcblxuICB0cnkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIC8vIEluIFwib3V0cHV0OiBleHBvcnRcIiBtb2RlLCB3ZSBjYW4ndCByZWx5IG9uIGhlYWRlcnMgdG8gZGlzdGluZ3Vpc2hcbiAgICAgICAgLy8gYmV0d2VlbiBIVE1MIGFuZCBSU0MgcmVxdWVzdHMuIEluc3RlYWQsIHdlIGFwcGVuZCBhbiBleHRyYSBwcmVmaXhcbiAgICAgICAgLy8gdG8gdGhlIHJlcXVlc3QuXG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICB1cmwucGF0aG5hbWUgKz0gJ2luZGV4LnR4dCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwucGF0aG5hbWUgKz0gJy50eHQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBpY2FsbHksIGR1cmluZyBhIG5hdmlnYXRpb24sIHdlIGRlY29kZSB0aGUgcmVzcG9uc2UgdXNpbmcgRmxpZ2h0J3NcbiAgICAvLyBgY3JlYXRlRnJvbUZldGNoYCBBUEksIHdoaWNoIGFjY2VwdHMgYSBgZmV0Y2hgIHByb21pc2UuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgY2hlY2sgb25jZSB0aGUgb2xkIFBQUiBmbGFnIGlzIHJlbW92ZWRcbiAgICBjb25zdCBpc0xlZ2FjeVBQUiA9XG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfUFBSICYmICFwcm9jZXNzLmVudi5fX05FWFRfQ0FDSEVfQ09NUE9ORU5UU1xuICAgIGNvbnN0IHNob3VsZEltbWVkaWF0ZWx5RGVjb2RlID0gIWlzTGVnYWN5UFBSXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3JlYXRlRmV0Y2g8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPihcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICAnYXV0bycsXG4gICAgICBzaG91bGRJbW1lZGlhdGVseURlY29kZVxuICAgIClcblxuICAgIGNvbnN0IHJlc3BvbnNlVXJsID0gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKG5ldyBVUkwocmVzLnVybCkpXG4gICAgY29uc3QgY2Fub25pY2FsVXJsID0gcmVzLnJlZGlyZWN0ZWQgPyByZXNwb25zZVVybCA6IG9yaWdpbmFsVXJsXG5cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJydcbiAgICBjb25zdCBpbnRlcmNlcHRpb24gPSAhIXJlcy5oZWFkZXJzLmdldCgndmFyeScpPy5pbmNsdWRlcyhORVhUX1VSTClcbiAgICBjb25zdCBwb3N0cG9uZWQgPSAhIXJlcy5oZWFkZXJzLmdldChORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIpXG4gICAgY29uc3Qgc3RhbGVUaW1lSGVhZGVyU2Vjb25kcyA9IHJlcy5oZWFkZXJzLmdldChcbiAgICAgIE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSXG4gICAgKVxuICAgIGNvbnN0IHN0YWxlVGltZSA9XG4gICAgICBzdGFsZVRpbWVIZWFkZXJTZWNvbmRzICE9PSBudWxsXG4gICAgICAgID8gcGFyc2VJbnQoc3RhbGVUaW1lSGVhZGVyU2Vjb25kcywgMTApICogMTAwMFxuICAgICAgICA6IC0xXG4gICAgbGV0IGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKFJTQ19DT05URU5UX1RZUEVfSEVBREVSKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvcGxhaW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggcmV0dXJucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZmxpZ2h0IHJlc3BvbnNlIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBJZiB0aGUgZmV0Y2ggd2FzIG5vdCAyMDAsIHdlIGFsc28gaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSB8fCAhcmVzLm9rIHx8ICFyZXMuYm9keSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3JpZ2luYWwgVVJMIGNhbWUgd2l0aCBhIGhhc2gsIHByZXNlcnZlIGl0IGJlZm9yZSByZWRpcmVjdGluZyB0byB0aGUgbmV3IFVSTFxuICAgICAgaWYgKHVybC5oYXNoKSB7XG4gICAgICAgIHJlc3BvbnNlVXJsLmhhc2ggPSB1cmwuaGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlc3BvbnNlVXJsLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gV2UgbWF5IG5hdmlnYXRlIHRvIGEgcGFnZSB0aGF0IHJlcXVpcmVzIGEgZGlmZmVyZW50IFdlYnBhY2sgcnVudGltZS5cbiAgICAvLyBJbiBwcm9kLCBldmVyeSBwYWdlIHdpbGwgaGF2ZSB0aGUgc2FtZSBXZWJwYWNrIHJ1bnRpbWUuXG4gICAgLy8gSW4gZGV2LCB0aGUgV2VicGFjayBydW50aW1lIGlzIG1pbmltYWwgZm9yIGVhY2ggcGFnZS5cbiAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgV2VicGFjayBydW50aW1lIGlzIHVwZGF0ZWQgYmVmb3JlIGV4ZWN1dGluZyBjbGllbnQtc2lkZSBKUyBvZiB0aGUgbmV3IHBhZ2UuXG4gICAgLy8gVE9ETzogVGhpcyBuZWVkcyB0byBoYXBwZW4gaW4gdGhlIEZsaWdodCBDbGllbnQuXG4gICAgLy8gT3IgV2VicGFjayBuZWVkcyB0byBpbmNsdWRlIHRoZSBydW50aW1lIHVwZGF0ZSBpbiB0aGUgRmxpZ2h0IHJlc3BvbnNlIGFzXG4gICAgLy8gYSBibG9ja2luZyBzY3JpcHQuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgYXdhaXQgKFxuICAgICAgICByZXF1aXJlKCcuLi8uLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpXG4gICAgICApLndhaXRGb3JXZWJwYWNrUnVudGltZUhvdFVwZGF0ZSgpXG4gICAgfVxuXG4gICAgbGV0IGZsaWdodFJlc3BvbnNlUHJvbWlzZSA9IHJlcy5mbGlnaHRSZXNwb25zZVxuICAgIGlmIChmbGlnaHRSZXNwb25zZVByb21pc2UgPT09IG51bGwpIHtcbiAgICAgIC8vIFR5cGljYWxseSwgYGNyZWF0ZUZldGNoYCB3b3VsZCBoYXZlIGFscmVhZHkgc3RhcnRlZCBkZWNvZGluZyB0aGVcbiAgICAgIC8vIEZsaWdodCByZXNwb25zZS4gSWYgaXQgaGFzbid0LCB0aG91Z2gsIHdlIG5lZWQgdG8gZGVjb2RlIGl0IG5vdy5cbiAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG9ubHkgYmUgcmVhY2hhYmxlIGlmIGxlZ2FjeSBQUFIgaXMgZW5hYmxlZCAoaS5lLiBQUFJcbiAgICAgIC8vIHdpdGhvdXQgQ2FjaGUgQ29tcG9uZW50cykuIFJlbW92ZSB0aGlzIGJyYW5jaCBvbmNlIGxlZ2FjeSBQUFJcbiAgICAgIC8vIGlzIGRlbGV0ZWQuXG4gICAgICBjb25zdCBmbGlnaHRTdHJlYW0gPSBwb3N0cG9uZWRcbiAgICAgICAgPyBjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbShyZXMuYm9keSlcbiAgICAgICAgOiByZXMuYm9keVxuICAgICAgZmxpZ2h0UmVzcG9uc2VQcm9taXNlID1cbiAgICAgICAgY3JlYXRlRnJvbU5leHRSZWFkYWJsZVN0cmVhbTxOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2U+KFxuICAgICAgICAgIGZsaWdodFN0cmVhbSxcbiAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBmbGlnaHRSZXNwb25zZSA9IGF3YWl0IGZsaWdodFJlc3BvbnNlUHJvbWlzZVxuXG4gICAgaWYgKGdldEFwcEJ1aWxkSWQoKSAhPT0gZmxpZ2h0UmVzcG9uc2UuYikge1xuICAgICAgcmV0dXJuIGRvTXBhTmF2aWdhdGlvbihyZXMudXJsKVxuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhID0gbm9ybWFsaXplRmxpZ2h0RGF0YShmbGlnaHRSZXNwb25zZS5mKVxuICAgIGlmICh0eXBlb2Ygbm9ybWFsaXplZEZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKG5vcm1hbGl6ZWRGbGlnaHREYXRhKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmbGlnaHREYXRhOiBub3JtYWxpemVkRmxpZ2h0RGF0YSxcbiAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsLFxuICAgICAgcmVuZGVyZWRTZWFyY2g6IGdldFJlbmRlcmVkU2VhcmNoKHJlcyksXG4gICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGludGVyY2VwdGlvbixcbiAgICAgIHByZXJlbmRlcmVkOiBmbGlnaHRSZXNwb25zZS5TLFxuICAgICAgcG9zdHBvbmVkLFxuICAgICAgc3RhbGVUaW1lLFxuICAgICAgZGVidWdJbmZvOiBmbGlnaHRSZXNwb25zZVByb21pc2UuX2RlYnVnSW5mbyA/PyBudWxsLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCFpc1BhZ2VVbmxvYWRpbmcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggUlNDIHBheWxvYWQgZm9yICR7b3JpZ2luYWxVcmx9LiBGYWxsaW5nIGJhY2sgdG8gYnJvd3NlciBuYXZpZ2F0aW9uLmAsXG4gICAgICAgIGVyclxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIElmIGZldGNoIGZhaWxzIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBUT0RPLUFQUDogQWRkIGEgdGVzdCBmb3IgdGhlIGNhc2Ugd2hlcmUgYSBDT1JTIHJlcXVlc3QgZmFpbHMsIGUuZy4gZXh0ZXJuYWwgdXJsIHJlZGlyZWN0IGNvbWluZyBmcm9tIHRoZSByZXNwb25zZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy80MzYwNSNpc3N1ZWNvbW1lbnQtMTQ1MTYxNzUyMSBmb3IgYSByZXByb2R1Y3Rpb24uXG4gICAgcmV0dXJuIG9yaWdpbmFsVXJsLnRvU3RyaW5nKClcbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgc3Vic2V0IG9mIHRoZSBzdGFuZGFyZCBSZXNwb25zZSB0eXBlLiBXZSB1c2UgYSBjdXN0b20gdHlwZSBmb3Jcbi8vIHRoaXMgc28gd2UgY2FuIGxpbWl0IHdoaWNoIGRldGFpbHMgYWJvdXQgdGhlIHJlc3BvbnNlIGxlYWsgaW50byB0aGUgcmVzdCBvZlxuLy8gdGhlIGNvZGViYXNlLiBGb3IgZXhhbXBsZSwgdGhlcmUncyBzb21lIGN1c3RvbSBsb2dpYyBmb3IgbWFudWFsbHkgZm9sbG93aW5nXG4vLyByZWRpcmVjdHMsIHNvIFwicmVkaXJlY3RlZFwiIGluIHRoaXMgdHlwZSBjb3VsZCBiZSBhIGNvbXBvc2l0ZSBvZiBtdWx0aXBsZVxuLy8gYnJvd3NlciBmZXRjaCBjYWxsczsgaG93ZXZlciwgdGhpcyBmYWN0IHNob3VsZCBub3QgbGVhayB0byB0aGUgY2FsbGVyLlxuZXhwb3J0IHR5cGUgUlNDUmVzcG9uc2U8VD4gPSB7XG4gIG9rOiBib29sZWFuXG4gIHJlZGlyZWN0ZWQ6IGJvb2xlYW5cbiAgaGVhZGVyczogSGVhZGVyc1xuICBib2R5OiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB8IG51bGxcbiAgc3RhdHVzOiBudW1iZXJcbiAgdXJsOiBzdHJpbmdcbiAgZmxpZ2h0UmVzcG9uc2U6IChQcm9taXNlPFQ+ICYgeyBfZGVidWdJbmZvPzogQXJyYXk8YW55PiB9KSB8IG51bGxcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZldGNoPFQ+KFxuICB1cmw6IFVSTCxcbiAgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMsXG4gIGZldGNoUHJpb3JpdHk6ICdhdXRvJyB8ICdoaWdoJyB8ICdsb3cnIHwgbnVsbCxcbiAgc2hvdWxkSW1tZWRpYXRlbHlEZWNvZGU6IGJvb2xlYW4sXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4pOiBQcm9taXNlPFJTQ1Jlc3BvbnNlPFQ+PiB7XG4gIC8vIFRPRE86IEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB0aGUgaGVhZGVycyBkbyBub3RoaW5nLiBPbWl0IHRoZW0gKGFuZCB0aGVcbiAgLy8gY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0pIGZyb20gdGhlIHJlcXVlc3Qgc28gdGhleSdyZVxuICAvLyBtYXhpbWFsbHkgY2FjaGVhYmxlLlxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFICYmIGZldGNoUHJpb3JpdHkgIT09IG51bGwpIHtcbiAgICBoZWFkZXJzWydOZXh0LVRlc3QtRmV0Y2gtUHJpb3JpdHknXSA9IGZldGNoUHJpb3JpdHlcbiAgfVxuXG4gIGNvbnN0IGRlcGxveW1lbnRJZCA9IGdldERlcGxveW1lbnRJZCgpXG4gIGlmIChkZXBsb3ltZW50SWQpIHtcbiAgICBoZWFkZXJzWyd4LWRlcGxveW1lbnQtaWQnXSA9IGRlcGxveW1lbnRJZFxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoc2VsZi5fX25leHRfcikge1xuICAgICAgaGVhZGVyc1tORVhUX0hUTUxfUkVRVUVTVF9JRF9IRUFERVJdID0gc2VsZi5fX25leHRfclxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyByZXF1ZXN0IElEIGZvciB0aGUgc2VydmVyIGFjdGlvbiByZXF1ZXN0LiBUaGUgc2VydmVyIHVzZXNcbiAgICAvLyB0aGlzIHRvIHRhZyBkZWJ1ZyBpbmZvcm1hdGlvbiBzZW50IHZpYSBXZWJTb2NrZXQgdG8gdGhlIGNsaWVudCwgd2hpY2hcbiAgICAvLyB0aGVuIHJvdXRlcyB0aG9zZSBjaHVua3MgdG8gdGhlIGRlYnVnIGNoYW5uZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgSUQuXG4gICAgaGVhZGVyc1tORVhUX1JFUVVFU1RfSURfSEVBREVSXSA9IGNyeXB0b1xuICAgICAgLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdXG4gICAgICAudG9TdHJpbmcoMTYpXG4gIH1cblxuICBjb25zdCBmZXRjaE9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge1xuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIG9sZGVyIGJyb3dzZXJzLiBgc2FtZS1vcmlnaW5gIGlzIHRoZSBkZWZhdWx0IGluIG1vZGVybiBicm93c2Vycy5cbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBoZWFkZXJzLFxuICAgIHByaW9yaXR5OiBmZXRjaFByaW9yaXR5IHx8IHVuZGVmaW5lZCxcbiAgICBzaWduYWwsXG4gIH1cbiAgLy8gYGZldGNoVXJsYCBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSBgdXJsYCBiZWNhdXNlIHdlIGFkZCBhIGNhY2hlLWJ1c3RpbmdcbiAgLy8gc2VhcmNoIHBhcmFtIHRvIGl0LiBUaGlzIHNob3VsZCBub3QgbGVhayBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24sIHNvIHdlXG4gIC8vIHRyYWNrIHRoZW0gc2VwYXJhdGVseS5cbiAgbGV0IGZldGNoVXJsID0gbmV3IFVSTCh1cmwpXG4gIHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtKGZldGNoVXJsLCBoZWFkZXJzKVxuICBsZXQgZmV0Y2hQcm9taXNlID0gZmV0Y2goZmV0Y2hVcmwsIGZldGNoT3B0aW9ucylcbiAgLy8gSW1tZWRpYXRlbHkgcGFzcyB0aGUgZmV0Y2ggcHJvbWlzZSB0byB0aGUgRmxpZ2h0IGNsaWVudCBzbyB0aGF0IHRoZSBkZWJ1Z1xuICAvLyBpbmZvIGluY2x1ZGVzIHRoZSBsYXRlbmN5IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLiBUaGUgaW50ZXJuYWwgdGltZXJcbiAgLy8gaW4gUmVhY3Qgc3RhcnRzIGFzIHNvb24gYXMgYGNyZWF0ZUZyb21GZXRjaGAgaXMgY2FsbGVkLlxuICAvL1xuICAvLyBUaGUgb25seSBjYXNlIHdoZXJlIHdlIGRvbid0IGRvIHRoaXMgaXMgZHVyaW5nIGEgcHJlZmV0Y2gsIGJlY2F1c2Ugd2UgaGF2ZVxuICAvLyB0byBkbyBzb21lIGV4dHJhIHByb2Nlc3Npbmcgb2YgdGhlIHJlc3BvbnNlIHN0cmVhbSAoc2VlXG4gIC8vIGBjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbWApLiBCdXQgdGhpcyBpcyBmaW5lLCBiZWNhdXNlIGEgdG9wLWxldmVsXG4gIC8vIHByZWZldGNoIHJlc3BvbnNlIG5ldmVyIGJsb2NrcyBhIG5hdmlnYXRpb247IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW5cbiAgLy8gd3JpdHRlbiBpbnRvIHRoZSBjYWNoZSBieSB0aGUgdGltZSB0aGUgbmF2aWdhdGlvbiBoYXBwZW5zLCB0aGUgcm91dGVyIHdpbGxcbiAgLy8gZ28gc3RyYWlnaHQgdG8gYSBkeW5hbWljIHJlcXVlc3QuXG4gIGxldCBmbGlnaHRSZXNwb25zZVByb21pc2UgPSBzaG91bGRJbW1lZGlhdGVseURlY29kZVxuICAgID8gY3JlYXRlRnJvbU5leHRGZXRjaDxUPihmZXRjaFByb21pc2UsIGhlYWRlcnMpXG4gICAgOiBudWxsXG4gIGxldCBicm93c2VyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaFByb21pc2VcblxuICAvLyBJZiB0aGUgc2VydmVyIHJlc3BvbmRzIHdpdGggYSByZWRpcmVjdCAoZS5nLiAzMDcpLCBhbmQgdGhlIHJlZGlyZWN0ZWRcbiAgLy8gbG9jYXRpb24gZG9lcyBub3QgY29udGFpbiB0aGUgY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0gc2V0IGluIHRoZVxuICAvLyBvcmlnaW5hbCByZXF1ZXN0LCB0aGUgcmVzcG9uc2UgaXMgbGlrZWx5IGludmFsaWQg4oCUIHdoZW4gZm9sbG93aW5nIHRoZVxuICAvLyByZWRpcmVjdCwgdGhlIGJyb3dzZXIgZm9yd2FyZHMgdGhlIHJlcXVlc3QgaGVhZGVycywgYnV0IHNpbmNlIHRoZSBjYWNoZVxuICAvLyBidXN0aW5nIHNlYXJjaCBwYXJhbSBpcyBtaXNzaW5nLCB0aGUgc2VydmVyIHdpbGwgcmVqZWN0IHRoZSByZXF1ZXN0IGR1ZSB0b1xuICAvLyBhIG1pc21hdGNoLlxuICAvL1xuICAvLyBJZGVhbGx5LCB3ZSB3b3VsZCBiZSBhYmxlIHRvIGludGVyY2VwdCB0aGUgcmVkaXJlY3QgcmVzcG9uc2UgYW5kIHBlcmZvcm0gaXRcbiAgLy8gbWFudWFsbHksIGluc3RlYWQgb2YgbGV0dGluZyB0aGUgYnJvd3NlciBhdXRvbWF0aWNhbGx5IGZvbGxvdyBpdCwgYnV0IHRoaXNcbiAgLy8gaXMgbm90IGFsbG93ZWQgYnkgdGhlIGZldGNoIEFQSS5cbiAgLy9cbiAgLy8gU28gaW5zdGVhZCwgd2UgbXVzdCBcInJlcGxheVwiIHRoZSByZWRpcmVjdCBieSBmZXRjaGluZyB0aGUgbmV3IGxvY2F0aW9uXG4gIC8vIGFnYWluLCBidXQgdGhpcyB0aW1lIHdlJ2xsIGFwcGVuZCB0aGUgY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0gdG8gcHJldmVudFxuICAvLyBhIG1pc21hdGNoLlxuICAvL1xuICAvLyBUT0RPOiBXZSBjYW4gb3B0aW1pemUgTmV4dC5qcydzIGJ1aWx0LWluIG1pZGRsZXdhcmUgQVBJcyBieSByZXR1cm5pbmcgYVxuICAvLyBjdXN0b20gc3RhdHVzIGNvZGUsIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBhdXRvbWF0aWNhbGx5IGZvbGxvd2luZyBpdC5cbiAgLy9cbiAgLy8gVGhpcyBkb2VzIG5vdCBhZmZlY3QgU2VydmVyIEFjdGlvbi1iYXNlZCByZWRpcmVjdHM7IHRob3NlIGFyZSBlbmNvZGVkXG4gIC8vIGRpZmZlcmVudGx5LCBhcyBwYXJ0IG9mIHRoZSBGbGlnaHQgYm9keS4gSXQgb25seSBhZmZlY3RzIHJlZGlyZWN0cyB0aGF0XG4gIC8vIG9jY3VyIGluIGEgbWlkZGxld2FyZSBvciBhIHRoaXJkLXBhcnR5IHByb3h5LlxuXG4gIGxldCByZWRpcmVjdGVkID0gYnJvd3NlclJlc3BvbnNlLnJlZGlyZWN0ZWRcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfVkFMSURBVEVfUlNDX1JFUVVFU1RfSEVBREVSUykge1xuICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBhIHJlZGlyZWN0IGxvb3AuIFNhbWUgbGltaXQgdXNlZCBieSBDaHJvbWUuXG4gICAgY29uc3QgTUFYX1JFRElSRUNUUyA9IDIwXG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBNQVhfUkVESVJFQ1RTOyBuKyspIHtcbiAgICAgIGlmICghYnJvd3NlclJlc3BvbnNlLnJlZGlyZWN0ZWQpIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciBkaWQgbm90IHBlcmZvcm0gYSByZWRpcmVjdC5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlVXJsID0gbmV3IFVSTChicm93c2VyUmVzcG9uc2UudXJsLCBmZXRjaFVybClcbiAgICAgIGlmIChyZXNwb25zZVVybC5vcmlnaW4gIT09IGZldGNoVXJsLm9yaWdpbikge1xuICAgICAgICAvLyBUaGUgc2VydmVyIHJlZGlyZWN0ZWQgdG8gYW4gZXh0ZXJuYWwgVVJMLiBUaGUgcmVzdCBvZiB0aGUgbG9naWMgYmVsb3dcbiAgICAgICAgLy8gaXMgbm90IHJlbGV2YW50LCBiZWNhdXNlIGl0IG9ubHkgYXBwbGllcyB0byBpbnRlcm5hbCByZWRpcmVjdHMuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHJlc3BvbnNlVXJsLnNlYXJjaFBhcmFtcy5nZXQoTkVYVF9SU0NfVU5JT05fUVVFUlkpID09PVxuICAgICAgICBmZXRjaFVybC5zZWFyY2hQYXJhbXMuZ2V0KE5FWFRfUlNDX1VOSU9OX1FVRVJZKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFRoZSByZWRpcmVjdGVkIFVSTCBhbHJlYWR5IGluY2x1ZGVzIHRoZSBjYWNoZSBidXN0aW5nIHNlYXJjaCBwYXJhbS5cbiAgICAgICAgLy8gVGhpcyB3YXMgcHJvYmFibHkgaW50ZW50aW9uYWwuIFJlZ2FyZGxlc3MsIHRoZXJlJ3Mgbm8gcmVhc29uIHRvXG4gICAgICAgIC8vIGlzc3VlIGFub3RoZXIgcmVxdWVzdCB0byB0aGlzIFVSTCBiZWNhdXNlIGl0IGFscmVhZHkgaGFzIHRoZSBwYXJhbVxuICAgICAgICAvLyB2YWx1ZSB0aGF0IHdlIHdvdWxkIGhhdmUgYWRkZWQgYmVsb3cuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICAvLyBUaGUgUlNDIHJlcXVlc3Qgd2FzIHJlZGlyZWN0ZWQuIEFzc3VtZSB0aGUgcmVzcG9uc2UgaXMgaW52YWxpZC5cbiAgICAgIC8vXG4gICAgICAvLyBBcHBlbmQgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIHRvIHRoZSByZWRpcmVjdGVkIFVSTCBhbmRcbiAgICAgIC8vIGZldGNoIGFnYWluLlxuICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGFib3J0IHRoZSBwcmV2aW91cyByZXF1ZXN0LlxuICAgICAgZmV0Y2hVcmwgPSBuZXcgVVJMKHJlc3BvbnNlVXJsKVxuICAgICAgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0oZmV0Y2hVcmwsIGhlYWRlcnMpXG4gICAgICBmZXRjaFByb21pc2UgPSBmZXRjaChmZXRjaFVybCwgZmV0Y2hPcHRpb25zKVxuICAgICAgZmxpZ2h0UmVzcG9uc2VQcm9taXNlID0gc2hvdWxkSW1tZWRpYXRlbHlEZWNvZGVcbiAgICAgICAgPyBjcmVhdGVGcm9tTmV4dEZldGNoPFQ+KGZldGNoUHJvbWlzZSwgaGVhZGVycylcbiAgICAgICAgOiBudWxsXG4gICAgICBicm93c2VyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaFByb21pc2VcbiAgICAgIC8vIFdlIGp1c3QgcGVyZm9ybWVkIGEgbWFudWFsIHJlZGlyZWN0LCBzbyB0aGlzIGlzIG5vdyB0cnVlLlxuICAgICAgcmVkaXJlY3RlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIGZyb20gdGhlIHJlc3BvbnNlIFVSTCwgdG8gcHJldmVudCBpdFxuICAvLyBmcm9tIGxlYWtpbmcgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICBjb25zdCByZXNwb25zZVVybCA9IG5ldyBVUkwoYnJvd3NlclJlc3BvbnNlLnVybCwgZmV0Y2hVcmwpXG4gIHJlc3BvbnNlVXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG5cbiAgY29uc3QgcnNjUmVzcG9uc2U6IFJTQ1Jlc3BvbnNlPFQ+ID0ge1xuICAgIHVybDogcmVzcG9uc2VVcmwuaHJlZixcblxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBpZiBhbnkgcmVkaXJlY3RzIG9jY3VycmVkLCBlaXRoZXIgYXV0b21hdGljYWxseSBieSB0aGVcbiAgICAvLyBicm93c2VyLCBvciBtYW51YWxseSBieSB1cy4gU28gaXQncyBkaWZmZXJlbnQgZnJvbVxuICAgIC8vIGBicm93c2VyUmVzcG9uc2UucmVkaXJlY3RlZGAsIHdoaWNoIG9ubHkgdGVsbHMgdXMgd2hldGhlciB0aGUgYnJvd3NlclxuICAgIC8vIGZvbGxvd2VkIGEgcmVkaXJlY3QsIGFuZCBvbmx5IGZvciB0aGUgbGFzdCByZXNwb25zZSBpbiB0aGUgY2hhaW4uXG4gICAgcmVkaXJlY3RlZCxcblxuICAgIC8vIFRoZXNlIGNhbiBiZSBjb3BpZWQgZnJvbSB0aGUgbGFzdCBicm93c2VyIHJlc3BvbnNlIHdlIHJlY2VpdmVkLiBXZVxuICAgIC8vIGludGVudGlvbmFsbHkgb25seSBleHBvc2UgdGhlIHN1YnNldCBvZiBmaWVsZHMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZFxuICAgIC8vIGVsc2V3aGVyZSBpbiB0aGUgY29kZWJhc2UuXG4gICAgb2s6IGJyb3dzZXJSZXNwb25zZS5vayxcbiAgICBoZWFkZXJzOiBicm93c2VyUmVzcG9uc2UuaGVhZGVycyxcbiAgICBib2R5OiBicm93c2VyUmVzcG9uc2UuYm9keSxcbiAgICBzdGF0dXM6IGJyb3dzZXJSZXNwb25zZS5zdGF0dXMsXG5cbiAgICAvLyBUaGlzIGlzIHRoZSBleGFjdCBwcm9taXNlIHJldHVybmVkIGJ5IGBjcmVhdGVGcm9tRmV0Y2hgLiBJdCBjb250YWluc1xuICAgIC8vIGRlYnVnIGluZm9ybWF0aW9uIHRoYXQgd2UgbmVlZCB0byB0cmFuc2ZlciB0byBhbnkgZGVyaXZlZCBwcm9taXNlcyB0aGF0XG4gICAgLy8gYXJlIGxhdGVyIHJlbmRlcmVkIGJ5IFJlYWN0LlxuICAgIGZsaWdodFJlc3BvbnNlOiBmbGlnaHRSZXNwb25zZVByb21pc2UsXG4gIH1cblxuICByZXR1cm4gcnNjUmVzcG9uc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW08VD4oXG4gIGZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4sXG4gIHJlcXVlc3RIZWFkZXJzOiBSZXF1ZXN0SGVhZGVyc1xuKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0oZmxpZ2h0U3RyZWFtLCB7XG4gICAgY2FsbFNlcnZlcixcbiAgICBmaW5kU291cmNlTWFwVVJMLFxuICAgIGRlYnVnQ2hhbm5lbDogY3JlYXRlRGVidWdDaGFubmVsICYmIGNyZWF0ZURlYnVnQ2hhbm5lbChyZXF1ZXN0SGVhZGVycyksXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21OZXh0RmV0Y2g8VD4oXG4gIHByb21pc2VGb3JSZXNwb25zZTogUHJvbWlzZTxSZXNwb25zZT4sXG4gIHJlcXVlc3RIZWFkZXJzOiBSZXF1ZXN0SGVhZGVyc1xuKTogUHJvbWlzZTxUPiAmIHsgX2RlYnVnSW5mbz86IEFycmF5PGFueT4gfSB7XG4gIHJldHVybiBjcmVhdGVGcm9tRmV0Y2gocHJvbWlzZUZvclJlc3BvbnNlLCB7XG4gICAgY2FsbFNlcnZlcixcbiAgICBmaW5kU291cmNlTWFwVVJMLFxuICAgIGRlYnVnQ2hhbm5lbDogY3JlYXRlRGVidWdDaGFubmVsICYmIGNyZWF0ZURlYnVnQ2hhbm5lbChyZXF1ZXN0SGVhZGVycyksXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtKFxuICBvcmlnaW5hbEZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgLy8gV2hlbiBQUFIgaXMgZW5hYmxlZCwgcHJlZmV0Y2ggc3RyZWFtcyBtYXkgY29udGFpbiByZWZlcmVuY2VzIHRoYXQgbmV2ZXJcbiAgLy8gcmVzb2x2ZSwgYmVjYXVzZSB0aGF0J3MgaG93IHdlIGVuY29kZSBkeW5hbWljIGRhdGEgYWNjZXNzLiBJbiB0aGUgZGVjb2RlZFxuICAvLyBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIEZsaWdodCBjbGllbnQsIHRoZXNlIGFyZSByZWlmaWVkIGludG8gaGFuZ2luZ1xuICAvLyBwcm9taXNlcyB0aGF0IHN1c3BlbmQgZHVyaW5nIHJlbmRlciwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgd2hhdCB3ZSB3YW50LlxuICAvLyBUaGUgVUkgcmVzb2x2ZXMgd2hlbiBpdCBzd2l0Y2hlcyB0byB0aGUgZHluYW1pYyBkYXRhIHN0cmVhbVxuICAvLyAodmlhIHVzZURlZmVycmVkVmFsdWUoZHluYW1pYywgc3RhdGljKSkuXG4gIC8vXG4gIC8vIEhvd2V2ZXIsIHRoZSBGbGlnaHQgaW1wbGVtZW50YXRpb24gY3VycmVudGx5IGVycm9ycyBpZiB0aGUgc2VydmVyIGNsb3Nlc1xuICAvLyB0aGUgcmVzcG9uc2UgYmVmb3JlIGFsbCB0aGUgcmVmZXJlbmNlcyBhcmUgcmVzb2x2ZWQuIEFzIGEgY2hlYXQgdG8gd29ya1xuICAvLyBhcm91bmQgdGhpcywgd2Ugd3JhcCB0aGUgb3JpZ2luYWwgc3RyZWFtIGluIGEgbmV3IHN0cmVhbSB0aGF0IG5ldmVyIGNsb3NlcyxcbiAgLy8gYW5kIHRoZXJlZm9yZSBkb2Vzbid0IGVycm9yLlxuICBjb25zdCByZWFkZXIgPSBvcmlnaW5hbEZsaWdodFN0cmVhbS5nZXRSZWFkZXIoKVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgLy8gUGFzcyB0byB0aGUgdGFyZ2V0IHN0cmVhbSBhbmQga2VlcCBjb25zdW1pbmcgdGhlIEZsaWdodCByZXNwb25zZVxuICAgICAgICAgIC8vIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgc2VydmVyIHN0cmVhbSBoYXMgY2xvc2VkLiBFeGl0LCBidXQgaW50ZW50aW9uYWxseSBkbyBub3QgY2xvc2VcbiAgICAgICAgLy8gdGhlIHRhcmdldCBzdHJlYW0uXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlRmV0Y2giLCJjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbUJyb3dzZXIiLCJjcmVhdGVGcm9tRmV0Y2giLCJjcmVhdGVGcm9tRmV0Y2hCcm93c2VyIiwiY3JlYXRlRGVidWdDaGFubmVsIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiX19ORVhUX1JFQUNUX0RFQlVHX0NIQU5ORUwiLCJyZXF1aXJlIiwiZG9NcGFOYXZpZ2F0aW9uIiwidXJsIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJ0b1N0cmluZyIsImlzUGFnZVVubG9hZGluZyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvcHRpb25zIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsInByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QiLCJpc0htclJlZnJlc2giLCJORVhUX0hNUl9SRUZSRVNIX0hFQURFUiIsIk5FWFRfVVJMIiwib3JpZ2luYWxVcmwiLCJfX05FWFRfQ09ORklHX09VVFBVVCIsInBhdGhuYW1lIiwiZW5kc1dpdGgiLCJpc0xlZ2FjeVBQUiIsIl9fTkVYVF9QUFIiLCJfX05FWFRfQ0FDSEVfQ09NUE9ORU5UUyIsInNob3VsZEltbWVkaWF0ZWx5RGVjb2RlIiwicmVzIiwicmVzcG9uc2VVcmwiLCJjYW5vbmljYWxVcmwiLCJyZWRpcmVjdGVkIiwiY29udGVudFR5cGUiLCJnZXQiLCJpbnRlcmNlcHRpb24iLCJpbmNsdWRlcyIsInBvc3Rwb25lZCIsIk5FWFRfRElEX1BPU1RQT05FX0hFQURFUiIsInN0YWxlVGltZUhlYWRlclNlY29uZHMiLCJORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUiIsInN0YWxlVGltZSIsInBhcnNlSW50IiwiaXNGbGlnaHRSZXNwb25zZSIsInN0YXJ0c1dpdGgiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIm9rIiwiYm9keSIsImhhc2giLCJUVVJCT1BBQ0siLCJ3YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUiLCJmbGlnaHRSZXNwb25zZVByb21pc2UiLCJmbGlnaHRSZXNwb25zZSIsImZsaWdodFN0cmVhbSIsImNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtIiwiZ2V0QXBwQnVpbGRJZCIsImIiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmIiwiZmxpZ2h0RGF0YSIsInJlbmRlcmVkU2VhcmNoIiwiZ2V0UmVuZGVyZWRTZWFyY2giLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVyZW5kZXJlZCIsIlMiLCJkZWJ1Z0luZm8iLCJfZGVidWdJbmZvIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiZmV0Y2hQcmlvcml0eSIsInNpZ25hbCIsIl9fTkVYVF9URVNUX01PREUiLCJkZXBsb3ltZW50SWQiLCJnZXREZXBsb3ltZW50SWQiLCJzZWxmIiwiX19uZXh0X3IiLCJORVhUX0hUTUxfUkVRVUVTVF9JRF9IRUFERVIiLCJORVhUX1JFUVVFU1RfSURfSEVBREVSIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiVWludDMyQXJyYXkiLCJmZXRjaE9wdGlvbnMiLCJjcmVkZW50aWFscyIsInByaW9yaXR5IiwidW5kZWZpbmVkIiwiZmV0Y2hVcmwiLCJzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSIsImZldGNoUHJvbWlzZSIsImZldGNoIiwiY3JlYXRlRnJvbU5leHRGZXRjaCIsImJyb3dzZXJSZXNwb25zZSIsIl9fTkVYVF9DTElFTlRfVkFMSURBVEVfUlNDX1JFUVVFU1RfSEVBREVSUyIsIk1BWF9SRURJUkVDVFMiLCJuIiwic2VhcmNoUGFyYW1zIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJkZWxldGUiLCJyc2NSZXNwb25zZSIsImhyZWYiLCJzdGF0dXMiLCJyZXF1ZXN0SGVhZGVycyIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwiZGVidWdDaGFubmVsIiwicHJvbWlzZUZvclJlc3BvbnNlIiwib3JpZ2luYWxGbGlnaHRTdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImVucXVldWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js":
/*!****************************************************************************************************!*\
  !*** ../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js ***!
  \****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverActionReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ \"(app-pages-browser)/../node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../../app-find-source-map-url */ \"(app-pages-browser)/../node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-headers.js\");\nconst _unrecognizedactionerror = __webpack_require__(/*! ../../unrecognized-action-error */ \"(app-pages-browser)/../node_modules/next/dist/client/components/unrecognized-action-error.js\");\nconst _client = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\nconst _assignlocation = __webpack_require__(/*! ../../../assign-location */ \"(app-pages-browser)/../node_modules/next/dist/client/assign-location.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../../flight-data-helpers */ \"(app-pages-browser)/../node_modules/next/dist/client/flight-data-helpers.js\");\nconst _redirect = __webpack_require__(/*! ../../redirect */ \"(app-pages-browser)/../node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ../../redirect-error */ \"(app-pages-browser)/../node_modules/next/dist/client/components/redirect-error.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../remove-base-path */ \"(app-pages-browser)/../node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../has-base-path */ \"(app-pages-browser)/../node_modules/next/dist/client/has-base-path.js\");\nconst _serverreferenceinfo = __webpack_require__(/*! ../../../../shared/lib/server-reference-info */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/server-reference-info.js\");\nconst _cache = __webpack_require__(/*! ../../segment-cache/cache */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/cache.js\");\nconst _deploymentid = __webpack_require__(/*! ../../../../shared/lib/deployment-id */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/deployment-id.js\");\nconst _navigation = __webpack_require__(/*! ../../segment-cache/navigation */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/navigation.js\");\nconst _actionrevalidationkind = __webpack_require__(/*! ../../../../shared/lib/action-revalidation-kind */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/action-revalidation-kind.js\");\nconst _approuterutils = __webpack_require__(/*! ../../app-router-utils */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-utils.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nconst createFromFetch = _client.createFromFetch;\nlet createDebugChannel;\nif (false) {}\nasync function fetchServerAction(state, nextUrl, { actionId, actionArgs }) {\n    const temporaryReferences = (0, _client.createTemporaryReferenceSet)();\n    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);\n    // TODO: Currently, we're only omitting unused args for the experimental \"use\n    // cache\" functions. Once the server reference info byte feature is stable, we\n    // should apply this to server actions as well.\n    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;\n    const body = await (0, _client.encodeReply)(usedArgs, {\n        temporaryReferences\n    });\n    const headers = {\n        Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n        [_approuterheaders.ACTION_HEADER]: actionId,\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(state.tree)\n    };\n    const deploymentId = (0, _deploymentid.getDeploymentId)();\n    if (deploymentId) {\n        headers['x-deployment-id'] = deploymentId;\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    if (true) {\n        if (self.__next_r) {\n            headers[_approuterheaders.NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\n        }\n        // Create a new request ID for the server action request. The server uses\n        // this to tag debug information sent via WebSocket to the client, which\n        // then routes those chunks to the debug channel associated with this ID.\n        headers[_approuterheaders.NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\n    }\n    const res = await fetch(state.canonicalUrl, {\n        method: 'POST',\n        headers,\n        body\n    });\n    // Handle server actions that the server didn't recognize.\n    const unrecognizedActionHeader = res.headers.get(_approuterheaders.NEXT_ACTION_NOT_FOUND_HEADER);\n    if (unrecognizedActionHeader === '1') {\n        throw Object.defineProperty(new _unrecognizedactionerror.UnrecognizedActionError(`Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`), \"__NEXT_ERROR_CODE\", {\n            value: \"E715\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const redirectHeader = res.headers.get('x-action-redirect');\n    const [location1, _redirectType] = redirectHeader?.split(';') || [];\n    let redirectType;\n    switch(_redirectType){\n        case 'push':\n            redirectType = _redirecterror.RedirectType.push;\n            break;\n        case 'replace':\n            redirectType = _redirecterror.RedirectType.replace;\n            break;\n        default:\n            redirectType = undefined;\n    }\n    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);\n    let revalidationKind = _actionrevalidationkind.ActionDidNotRevalidate;\n    try {\n        const revalidationHeader = res.headers.get('x-action-revalidated');\n        if (revalidationHeader) {\n            const parsedKind = JSON.parse(revalidationHeader);\n            if (parsedKind === _actionrevalidationkind.ActionDidRevalidateStaticAndDynamic || parsedKind === _actionrevalidationkind.ActionDidRevalidateDynamicOnly) {\n                revalidationKind = parsedKind;\n            }\n        }\n    } catch  {}\n    const redirectLocation = location1 ? (0, _assignlocation.assignLocation)(location1, new URL(state.canonicalUrl, window.location.href)) : undefined;\n    const contentType = res.headers.get('content-type');\n    const isRscResponse = !!(contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER));\n    // Handle invalid server action responses.\n    // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n    // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n    if (!isRscResponse && !redirectLocation) {\n        // The server can respond with a text/plain error message, but we'll fallback to something generic\n        // if there isn't one.\n        const message = res.status >= 400 && contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let actionResult;\n    let actionFlightData;\n    let actionFlightDataRenderedSearch;\n    let actionFlightDataCouldBeIntercepted;\n    if (isRscResponse) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer,\n            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n            temporaryReferences,\n            debugChannel: createDebugChannel && createDebugChannel(headers)\n        });\n        // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n        actionResult = redirectLocation ? undefined : response.a;\n        const maybeFlightData = (0, _flightdatahelpers.normalizeFlightData)(response.f);\n        if (maybeFlightData !== '') {\n            actionFlightData = maybeFlightData;\n            actionFlightDataRenderedSearch = response.q;\n            actionFlightDataCouldBeIntercepted = response.i;\n        }\n    } else {\n        // An external redirect doesn't contain RSC data.\n        actionResult = undefined;\n        actionFlightData = undefined;\n        actionFlightDataRenderedSearch = undefined;\n        actionFlightDataCouldBeIntercepted = undefined;\n    }\n    return {\n        actionResult,\n        actionFlightData,\n        actionFlightDataRenderedSearch,\n        actionFlightDataCouldBeIntercepted,\n        redirectLocation,\n        redirectType,\n        revalidationKind,\n        isPrerender\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.previousNextUrl || state.nextUrl : null;\n    return fetchServerAction(state, nextUrl, action).then(async ({ revalidationKind, actionResult, actionFlightData: flightData, actionFlightDataRenderedSearch: flightDataRenderedSearch, actionFlightDataCouldBeIntercepted: flightDataCouldBeIntercepted, redirectLocation, redirectType })=>{\n        if (revalidationKind !== _actionrevalidationkind.ActionDidNotRevalidate) {\n            // Store whether this action triggered any revalidation\n            // The action queue will use this information to potentially\n            // trigger a refresh action if the action was discarded\n            // (ie, due to a navigation, before the action completed)\n            action.didRevalidate = true;\n            // If there was a revalidation, evict the entire prefetch cache.\n            // TODO: Evict only segments with matching tags and/or paths.\n            if (revalidationKind === _actionrevalidationkind.ActionDidRevalidateStaticAndDynamic) {\n                (0, _cache.revalidateEntireCache)(nextUrl, state.tree);\n            }\n        }\n        const pendingPush = redirectType !== _redirecterror.RedirectType.replace;\n        state.pushRef.pendingPush = pendingPush;\n        mutable.pendingPush = pendingPush;\n        if (redirectLocation !== undefined) {\n            // If the action triggered a redirect, the action promise will be rejected with\n            // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n            // action result to resolve the promise with. This will effectively reset the state of\n            // the component that called the action as the error boundary will remount the tree.\n            // The status code doesn't matter here as the action handler will have already sent\n            // a response with the correct status code.\n            const resolvedRedirectType = redirectType || _redirecterror.RedirectType.push;\n            if ((0, _approuterutils.isExternalURL)(redirectLocation)) {\n                // External redirect. Triggers an MPA navigation.\n                const redirectHref = redirectLocation.href;\n                const redirectError = createRedirectErrorForAction(redirectHref, resolvedRedirectType);\n                reject(redirectError);\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref, pendingPush);\n            } else {\n                // Internal redirect. Triggers an SPA navigation.\n                const redirectWithBasepath = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n                const redirectHref = (0, _hasbasepath.hasBasePath)(redirectWithBasepath) ? (0, _removebasepath.removeBasePath)(redirectWithBasepath) : redirectWithBasepath;\n                const redirectError = createRedirectErrorForAction(redirectHref, resolvedRedirectType);\n                reject(redirectError);\n            }\n        } else {\n            // If there's no redirect, resolve the action with the result.\n            resolve(actionResult);\n        }\n        // Check if we can bail out without updating any state.\n        if (redirectLocation === undefined && // Did the action revalidate any data?\n        revalidationKind === _actionrevalidationkind.ActionDidNotRevalidate && // Did the server render new data?\n        flightData === undefined) {\n            // The action did not trigger any revalidations or redirects. No\n            // navigation is required.\n            return state;\n        }\n        if (flightData === undefined && redirectLocation !== undefined) {\n            // The server redirected, but did not send any Flight data. This implies\n            // an external redirect.\n            // TODO: We should refactor the action response type to be more explicit\n            // about the various response types.\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, pendingPush);\n        }\n        if (typeof flightData === 'string') {\n            // If the flight data is just a string, something earlier in the\n            // response handling triggered an external redirect.\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, pendingPush);\n        }\n        // The action triggered a navigation  either a redirect, a revalidation,\n        // or both.\n        // If there was no redirect, then the target URL is the same as the\n        // current URL.\n        const currentUrl = new URL(state.canonicalUrl, location.origin);\n        const redirectUrl = redirectLocation !== undefined ? redirectLocation : currentUrl;\n        const currentFlightRouterState = state.tree;\n        const shouldScroll = true;\n        // If the action triggered a revalidation of the cache, we should also\n        // refresh all the dynamic data.\n        const freshnessPolicy = revalidationKind === _actionrevalidationkind.ActionDidNotRevalidate ? _pprnavigations.FreshnessPolicy.Default : _pprnavigations.FreshnessPolicy.RefreshAll;\n        // The server may have sent back new data. If so, we will perform a\n        // \"seeded\" navigation that uses the data from the response.\n        if (flightData !== undefined) {\n            const normalizedFlightData = flightData[0];\n            if (normalizedFlightData !== undefined && // TODO: Currently the server always renders from the root in\n            // response to a Server Action. In the case of a normal redirect\n            // with no revalidation, it should skip over the shared layouts.\n            normalizedFlightData.isRootRender && flightDataRenderedSearch !== undefined && flightDataCouldBeIntercepted !== undefined) {\n                // The server sent back new route data as part of the response. We\n                // will use this to render the new page. If this happens to be only a\n                // subset of the data needed to render the new page, we'll initiate a\n                // new fetch, like we would for a normal navigation.\n                const redirectCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(redirectUrl);\n                const navigationSeed = {\n                    tree: normalizedFlightData.tree,\n                    renderedSearch: flightDataRenderedSearch,\n                    data: normalizedFlightData.seedData,\n                    head: normalizedFlightData.head\n                };\n                const now = Date.now();\n                const result = (0, _navigation.navigateToSeededRoute)(now, redirectUrl, redirectCanonicalUrl, navigationSeed, currentUrl, state.cache, currentFlightRouterState, freshnessPolicy, nextUrl, shouldScroll);\n                return (0, _navigatereducer.handleNavigationResult)(redirectUrl, state, mutable, pendingPush, result);\n            }\n        }\n        // The server did not send back new data. We'll perform a regular, non-\n        // seeded navigation  effectively the same as <Link> or router.push().\n        const result = (0, _navigation.navigate)(redirectUrl, currentUrl, state.cache, currentFlightRouterState, nextUrl, freshnessPolicy, shouldScroll, mutable);\n        return (0, _navigatereducer.handleNavigationResult)(redirectUrl, state, mutable, pendingPush, result);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nfunction createRedirectErrorForAction(redirectHref, resolvedRedirectType) {\n    const redirectError = (0, _redirect.getRedirectError)(redirectHref, resolvedRedirectType);\n    redirectError.handled = true;\n    return redirectError;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3VEQStQZ0JBOzs7ZUFBQUE7OzsyQ0EzUFc7aURBQ007OENBVTFCO3FEQUNpQztvQ0FRakM7NENBUXdCOytDQUNHOzZDQUN3QjsrREFDUjsrQ0FLM0M7c0NBQzBCOzJDQUNKOzRDQUNFO3lDQUNIO2lEQUlyQjttQ0FDK0I7MENBQ047d0NBSXpCO29EQU9BOzRDQUN1Qjs0Q0FDRTtBQUVoQyxNQUFNQyxrQkFDSkMsUUFBQUEsZUFBc0I7QUFFeEIsSUFBSUM7QUFJSixJQUNFQyxLQUNzQyxFQUN0QyxFQUlEO0FBZ0JELGVBQWVLLGtCQUNiQyxLQUEyQixFQUMzQkMsT0FBd0MsRUFDeEMsRUFBRUMsUUFBUSxFQUFFQyxVQUFVLEVBQXNCO0lBRTVDLE1BQU1DLHNCQUFzQkMsQ0FBQUEsR0FBQUEsUUFBQUEsMkJBQTJCO0lBQ3ZELE1BQU1DLE9BQU9DLENBQUFBLEdBQUFBLHFCQUFBQSxnQ0FBQUEsRUFBaUNMO0lBRTlDLDZFQUE2RTtJQUM3RSw4RUFBOEU7SUFDOUUsK0NBQStDO0lBQy9DLE1BQU1NLFdBQ0pGLEtBQUtHLElBQUksS0FBSyxjQUFjQyxDQUFBQSxHQUFBQSxxQkFBQUEsY0FBYyxFQUFDUCxZQUFZRyxRQUFRSDtJQUVqRSxNQUFNUSxPQUFPLE1BQU1DLENBQUFBLEdBQUFBLFFBQUFBLFdBQUFBLEVBQVlKLFVBQVU7UUFBRUo7SUFBb0I7SUFFL0QsTUFBTVMsVUFBa0M7UUFDdENDLFFBQVFDLGtCQUFBQSx1QkFBdUI7UUFDL0IsQ0FBQ0Msa0JBQUFBLGFBQWEsQ0FBQyxFQUFFZDtRQUNqQixDQUFDZSxrQkFBQUEsNkJBQTZCLENBQUMsRUFBRUMsQ0FBQUEsR0FBQUEsbUJBQUFBLGtDQUFBQSxFQUMvQmxCLE1BQU1tQixJQUFJO0lBRWQ7SUFFQSxNQUFNQyxlQUFlQyxDQUFBQSxHQUFBQSxjQUFBQSxlQUFBQTtJQUNyQixJQUFJRCxjQUFjO1FBQ2hCUCxPQUFPLENBQUMsa0JBQWtCLEdBQUdPO0lBQy9CO0lBRUEsSUFBSW5CLFNBQVM7UUFDWFksT0FBTyxDQUFDUyxrQkFBQUEsUUFBUSxDQUFDLEdBQUdyQjtJQUN0QjtJQUVBLElBQUlQLElBQW9CLEVBQW1CO1FBQ3pDLElBQUk2QixLQUFLQyxRQUFRLEVBQUU7WUFDakJYLE9BQU8sQ0FBQ1ksa0JBQUFBLDJCQUEyQixDQUFDLEdBQUdGLEtBQUtDLFFBQVE7UUFDdEQ7UUFFQSx5RUFBeUU7UUFDekUsd0VBQXdFO1FBQ3hFLHlFQUF5RTtRQUN6RVgsT0FBTyxDQUFDYSxrQkFBQUEsc0JBQXNCLENBQUMsR0FBR0MsT0FDL0JDLGVBQWUsQ0FBQyxJQUFJQyxZQUFZLEdBQUcsQ0FBQyxFQUFFLENBQ3RDQyxRQUFRLENBQUM7SUFDZDtJQUVBLE1BQU1DLE1BQU0sTUFBTUMsTUFBTWhDLE1BQU1pQyxZQUFZLEVBQUU7UUFBRUMsUUFBUTtRQUFRckI7UUFBU0Y7SUFBSztJQUU1RSwwREFBMEQ7SUFDMUQsTUFBTXdCLDJCQUEyQkosSUFBSWxCLE9BQU8sQ0FBQ3VCLEdBQUcsQ0FBQ0Msa0JBQUFBLDRCQUE0QjtJQUM3RSxJQUFJRiw2QkFBNkIsS0FBSztRQUNwQyxNQUFNLHFCQUVMLENBRkssSUFBSUcseUJBQUFBLHVCQUF1QixDQUMvQixDQUFDLGVBQWUsRUFBRXBDLFNBQVMseUdBQXlHLENBQUMsR0FEakk7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBRUEsTUFBTXFDLGlCQUFpQlIsSUFBSWxCLE9BQU8sQ0FBQ3VCLEdBQUcsQ0FBQztJQUN2QyxNQUFNLENBQUNJLFdBQVVDLGNBQWMsR0FBR0YsZ0JBQWdCRyxNQUFNLFFBQVEsRUFBRTtJQUNsRSxJQUFJQztJQUNKLE9BQVFGO1FBQ04sS0FBSztZQUNIRSxlQUFlQyxlQUFBQSxZQUFZLENBQUNDLElBQUk7WUFDaEM7UUFDRixLQUFLO1lBQ0hGLGVBQWVDLGVBQUFBLFlBQVksQ0FBQ0UsT0FBTztZQUNuQztRQUNGO1lBQ0VILGVBQWVJO0lBQ25CO0lBRUEsTUFBTUMsY0FBYyxDQUFDLENBQUNqQixJQUFJbEIsT0FBTyxDQUFDdUIsR0FBRyxDQUFDYSxrQkFBQUEsd0JBQXdCO0lBRTlELElBQUlDLG1CQUEyQ0Msd0JBQUFBLHNCQUFzQjtJQUNyRSxJQUFJO1FBQ0YsTUFBTUMscUJBQXFCckIsSUFBSWxCLE9BQU8sQ0FBQ3VCLEdBQUcsQ0FBQztRQUMzQyxJQUFJZ0Isb0JBQW9CO1lBQ3RCLE1BQU1DLGFBQWFDLEtBQUtDLEtBQUssQ0FBQ0g7WUFDOUIsSUFDRUMsZUFBZUcsd0JBQUFBLG1DQUFtQyxJQUNsREgsZUFBZUksd0JBQUFBLDhCQUE4QixFQUM3QztnQkFDQVAsbUJBQW1CRztZQUNyQjtRQUNGO0lBQ0YsRUFBRSxPQUFNLENBQUM7SUFFVCxNQUFNSyxtQkFBbUJsQixZQUNyQm1CLENBQUFBLEdBQUFBLGdCQUFBQSxjQUFBQSxFQUNFbkIsV0FDQSxJQUFJb0IsSUFBSTVELE1BQU1pQyxZQUFZLEVBQUU0QixPQUFPckIsUUFBUSxDQUFDc0IsSUFBSSxLQUVsRGY7SUFFSixNQUFNZ0IsY0FBY2hDLElBQUlsQixPQUFPLENBQUN1QixHQUFHLENBQUM7SUFDcEMsTUFBTTRCLGdCQUFnQixDQUFDLENBQ3JCRCxDQUFBQSxlQUFlQSxZQUFZRSxVQUFVLENBQUNsRCxrQkFBQUEsd0JBQXVCO0lBRy9ELDBDQUEwQztJQUMxQyxpR0FBaUc7SUFDakcsaUdBQWlHO0lBQ2pHLElBQUksQ0FBQ2lELGlCQUFpQixDQUFDTixrQkFBa0I7UUFDdkMsa0dBQWtHO1FBQ2xHLHNCQUFzQjtRQUN0QixNQUFNUSxVQUNKbkMsSUFBSW9DLE1BQU0sSUFBSSxPQUFPSixnQkFBZ0IsZUFDakMsTUFBTWhDLElBQUlxQyxJQUFJLEtBQ2Q7UUFFTixNQUFNLHFCQUFrQixDQUFsQixJQUFJQyxNQUFNSCxVQUFWO21CQUFBO3dCQUFBOzBCQUFBO1FBQWlCO0lBQ3pCO0lBRUEsSUFBSUk7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSixJQUFJVCxlQUFlO1FBQ2pCLE1BQU1VLFdBQWlDLE1BQU1uRixnQkFDM0NvRixRQUFRQyxPQUFPLENBQUM3QyxNQUNoQjtZQUNFOEMsWUFBQUEsZUFBQUEsVUFBVTtZQUNWQyxrQkFBQUEscUJBQUFBLGdCQUFnQjtZQUNoQjFFO1lBQ0EyRSxjQUFjdEYsc0JBQXNCQSxtQkFBbUJvQjtRQUN6RDtRQUdGLDRGQUE0RjtRQUM1RnlELGVBQWVaLG1CQUFtQlgsWUFBWTJCLFNBQVNNLENBQUM7UUFDeEQsTUFBTUMsa0JBQWtCQyxDQUFBQSxHQUFBQSxtQkFBQUEsbUJBQUFBLEVBQW9CUixTQUFTUyxDQUFDO1FBQ3RELElBQUlGLG9CQUFvQixJQUFJO1lBQzFCVixtQkFBbUJVO1lBQ25CVCxpQ0FBaUNFLFNBQVNVLENBQUM7WUFDM0NYLHFDQUFxQ0MsU0FBU1csQ0FBQztRQUNqRDtJQUNGLE9BQU87UUFDTCxpREFBaUQ7UUFDakRmLGVBQWV2QjtRQUNmd0IsbUJBQW1CeEI7UUFDbkJ5QixpQ0FBaUN6QjtRQUNqQzBCLHFDQUFxQzFCO0lBQ3ZDO0lBRUEsT0FBTztRQUNMdUI7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQWY7UUFDQWY7UUFDQU87UUFDQUY7SUFDRjtBQUNGO0FBTU8sU0FBUzFELG9CQUNkVSxLQUEyQixFQUMzQnNGLE1BQTBCO0lBRTFCLE1BQU0sRUFBRVYsT0FBTyxFQUFFVyxNQUFNLEVBQUUsR0FBR0Q7SUFDNUIsTUFBTUUsVUFBK0IsQ0FBQztJQUV0Q0EsUUFBUUMsMEJBQTBCLEdBQUc7SUFFckMsMkdBQTJHO0lBQzNHLG1FQUFtRTtJQUNuRSw0RUFBNEU7SUFDNUUsd0RBQXdEO0lBQ3hELE1BQU14RixVQU1KLHlEQUx5RCxDQUNDO0lBQzFELHdEQUF3RDtJQUN4RCxzREFBc0Q7SUFDdEQsWUFBWTtLQUNYRCxNQUFNMEYsZUFBZSxJQUFJMUYsTUFBTUMsT0FBQUEsS0FDaEMwRixDQUFBQSxHQUFBQSxtQ0FBQUEsaUNBQUFBLEVBQWtDM0YsTUFBTW1CLElBQUksSUFDeENuQixNQUFNMEYsZUFBZSxJQUFJMUYsTUFBTUMsT0FBTyxHQUN0QztJQUVOLE9BQU9GLGtCQUFrQkMsT0FBT0MsU0FBU3FGLFFBQVFNLElBQUksQ0FDbkQsT0FBTyxFQUNMMUMsZ0JBQWdCLEVBQ2hCb0IsWUFBWSxFQUNaQyxrQkFBa0JzQixVQUFVLEVBQzVCckIsZ0NBQWdDc0Isd0JBQXdCLEVBQ3hEckIsb0NBQW9Dc0IsNEJBQTRCLEVBQ2hFckMsZ0JBQWdCLEVBQ2hCZixZQUFZLEVBQ2I7UUFDQyxJQUFJTyxxQkFBcUJDLHdCQUFBQSxzQkFBc0IsRUFBRTtZQUMvQyx1REFBdUQ7WUFDdkQsNERBQTREO1lBQzVELHVEQUF1RDtZQUN2RCx5REFBeUQ7WUFDekRtQyxPQUFPVSxhQUFhLEdBQUc7WUFFdkIsZ0VBQWdFO1lBQ2hFLDZEQUE2RDtZQUM3RCxJQUFJOUMscUJBQXFCTSx3QkFBQUEsbUNBQW1DLEVBQUU7Z0JBQzVEeUMsQ0FBQUEsR0FBQUEsT0FBQUEscUJBQUFBLEVBQXNCaEcsU0FBU0QsTUFBTW1CLElBQUk7WUFDM0M7UUFDRjtRQUVBLE1BQU0rRSxjQUFjdkQsaUJBQWlCQyxlQUFBQSxZQUFZLENBQUNFLE9BQU87UUFDekQ5QyxNQUFNbUcsT0FBTyxDQUFDRCxXQUFXLEdBQUdBO1FBQzVCVixRQUFRVSxXQUFXLEdBQUdBO1FBRXRCLElBQUl4QyxxQkFBcUJYLFdBQVc7WUFDbEMsK0VBQStFO1lBQy9FLCtFQUErRTtZQUMvRSxzRkFBc0Y7WUFDdEYsb0ZBQW9GO1lBQ3BGLG1GQUFtRjtZQUNuRiwyQ0FBMkM7WUFDM0MsTUFBTXFELHVCQUF1QnpELGdCQUFnQkMsZUFBQUEsWUFBWSxDQUFDQyxJQUFJO1lBRTlELElBQUl3RCxDQUFBQSxHQUFBQSxnQkFBQUEsYUFBQUEsRUFBYzNDLG1CQUFtQjtnQkFDbkMsaURBQWlEO2dCQUNqRCxNQUFNNEMsZUFBZTVDLGlCQUFpQkksSUFBSTtnQkFDMUMsTUFBTXlDLGdCQUFnQkMsNkJBQ3BCRixjQUNBRjtnQkFFRmIsT0FBT2dCO2dCQUNQLE9BQU9FLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFBa0J6RyxPQUFPd0YsU0FBU2MsY0FBY0o7WUFDekQsT0FBTztnQkFDTCxpREFBaUQ7Z0JBQ2pELE1BQU1RLHVCQUF1QkMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUMzQmpELGtCQUNBO2dCQUVGLE1BQU00QyxlQUFlTSxDQUFBQSxHQUFBQSxhQUFBQSxXQUFXLEVBQUNGLHdCQUM3QkcsQ0FBQUEsR0FBQUEsZ0JBQUFBLGNBQUFBLEVBQWVILHdCQUNmQTtnQkFDSixNQUFNSCxnQkFBZ0JDLDZCQUNwQkYsY0FDQUY7Z0JBRUZiLE9BQU9nQjtZQUNUO1FBQ0YsT0FBTztZQUNMLDhEQUE4RDtZQUM5RDNCLFFBQVFOO1FBQ1Y7UUFFQSx1REFBdUQ7UUFDdkQsSUFFRVoscUJBQXFCWCxhQUNyQixHQUZxQyxtQ0FFQztRQUN0Q0cscUJBQXFCQyx3QkFBQUEsc0JBQXNCLElBQzNDLGtDQUFrQztRQUNsQzBDLGVBQWU5QyxXQUNmO1lBQ0EsZ0VBQWdFO1lBQ2hFLDBCQUEwQjtZQUMxQixPQUFPL0M7UUFDVDtRQUVBLElBQUk2RixlQUFlOUMsYUFBYVcscUJBQXFCWCxXQUFXO1lBQzlELHdFQUF3RTtZQUN4RSx3QkFBd0I7WUFDeEIsd0VBQXdFO1lBQ3hFLG9DQUFvQztZQUNwQyxPQUFPMEQsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNMekcsT0FDQXdGLFNBQ0E5QixpQkFBaUJJLElBQUksRUFDckJvQztRQUVKO1FBRUEsSUFBSSxPQUFPTCxlQUFlLFVBQVU7WUFDbEMsZ0VBQWdFO1lBQ2hFLG9EQUFvRDtZQUNwRCxPQUFPWSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQWtCekcsT0FBT3dGLFNBQVNLLFlBQVlLO1FBQ3ZEO1FBRUEseUVBQXlFO1FBQ3pFLFdBQVc7UUFFWCxtRUFBbUU7UUFDbkUsZUFBZTtRQUNmLE1BQU1ZLGFBQWEsSUFBSWxELElBQUk1RCxNQUFNaUMsWUFBWSxFQUFFTyxTQUFTdUUsTUFBTTtRQUM5RCxNQUFNQyxjQUNKdEQscUJBQXFCWCxZQUFZVyxtQkFBbUJvRDtRQUN0RCxNQUFNRywyQkFBMkJqSCxNQUFNbUIsSUFBSTtRQUMzQyxNQUFNK0YsZUFBZTtRQUVyQixzRUFBc0U7UUFDdEUsZ0NBQWdDO1FBQ2hDLE1BQU1DLGtCQUNKakUscUJBQXFCQyx3QkFBQUEsc0JBQXNCLEdBQ3ZDaUUsZ0JBQUFBLGVBQWUsQ0FBQ0MsT0FBTyxHQUN2QkQsZ0JBQUFBLGVBQWUsQ0FBQ0UsVUFBVTtRQUVoQyxtRUFBbUU7UUFDbkUsNERBQTREO1FBQzVELElBQUl6QixlQUFlOUMsV0FBVztZQUM1QixNQUFNd0UsdUJBQXVCMUIsVUFBVSxDQUFDLEVBQUU7WUFDMUMsSUFDRTBCLHlCQUF5QnhFLGFBQ3pCLDZEQUE2RDtZQUM3RCxnRUFBZ0U7WUFDaEUsZ0VBQWdFO1lBQ2hFd0UscUJBQXFCQyxZQUFZLElBQ2pDMUIsNkJBQTZCL0MsYUFDN0JnRCxpQ0FBaUNoRCxXQUNqQztnQkFDQSxrRUFBa0U7Z0JBQ2xFLHFFQUFxRTtnQkFDckUscUVBQXFFO2dCQUNyRSxvREFBb0Q7Z0JBQ3BELE1BQU0wRSx1QkFBdUJkLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JLO2dCQUMvQyxNQUFNVSxpQkFBaUI7b0JBQ3JCdkcsTUFBTW9HLHFCQUFxQnBHLElBQUk7b0JBQy9Cd0csZ0JBQWdCN0I7b0JBQ2hCOEIsTUFBTUwscUJBQXFCTSxRQUFRO29CQUNuQ0MsTUFBTVAscUJBQXFCTyxJQUFJO2dCQUNqQztnQkFDQSxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO2dCQUNwQixNQUFNRSxTQUFTQyxDQUFBQSxHQUFBQSxZQUFBQSxxQkFBQUEsRUFDYkgsS0FDQWYsYUFDQVMsc0JBQ0FDLGdCQUNBWixZQUNBOUcsTUFBTW1JLEtBQUssRUFDWGxCLDBCQUNBRSxpQkFDQWxILFNBQ0FpSDtnQkFFRixPQUFPa0IsQ0FBQUEsR0FBQUEsaUJBQUFBLHNCQUFBQSxFQUNMcEIsYUFDQWhILE9BQ0F3RixTQUNBVSxhQUNBK0I7WUFFSjtRQUNGO1FBRUEsdUVBQXVFO1FBQ3ZFLHVFQUF1RTtRQUN2RSxNQUFNQSxTQUFTSSxDQUFBQSxHQUFBQSxZQUFBQSxRQUFBQSxFQUNickIsYUFDQUYsWUFDQTlHLE1BQU1tSSxLQUFLLEVBQ1hsQiwwQkFDQWhILFNBQ0FrSCxpQkFDQUQsY0FDQTFCO1FBRUYsT0FBTzRDLENBQUFBLEdBQUFBLGlCQUFBQSxzQkFBQUEsRUFDTHBCLGFBQ0FoSCxPQUNBd0YsU0FDQVUsYUFDQStCO0lBRUosR0FDQSxDQUFDSztRQUNDLG1IQUFtSDtRQUNuSC9DLE9BQU8rQztRQUVQLE9BQU90STtJQUNUO0FBRUo7QUFFQSxTQUFTd0csNkJBQ1BGLFlBQW9CLEVBQ3BCRixvQkFBa0M7SUFFbEMsTUFBTUcsZ0JBQWdCZ0MsQ0FBQUEsR0FBQUEsVUFBQUEsZ0JBQUFBLEVBQWlCakMsY0FBY0Y7SUFNbkRHLGNBQXNCaUMsT0FBTyxHQUFHO0lBQ2xDLE9BQU9qQztBQUNUIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEFjdGlvbkZsaWdodFJlc3BvbnNlLFxuICBBY3Rpb25SZXN1bHQsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7IGNhbGxTZXJ2ZXIgfSBmcm9tICcuLi8uLi8uLi9hcHAtY2FsbC1zZXJ2ZXInXG5pbXBvcnQgeyBmaW5kU291cmNlTWFwVVJMIH0gZnJvbSAnLi4vLi4vLi4vYXBwLWZpbmQtc291cmNlLW1hcC11cmwnXG5pbXBvcnQge1xuICBBQ1RJT05fSEVBREVSLFxuICBORVhUX0FDVElPTl9OT1RfRk9VTkRfSEVBREVSLFxuICBORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIsXG4gIE5FWFRfSFRNTF9SRVFVRVNUX0lEX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfVVJMLFxuICBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgTkVYVF9SRVFVRVNUX0lEX0hFQURFUixcbn0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHsgVW5yZWNvZ25pemVkQWN0aW9uRXJyb3IgfSBmcm9tICcuLi8uLi91bnJlY29nbml6ZWQtYWN0aW9uLWVycm9yJ1xuXG4vLyBUT0RPOiBFeHBsaWNpdGx5IGltcG9ydCBmcm9tIGNsaWVudC5icm93c2VyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQge1xuICBjcmVhdGVGcm9tRmV0Y2ggYXMgY3JlYXRlRnJvbUZldGNoQnJvd3NlcixcbiAgY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0LFxuICBlbmNvZGVSZXBseSxcbn0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcblxuaW1wb3J0IHR5cGUge1xuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgUmVkdWNlclN0YXRlLFxuICBTZXJ2ZXJBY3Rpb25BY3Rpb24sXG4gIFNlcnZlckFjdGlvbk11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgYXNzaWduTG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi9hc3NpZ24tbG9jYXRpb24nXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwsIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUgfSBmcm9tICcuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlJ1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplRmxpZ2h0RGF0YSxcbiAgcHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdCxcbiAgdHlwZSBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbn0gZnJvbSAnLi4vLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcbmltcG9ydCB7IGdldFJlZGlyZWN0RXJyb3IgfSBmcm9tICcuLi8uLi9yZWRpcmVjdCdcbmltcG9ydCB7IFJlZGlyZWN0VHlwZSB9IGZyb20gJy4uLy4uL3JlZGlyZWN0LWVycm9yJ1xuaW1wb3J0IHsgcmVtb3ZlQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHtcbiAgZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQsXG4gIG9taXRVbnVzZWRBcmdzLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL3NlcnZlci1yZWZlcmVuY2UtaW5mbydcbmltcG9ydCB7IHJldmFsaWRhdGVFbnRpcmVDYWNoZSB9IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUvY2FjaGUnXG5pbXBvcnQgeyBnZXREZXBsb3ltZW50SWQgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2RlcGxveW1lbnQtaWQnXG5pbXBvcnQge1xuICBuYXZpZ2F0ZVRvU2VlZGVkUm91dGUsXG4gIG5hdmlnYXRlIGFzIG5hdmlnYXRlVXNpbmdTZWdtZW50Q2FjaGUsXG59IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUvbmF2aWdhdGlvbidcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZFNlYXJjaCB9IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUvY2FjaGUta2V5J1xuaW1wb3J0IHtcbiAgQWN0aW9uRGlkTm90UmV2YWxpZGF0ZSxcbiAgQWN0aW9uRGlkUmV2YWxpZGF0ZUR5bmFtaWNPbmx5LFxuICBBY3Rpb25EaWRSZXZhbGlkYXRlU3RhdGljQW5kRHluYW1pYyxcbiAgdHlwZSBBY3Rpb25SZXZhbGlkYXRpb25LaW5kLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FjdGlvbi1yZXZhbGlkYXRpb24ta2luZCdcbmltcG9ydCB7IGlzRXh0ZXJuYWxVUkwgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyLXV0aWxzJ1xuaW1wb3J0IHsgRnJlc2huZXNzUG9saWN5IH0gZnJvbSAnLi4vcHByLW5hdmlnYXRpb25zJ1xuXG5jb25zdCBjcmVhdGVGcm9tRmV0Y2ggPVxuICBjcmVhdGVGcm9tRmV0Y2hCcm93c2VyIGFzICh0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmJyb3dzZXInKSlbJ2NyZWF0ZUZyb21GZXRjaCddXG5cbmxldCBjcmVhdGVEZWJ1Z0NoYW5uZWw6XG4gIHwgdHlwZW9mIGltcG9ydCgnLi4vLi4vLi4vZGV2L2RlYnVnLWNoYW5uZWwnKS5jcmVhdGVEZWJ1Z0NoYW5uZWxcbiAgfCB1bmRlZmluZWRcblxuaWYgKFxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ERUJVR19DSEFOTkVMXG4pIHtcbiAgY3JlYXRlRGVidWdDaGFubmVsID0gKFxuICAgIHJlcXVpcmUoJy4uLy4uLy4uL2Rldi9kZWJ1Zy1jaGFubmVsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vLi4vZGV2L2RlYnVnLWNoYW5uZWwnKVxuICApLmNyZWF0ZURlYnVnQ2hhbm5lbFxufVxuXG4vLyBUT0RPOiBSZWZhY3RvciB0byBiZSBhIGRpc2NyaW1pbmF0ZWQgdW5pb24uIE9yIGp1c3QgZ2V0IHJpZCBvZiBpdDtcbi8vIGZldGNoU2VydmVyQWN0aW9uIG9ubHkgaGFzIG9uZSBjYWxsZXIsIG5vIHJlYXNvbiB0aGlzIGludGVybWVkaWF0ZSB0eXBlIGhhc1xuLy8gdG8gZXhpc3QuXG50eXBlIEZldGNoU2VydmVyQWN0aW9uUmVzdWx0ID0ge1xuICByZWRpcmVjdExvY2F0aW9uOiBVUkwgfCB1bmRlZmluZWRcbiAgcmVkaXJlY3RUeXBlOiBSZWRpcmVjdFR5cGUgfCB1bmRlZmluZWRcbiAgcmV2YWxpZGF0aW9uS2luZDogQWN0aW9uUmV2YWxpZGF0aW9uS2luZFxuICBhY3Rpb25SZXN1bHQ6IEFjdGlvblJlc3VsdCB8IHVuZGVmaW5lZFxuICBhY3Rpb25GbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGFjdGlvbkZsaWdodERhdGFSZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaCB8IHVuZGVmaW5lZFxuICBhY3Rpb25GbGlnaHREYXRhQ291bGRCZUludGVyY2VwdGVkOiBib29sZWFuIHwgdW5kZWZpbmVkXG4gIGlzUHJlcmVuZGVyOiBib29sZWFuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIG5leHRVcmw6IFJlYWRvbmx5UmVkdWNlclN0YXRlWyduZXh0VXJsJ10sXG4gIHsgYWN0aW9uSWQsIGFjdGlvbkFyZ3MgfTogU2VydmVyQWN0aW9uQWN0aW9uXG4pOiBQcm9taXNlPEZldGNoU2VydmVyQWN0aW9uUmVzdWx0PiB7XG4gIGNvbnN0IHRlbXBvcmFyeVJlZmVyZW5jZXMgPSBjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQoKVxuICBjb25zdCBpbmZvID0gZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQoYWN0aW9uSWQpXG5cbiAgLy8gVE9ETzogQ3VycmVudGx5LCB3ZSdyZSBvbmx5IG9taXR0aW5nIHVudXNlZCBhcmdzIGZvciB0aGUgZXhwZXJpbWVudGFsIFwidXNlXG4gIC8vIGNhY2hlXCIgZnVuY3Rpb25zLiBPbmNlIHRoZSBzZXJ2ZXIgcmVmZXJlbmNlIGluZm8gYnl0ZSBmZWF0dXJlIGlzIHN0YWJsZSwgd2VcbiAgLy8gc2hvdWxkIGFwcGx5IHRoaXMgdG8gc2VydmVyIGFjdGlvbnMgYXMgd2VsbC5cbiAgY29uc3QgdXNlZEFyZ3MgPVxuICAgIGluZm8udHlwZSA9PT0gJ3VzZS1jYWNoZScgPyBvbWl0VW51c2VkQXJncyhhY3Rpb25BcmdzLCBpbmZvKSA6IGFjdGlvbkFyZ3NcblxuICBjb25zdCBib2R5ID0gYXdhaXQgZW5jb2RlUmVwbHkodXNlZEFyZ3MsIHsgdGVtcG9yYXJ5UmVmZXJlbmNlcyB9KVxuXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgQWNjZXB0OiBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgICBbQUNUSU9OX0hFQURFUl06IGFjdGlvbklkLFxuICAgIFtORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl06IHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QoXG4gICAgICBzdGF0ZS50cmVlXG4gICAgKSxcbiAgfVxuXG4gIGNvbnN0IGRlcGxveW1lbnRJZCA9IGdldERlcGxveW1lbnRJZCgpXG4gIGlmIChkZXBsb3ltZW50SWQpIHtcbiAgICBoZWFkZXJzWyd4LWRlcGxveW1lbnQtaWQnXSA9IGRlcGxveW1lbnRJZFxuICB9XG5cbiAgaWYgKG5leHRVcmwpIHtcbiAgICBoZWFkZXJzW05FWFRfVVJMXSA9IG5leHRVcmxcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHNlbGYuX19uZXh0X3IpIHtcbiAgICAgIGhlYWRlcnNbTkVYVF9IVE1MX1JFUVVFU1RfSURfSEVBREVSXSA9IHNlbGYuX19uZXh0X3JcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgcmVxdWVzdCBJRCBmb3IgdGhlIHNlcnZlciBhY3Rpb24gcmVxdWVzdC4gVGhlIHNlcnZlciB1c2VzXG4gICAgLy8gdGhpcyB0byB0YWcgZGVidWcgaW5mb3JtYXRpb24gc2VudCB2aWEgV2ViU29ja2V0IHRvIHRoZSBjbGllbnQsIHdoaWNoXG4gICAgLy8gdGhlbiByb3V0ZXMgdGhvc2UgY2h1bmtzIHRvIHRoZSBkZWJ1ZyBjaGFubmVsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIElELlxuICAgIGhlYWRlcnNbTkVYVF9SRVFVRVNUX0lEX0hFQURFUl0gPSBjcnlwdG9cbiAgICAgIC5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXVxuICAgICAgLnRvU3RyaW5nKDE2KVxuICB9XG5cbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goc3RhdGUuY2Fub25pY2FsVXJsLCB7IG1ldGhvZDogJ1BPU1QnLCBoZWFkZXJzLCBib2R5IH0pXG5cbiAgLy8gSGFuZGxlIHNlcnZlciBhY3Rpb25zIHRoYXQgdGhlIHNlcnZlciBkaWRuJ3QgcmVjb2duaXplLlxuICBjb25zdCB1bnJlY29nbml6ZWRBY3Rpb25IZWFkZXIgPSByZXMuaGVhZGVycy5nZXQoTkVYVF9BQ1RJT05fTk9UX0ZPVU5EX0hFQURFUilcbiAgaWYgKHVucmVjb2duaXplZEFjdGlvbkhlYWRlciA9PT0gJzEnKSB7XG4gICAgdGhyb3cgbmV3IFVucmVjb2duaXplZEFjdGlvbkVycm9yKFxuICAgICAgYFNlcnZlciBBY3Rpb24gXCIke2FjdGlvbklkfVwiIHdhcyBub3QgZm91bmQgb24gdGhlIHNlcnZlci4gXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9mYWlsZWQtdG8tZmluZC1zZXJ2ZXItYWN0aW9uYFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlZGlyZWN0SGVhZGVyID0gcmVzLmhlYWRlcnMuZ2V0KCd4LWFjdGlvbi1yZWRpcmVjdCcpXG4gIGNvbnN0IFtsb2NhdGlvbiwgX3JlZGlyZWN0VHlwZV0gPSByZWRpcmVjdEhlYWRlcj8uc3BsaXQoJzsnKSB8fCBbXVxuICBsZXQgcmVkaXJlY3RUeXBlOiBSZWRpcmVjdFR5cGUgfCB1bmRlZmluZWRcbiAgc3dpdGNoIChfcmVkaXJlY3RUeXBlKSB7XG4gICAgY2FzZSAncHVzaCc6XG4gICAgICByZWRpcmVjdFR5cGUgPSBSZWRpcmVjdFR5cGUucHVzaFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBsYWNlJzpcbiAgICAgIHJlZGlyZWN0VHlwZSA9IFJlZGlyZWN0VHlwZS5yZXBsYWNlXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWRpcmVjdFR5cGUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IGlzUHJlcmVuZGVyID0gISFyZXMuaGVhZGVycy5nZXQoTkVYVF9JU19QUkVSRU5ERVJfSEVBREVSKVxuXG4gIGxldCByZXZhbGlkYXRpb25LaW5kOiBBY3Rpb25SZXZhbGlkYXRpb25LaW5kID0gQWN0aW9uRGlkTm90UmV2YWxpZGF0ZVxuICB0cnkge1xuICAgIGNvbnN0IHJldmFsaWRhdGlvbkhlYWRlciA9IHJlcy5oZWFkZXJzLmdldCgneC1hY3Rpb24tcmV2YWxpZGF0ZWQnKVxuICAgIGlmIChyZXZhbGlkYXRpb25IZWFkZXIpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEtpbmQgPSBKU09OLnBhcnNlKHJldmFsaWRhdGlvbkhlYWRlcilcbiAgICAgIGlmIChcbiAgICAgICAgcGFyc2VkS2luZCA9PT0gQWN0aW9uRGlkUmV2YWxpZGF0ZVN0YXRpY0FuZER5bmFtaWMgfHxcbiAgICAgICAgcGFyc2VkS2luZCA9PT0gQWN0aW9uRGlkUmV2YWxpZGF0ZUR5bmFtaWNPbmx5XG4gICAgICApIHtcbiAgICAgICAgcmV2YWxpZGF0aW9uS2luZCA9IHBhcnNlZEtpbmRcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge31cblxuICBjb25zdCByZWRpcmVjdExvY2F0aW9uID0gbG9jYXRpb25cbiAgICA/IGFzc2lnbkxvY2F0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbmV3IFVSTChzdGF0ZS5jYW5vbmljYWxVcmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkXG5cbiAgY29uc3QgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpXG4gIGNvbnN0IGlzUnNjUmVzcG9uc2UgPSAhIShcbiAgICBjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5zdGFydHNXaXRoKFJTQ19DT05URU5UX1RZUEVfSEVBREVSKVxuICApXG5cbiAgLy8gSGFuZGxlIGludmFsaWQgc2VydmVyIGFjdGlvbiByZXNwb25zZXMuXG4gIC8vIEEgdmFsaWQgcmVzcG9uc2UgbXVzdCBoYXZlIGBjb250ZW50LXR5cGU6IHRleHQveC1jb21wb25lbnRgLCB1bmxlc3MgaXQncyBhbiBleHRlcm5hbCByZWRpcmVjdC5cbiAgLy8gKGV4dGVybmFsIHJlZGlyZWN0cyBoYXZlIGFuICd4LWFjdGlvbi1yZWRpcmVjdCcgaGVhZGVyLCBidXQgdGhlIGJvZHkgaXMgYW4gZW1wdHkgJ3RleHQvcGxhaW4nKVxuICBpZiAoIWlzUnNjUmVzcG9uc2UgJiYgIXJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAvLyBUaGUgc2VydmVyIGNhbiByZXNwb25kIHdpdGggYSB0ZXh0L3BsYWluIGVycm9yIG1lc3NhZ2UsIGJ1dCB3ZSdsbCBmYWxsYmFjayB0byBzb21ldGhpbmcgZ2VuZXJpY1xuICAgIC8vIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgIHJlcy5zdGF0dXMgPj0gNDAwICYmIGNvbnRlbnRUeXBlID09PSAndGV4dC9wbGFpbidcbiAgICAgICAgPyBhd2FpdCByZXMudGV4dCgpXG4gICAgICAgIDogJ0FuIHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4nXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGxldCBhY3Rpb25SZXN1bHQ6IEZldGNoU2VydmVyQWN0aW9uUmVzdWx0WydhY3Rpb25SZXN1bHQnXVxuICBsZXQgYWN0aW9uRmxpZ2h0RGF0YTogRmV0Y2hTZXJ2ZXJBY3Rpb25SZXN1bHRbJ2FjdGlvbkZsaWdodERhdGEnXVxuICBsZXQgYWN0aW9uRmxpZ2h0RGF0YVJlbmRlcmVkU2VhcmNoOiBGZXRjaFNlcnZlckFjdGlvblJlc3VsdFsnYWN0aW9uRmxpZ2h0RGF0YVJlbmRlcmVkU2VhcmNoJ11cbiAgbGV0IGFjdGlvbkZsaWdodERhdGFDb3VsZEJlSW50ZXJjZXB0ZWQ6IEZldGNoU2VydmVyQWN0aW9uUmVzdWx0WydhY3Rpb25GbGlnaHREYXRhQ291bGRCZUludGVyY2VwdGVkJ11cblxuICBpZiAoaXNSc2NSZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlOiBBY3Rpb25GbGlnaHRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZUZyb21GZXRjaChcbiAgICAgIFByb21pc2UucmVzb2x2ZShyZXMpLFxuICAgICAge1xuICAgICAgICBjYWxsU2VydmVyLFxuICAgICAgICBmaW5kU291cmNlTWFwVVJMLFxuICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLFxuICAgICAgICBkZWJ1Z0NoYW5uZWw6IGNyZWF0ZURlYnVnQ2hhbm5lbCAmJiBjcmVhdGVEZWJ1Z0NoYW5uZWwoaGVhZGVycyksXG4gICAgICB9XG4gICAgKVxuXG4gICAgLy8gQW4gaW50ZXJuYWwgcmVkaXJlY3QgY2FuIHNlbmQgYW4gUlNDIHJlc3BvbnNlLCBidXQgZG9lcyBub3QgaGF2ZSBhIHVzZWZ1bCBgYWN0aW9uUmVzdWx0YC5cbiAgICBhY3Rpb25SZXN1bHQgPSByZWRpcmVjdExvY2F0aW9uID8gdW5kZWZpbmVkIDogcmVzcG9uc2UuYVxuICAgIGNvbnN0IG1heWJlRmxpZ2h0RGF0YSA9IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZilcbiAgICBpZiAobWF5YmVGbGlnaHREYXRhICE9PSAnJykge1xuICAgICAgYWN0aW9uRmxpZ2h0RGF0YSA9IG1heWJlRmxpZ2h0RGF0YVxuICAgICAgYWN0aW9uRmxpZ2h0RGF0YVJlbmRlcmVkU2VhcmNoID0gcmVzcG9uc2UucSBhcyBOb3JtYWxpemVkU2VhcmNoXG4gICAgICBhY3Rpb25GbGlnaHREYXRhQ291bGRCZUludGVyY2VwdGVkID0gcmVzcG9uc2UuaVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBBbiBleHRlcm5hbCByZWRpcmVjdCBkb2Vzbid0IGNvbnRhaW4gUlNDIGRhdGEuXG4gICAgYWN0aW9uUmVzdWx0ID0gdW5kZWZpbmVkXG4gICAgYWN0aW9uRmxpZ2h0RGF0YSA9IHVuZGVmaW5lZFxuICAgIGFjdGlvbkZsaWdodERhdGFSZW5kZXJlZFNlYXJjaCA9IHVuZGVmaW5lZFxuICAgIGFjdGlvbkZsaWdodERhdGFDb3VsZEJlSW50ZXJjZXB0ZWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWN0aW9uUmVzdWx0LFxuICAgIGFjdGlvbkZsaWdodERhdGEsXG4gICAgYWN0aW9uRmxpZ2h0RGF0YVJlbmRlcmVkU2VhcmNoLFxuICAgIGFjdGlvbkZsaWdodERhdGFDb3VsZEJlSW50ZXJjZXB0ZWQsXG4gICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICByZWRpcmVjdFR5cGUsXG4gICAgcmV2YWxpZGF0aW9uS2luZCxcbiAgICBpc1ByZXJlbmRlcixcbiAgfVxufVxuXG4vKlxuICogVGhpcyByZWR1Y2VyIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIHRoZSBzZXJ2ZXIgYWN0aW9uIGFuZCBwcm9jZXNzaW5nIGFueSBzaWRlLWVmZmVjdHMgZnJvbSB0aGUgc2VydmVyIGFjdGlvbi5cbiAqIEl0IGRvZXMgbm90IG11dGF0ZSB0aGUgc3RhdGUgYnkgaXRzZWxmIGJ1dCByYXRoZXIgZGVsZWdhdGVzIHRvIG90aGVyIHJlZHVjZXJzIHRvIGRvIHRoZSBhY3R1YWwgbXV0YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJ2ZXJBY3Rpb25SZWR1Y2VyKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogU2VydmVyQWN0aW9uQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gYWN0aW9uXG4gIGNvbnN0IG11dGFibGU6IFNlcnZlckFjdGlvbk11dGFibGUgPSB7fVxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIC8vIG9ubHkgcGFzcyBhbG9uZyB0aGUgYG5leHRVcmxgIHBhcmFtICh1c2VkIGZvciBpbnRlcmNlcHRpb24gcm91dGVzKSBpZiB0aGUgY3VycmVudCByb3V0ZSB3YXMgaW50ZXJjZXB0ZWQuXG4gIC8vIElmIHRoZSByb3V0ZSBoYXMgYmVlbiBpbnRlcmNlcHRlZCwgdGhlIGFjdGlvbiBzaG91bGQgYmUgYXMgd2VsbC5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBzZXJ2ZXIgYWN0aW9uIG1pZ2h0IGJlIGludGVyY2VwdGVkIHdpdGggdGhlIHdyb25nIGFjdGlvbiBpZFxuICAvLyAoaWUsIG9uZSB0aGF0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGludGVyY2VwdGVkIHJvdXRlKVxuICBjb25zdCBuZXh0VXJsID1cbiAgICAvLyBXZSBhbHdheXMgc2VuZCB0aGUgbGFzdCBuZXh0LXVybCwgbm90IHRoZSBjdXJyZW50IHdoZW5cbiAgICAvLyBwZXJmb3JtaW5nIGEgZHluYW1pYyByZXF1ZXN0LiBUaGlzIGlzIGJlY2F1c2Ugd2UgdXBkYXRlXG4gICAgLy8gdGhlIG5leHQtdXJsIGFmdGVyIGEgbmF2aWdhdGlvbiwgYnV0IHdlIHdhbnQgdGhlIHNhbWVcbiAgICAvLyBpbnRlcmNlcHRpb24gcm91dGUgdG8gYmUgbWF0Y2hlZCB0aGF0IHVzZWQgdGhlIGxhc3RcbiAgICAvLyBuZXh0LXVybC5cbiAgICAoc3RhdGUucHJldmlvdXNOZXh0VXJsIHx8IHN0YXRlLm5leHRVcmwpICYmXG4gICAgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG4gICAgICA/IHN0YXRlLnByZXZpb3VzTmV4dFVybCB8fCBzdGF0ZS5uZXh0VXJsXG4gICAgICA6IG51bGxcblxuICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc3RhdGUsIG5leHRVcmwsIGFjdGlvbikudGhlbihcbiAgICBhc3luYyAoe1xuICAgICAgcmV2YWxpZGF0aW9uS2luZCxcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGFjdGlvbkZsaWdodERhdGE6IGZsaWdodERhdGEsXG4gICAgICBhY3Rpb25GbGlnaHREYXRhUmVuZGVyZWRTZWFyY2g6IGZsaWdodERhdGFSZW5kZXJlZFNlYXJjaCxcbiAgICAgIGFjdGlvbkZsaWdodERhdGFDb3VsZEJlSW50ZXJjZXB0ZWQ6IGZsaWdodERhdGFDb3VsZEJlSW50ZXJjZXB0ZWQsXG4gICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgcmVkaXJlY3RUeXBlLFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChyZXZhbGlkYXRpb25LaW5kICE9PSBBY3Rpb25EaWROb3RSZXZhbGlkYXRlKSB7XG4gICAgICAgIC8vIFN0b3JlIHdoZXRoZXIgdGhpcyBhY3Rpb24gdHJpZ2dlcmVkIGFueSByZXZhbGlkYXRpb25cbiAgICAgICAgLy8gVGhlIGFjdGlvbiBxdWV1ZSB3aWxsIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIHBvdGVudGlhbGx5XG4gICAgICAgIC8vIHRyaWdnZXIgYSByZWZyZXNoIGFjdGlvbiBpZiB0aGUgYWN0aW9uIHdhcyBkaXNjYXJkZWRcbiAgICAgICAgLy8gKGllLCBkdWUgdG8gYSBuYXZpZ2F0aW9uLCBiZWZvcmUgdGhlIGFjdGlvbiBjb21wbGV0ZWQpXG4gICAgICAgIGFjdGlvbi5kaWRSZXZhbGlkYXRlID0gdHJ1ZVxuXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHJldmFsaWRhdGlvbiwgZXZpY3QgdGhlIGVudGlyZSBwcmVmZXRjaCBjYWNoZS5cbiAgICAgICAgLy8gVE9ETzogRXZpY3Qgb25seSBzZWdtZW50cyB3aXRoIG1hdGNoaW5nIHRhZ3MgYW5kL29yIHBhdGhzLlxuICAgICAgICBpZiAocmV2YWxpZGF0aW9uS2luZCA9PT0gQWN0aW9uRGlkUmV2YWxpZGF0ZVN0YXRpY0FuZER5bmFtaWMpIHtcbiAgICAgICAgICByZXZhbGlkYXRlRW50aXJlQ2FjaGUobmV4dFVybCwgc3RhdGUudHJlZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwZW5kaW5nUHVzaCA9IHJlZGlyZWN0VHlwZSAhPT0gUmVkaXJlY3RUeXBlLnJlcGxhY2VcbiAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaFxuICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoXG5cbiAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiB0cmlnZ2VyZWQgYSByZWRpcmVjdCwgdGhlIGFjdGlvbiBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aFxuICAgICAgICAvLyBhIHJlZGlyZWN0IHNvIHRoYXQgaXQncyBoYW5kbGVkIGJ5IFJlZGlyZWN0Qm91bmRhcnkgYXMgd2Ugd29uJ3QgaGF2ZSBhIHZhbGlkXG4gICAgICAgIC8vIGFjdGlvbiByZXN1bHQgdG8gcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRoLiBUaGlzIHdpbGwgZWZmZWN0aXZlbHkgcmVzZXQgdGhlIHN0YXRlIG9mXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgdGhhdCBjYWxsZWQgdGhlIGFjdGlvbiBhcyB0aGUgZXJyb3IgYm91bmRhcnkgd2lsbCByZW1vdW50IHRoZSB0cmVlLlxuICAgICAgICAvLyBUaGUgc3RhdHVzIGNvZGUgZG9lc24ndCBtYXR0ZXIgaGVyZSBhcyB0aGUgYWN0aW9uIGhhbmRsZXIgd2lsbCBoYXZlIGFscmVhZHkgc2VudFxuICAgICAgICAvLyBhIHJlc3BvbnNlIHdpdGggdGhlIGNvcnJlY3Qgc3RhdHVzIGNvZGUuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkUmVkaXJlY3RUeXBlID0gcmVkaXJlY3RUeXBlIHx8IFJlZGlyZWN0VHlwZS5wdXNoXG5cbiAgICAgICAgaWYgKGlzRXh0ZXJuYWxVUkwocmVkaXJlY3RMb2NhdGlvbikpIHtcbiAgICAgICAgICAvLyBFeHRlcm5hbCByZWRpcmVjdC4gVHJpZ2dlcnMgYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICAgICAgY29uc3QgcmVkaXJlY3RIcmVmID0gcmVkaXJlY3RMb2NhdGlvbi5ocmVmXG4gICAgICAgICAgY29uc3QgcmVkaXJlY3RFcnJvciA9IGNyZWF0ZVJlZGlyZWN0RXJyb3JGb3JBY3Rpb24oXG4gICAgICAgICAgICByZWRpcmVjdEhyZWYsXG4gICAgICAgICAgICByZXNvbHZlZFJlZGlyZWN0VHlwZVxuICAgICAgICAgIClcbiAgICAgICAgICByZWplY3QocmVkaXJlY3RFcnJvcilcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIHJlZGlyZWN0SHJlZiwgcGVuZGluZ1B1c2gpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW50ZXJuYWwgcmVkaXJlY3QuIFRyaWdnZXJzIGFuIFNQQSBuYXZpZ2F0aW9uLlxuICAgICAgICAgIGNvbnN0IHJlZGlyZWN0V2l0aEJhc2VwYXRoID0gY3JlYXRlSHJlZkZyb21VcmwoXG4gICAgICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgcmVkaXJlY3RIcmVmID0gaGFzQmFzZVBhdGgocmVkaXJlY3RXaXRoQmFzZXBhdGgpXG4gICAgICAgICAgICA/IHJlbW92ZUJhc2VQYXRoKHJlZGlyZWN0V2l0aEJhc2VwYXRoKVxuICAgICAgICAgICAgOiByZWRpcmVjdFdpdGhCYXNlcGF0aFxuICAgICAgICAgIGNvbnN0IHJlZGlyZWN0RXJyb3IgPSBjcmVhdGVSZWRpcmVjdEVycm9yRm9yQWN0aW9uKFxuICAgICAgICAgICAgcmVkaXJlY3RIcmVmLFxuICAgICAgICAgICAgcmVzb2x2ZWRSZWRpcmVjdFR5cGVcbiAgICAgICAgICApXG4gICAgICAgICAgcmVqZWN0KHJlZGlyZWN0RXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVkaXJlY3QsIHJlc29sdmUgdGhlIGFjdGlvbiB3aXRoIHRoZSByZXN1bHQuXG4gICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gYmFpbCBvdXQgd2l0aG91dCB1cGRhdGluZyBhbnkgc3RhdGUuXG4gICAgICBpZiAoXG4gICAgICAgIC8vIERpZCB0aGUgYWN0aW9uIHRyaWdnZXIgYSByZWRpcmVjdD9cbiAgICAgICAgcmVkaXJlY3RMb2NhdGlvbiA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIC8vIERpZCB0aGUgYWN0aW9uIHJldmFsaWRhdGUgYW55IGRhdGE/XG4gICAgICAgIHJldmFsaWRhdGlvbktpbmQgPT09IEFjdGlvbkRpZE5vdFJldmFsaWRhdGUgJiZcbiAgICAgICAgLy8gRGlkIHRoZSBzZXJ2ZXIgcmVuZGVyIG5ldyBkYXRhP1xuICAgICAgICBmbGlnaHREYXRhID09PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICAvLyBUaGUgYWN0aW9uIGRpZCBub3QgdHJpZ2dlciBhbnkgcmV2YWxpZGF0aW9ucyBvciByZWRpcmVjdHMuIE5vXG4gICAgICAgIC8vIG5hdmlnYXRpb24gaXMgcmVxdWlyZWQuXG4gICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgfVxuXG4gICAgICBpZiAoZmxpZ2h0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlZGlyZWN0TG9jYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBUaGUgc2VydmVyIHJlZGlyZWN0ZWQsIGJ1dCBkaWQgbm90IHNlbmQgYW55IEZsaWdodCBkYXRhLiBUaGlzIGltcGxpZXNcbiAgICAgICAgLy8gYW4gZXh0ZXJuYWwgcmVkaXJlY3QuXG4gICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCByZWZhY3RvciB0aGUgYWN0aW9uIHJlc3BvbnNlIHR5cGUgdG8gYmUgbW9yZSBleHBsaWNpdFxuICAgICAgICAvLyBhYm91dCB0aGUgdmFyaW91cyByZXNwb25zZSB0eXBlcy5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgcmVkaXJlY3RMb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIHBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBJZiB0aGUgZmxpZ2h0IGRhdGEgaXMganVzdCBhIHN0cmluZywgc29tZXRoaW5nIGVhcmxpZXIgaW4gdGhlXG4gICAgICAgIC8vIHJlc3BvbnNlIGhhbmRsaW5nIHRyaWdnZXJlZCBhbiBleHRlcm5hbCByZWRpcmVjdC5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBwZW5kaW5nUHVzaClcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGFjdGlvbiB0cmlnZ2VyZWQgYSBuYXZpZ2F0aW9uIOKAlCBlaXRoZXIgYSByZWRpcmVjdCwgYSByZXZhbGlkYXRpb24sXG4gICAgICAvLyBvciBib3RoLlxuXG4gICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gcmVkaXJlY3QsIHRoZW4gdGhlIHRhcmdldCBVUkwgaXMgdGhlIHNhbWUgYXMgdGhlXG4gICAgICAvLyBjdXJyZW50IFVSTC5cbiAgICAgIGNvbnN0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHN0YXRlLmNhbm9uaWNhbFVybCwgbG9jYXRpb24ub3JpZ2luKVxuICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPVxuICAgICAgICByZWRpcmVjdExvY2F0aW9uICE9PSB1bmRlZmluZWQgPyByZWRpcmVjdExvY2F0aW9uIDogY3VycmVudFVybFxuICAgICAgY29uc3QgY3VycmVudEZsaWdodFJvdXRlclN0YXRlID0gc3RhdGUudHJlZVxuICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gdHJ1ZVxuXG4gICAgICAvLyBJZiB0aGUgYWN0aW9uIHRyaWdnZXJlZCBhIHJldmFsaWRhdGlvbiBvZiB0aGUgY2FjaGUsIHdlIHNob3VsZCBhbHNvXG4gICAgICAvLyByZWZyZXNoIGFsbCB0aGUgZHluYW1pYyBkYXRhLlxuICAgICAgY29uc3QgZnJlc2huZXNzUG9saWN5ID1cbiAgICAgICAgcmV2YWxpZGF0aW9uS2luZCA9PT0gQWN0aW9uRGlkTm90UmV2YWxpZGF0ZVxuICAgICAgICAgID8gRnJlc2huZXNzUG9saWN5LkRlZmF1bHRcbiAgICAgICAgICA6IEZyZXNobmVzc1BvbGljeS5SZWZyZXNoQWxsXG5cbiAgICAgIC8vIFRoZSBzZXJ2ZXIgbWF5IGhhdmUgc2VudCBiYWNrIG5ldyBkYXRhLiBJZiBzbywgd2Ugd2lsbCBwZXJmb3JtIGFcbiAgICAgIC8vIFwic2VlZGVkXCIgbmF2aWdhdGlvbiB0aGF0IHVzZXMgdGhlIGRhdGEgZnJvbSB0aGUgcmVzcG9uc2UuXG4gICAgICBpZiAoZmxpZ2h0RGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhID0gZmxpZ2h0RGF0YVswXVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbm9ybWFsaXplZEZsaWdodERhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIC8vIFRPRE86IEN1cnJlbnRseSB0aGUgc2VydmVyIGFsd2F5cyByZW5kZXJzIGZyb20gdGhlIHJvb3QgaW5cbiAgICAgICAgICAvLyByZXNwb25zZSB0byBhIFNlcnZlciBBY3Rpb24uIEluIHRoZSBjYXNlIG9mIGEgbm9ybWFsIHJlZGlyZWN0XG4gICAgICAgICAgLy8gd2l0aCBubyByZXZhbGlkYXRpb24sIGl0IHNob3VsZCBza2lwIG92ZXIgdGhlIHNoYXJlZCBsYXlvdXRzLlxuICAgICAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhLmlzUm9vdFJlbmRlciAmJlxuICAgICAgICAgIGZsaWdodERhdGFSZW5kZXJlZFNlYXJjaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgZmxpZ2h0RGF0YUNvdWxkQmVJbnRlcmNlcHRlZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgc2VudCBiYWNrIG5ldyByb3V0ZSBkYXRhIGFzIHBhcnQgb2YgdGhlIHJlc3BvbnNlLiBXZVxuICAgICAgICAgIC8vIHdpbGwgdXNlIHRoaXMgdG8gcmVuZGVyIHRoZSBuZXcgcGFnZS4gSWYgdGhpcyBoYXBwZW5zIHRvIGJlIG9ubHkgYVxuICAgICAgICAgIC8vIHN1YnNldCBvZiB0aGUgZGF0YSBuZWVkZWQgdG8gcmVuZGVyIHRoZSBuZXcgcGFnZSwgd2UnbGwgaW5pdGlhdGUgYVxuICAgICAgICAgIC8vIG5ldyBmZXRjaCwgbGlrZSB3ZSB3b3VsZCBmb3IgYSBub3JtYWwgbmF2aWdhdGlvbi5cbiAgICAgICAgICBjb25zdCByZWRpcmVjdENhbm9uaWNhbFVybCA9IGNyZWF0ZUhyZWZGcm9tVXJsKHJlZGlyZWN0VXJsKVxuICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb25TZWVkID0ge1xuICAgICAgICAgICAgdHJlZTogbm9ybWFsaXplZEZsaWdodERhdGEudHJlZSxcbiAgICAgICAgICAgIHJlbmRlcmVkU2VhcmNoOiBmbGlnaHREYXRhUmVuZGVyZWRTZWFyY2gsXG4gICAgICAgICAgICBkYXRhOiBub3JtYWxpemVkRmxpZ2h0RGF0YS5zZWVkRGF0YSxcbiAgICAgICAgICAgIGhlYWQ6IG5vcm1hbGl6ZWRGbGlnaHREYXRhLmhlYWQsXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBuYXZpZ2F0ZVRvU2VlZGVkUm91dGUoXG4gICAgICAgICAgICBub3csXG4gICAgICAgICAgICByZWRpcmVjdFVybCxcbiAgICAgICAgICAgIHJlZGlyZWN0Q2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgbmF2aWdhdGlvblNlZWQsXG4gICAgICAgICAgICBjdXJyZW50VXJsLFxuICAgICAgICAgICAgc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICBjdXJyZW50RmxpZ2h0Um91dGVyU3RhdGUsXG4gICAgICAgICAgICBmcmVzaG5lc3NQb2xpY3ksXG4gICAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgICAgc2hvdWxkU2Nyb2xsXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBoYW5kbGVOYXZpZ2F0aW9uUmVzdWx0KFxuICAgICAgICAgICAgcmVkaXJlY3RVcmwsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgICBwZW5kaW5nUHVzaCxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgc2VydmVyIGRpZCBub3Qgc2VuZCBiYWNrIG5ldyBkYXRhLiBXZSdsbCBwZXJmb3JtIGEgcmVndWxhciwgbm9uLVxuICAgICAgLy8gc2VlZGVkIG5hdmlnYXRpb24g4oCUIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIDxMaW5rPiBvciByb3V0ZXIucHVzaCgpLlxuICAgICAgY29uc3QgcmVzdWx0ID0gbmF2aWdhdGVVc2luZ1NlZ21lbnRDYWNoZShcbiAgICAgICAgcmVkaXJlY3RVcmwsXG4gICAgICAgIGN1cnJlbnRVcmwsXG4gICAgICAgIHN0YXRlLmNhY2hlLFxuICAgICAgICBjdXJyZW50RmxpZ2h0Um91dGVyU3RhdGUsXG4gICAgICAgIG5leHRVcmwsXG4gICAgICAgIGZyZXNobmVzc1BvbGljeSxcbiAgICAgICAgc2hvdWxkU2Nyb2xsLFxuICAgICAgICBtdXRhYmxlXG4gICAgICApXG4gICAgICByZXR1cm4gaGFuZGxlTmF2aWdhdGlvblJlc3VsdChcbiAgICAgICAgcmVkaXJlY3RVcmwsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBtdXRhYmxlLFxuICAgICAgICBwZW5kaW5nUHVzaCxcbiAgICAgICAgcmVzdWx0XG4gICAgICApXG4gICAgfSxcbiAgICAoZTogYW55KSA9PiB7XG4gICAgICAvLyBXaGVuIHRoZSBzZXJ2ZXIgYWN0aW9uIGlzIHJlamVjdGVkIHdlIGRvbid0IHVwZGF0ZSB0aGUgc3RhdGUgYW5kIGluc3RlYWQgY2FsbCB0aGUgcmVqZWN0IGhhbmRsZXIgb2YgdGhlIHByb21pc2UuXG4gICAgICByZWplY3QoZSlcblxuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuICApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZGlyZWN0RXJyb3JGb3JBY3Rpb24oXG4gIHJlZGlyZWN0SHJlZjogc3RyaW5nLFxuICByZXNvbHZlZFJlZGlyZWN0VHlwZTogUmVkaXJlY3RUeXBlXG4pIHtcbiAgY29uc3QgcmVkaXJlY3RFcnJvciA9IGdldFJlZGlyZWN0RXJyb3IocmVkaXJlY3RIcmVmLCByZXNvbHZlZFJlZGlyZWN0VHlwZSlcbiAgLy8gV2UgbWFyayB0aGUgZXJyb3IgYXMgaGFuZGxlZCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdGhlIHJlZGlyZWN0IHRvIGJlIHRyaWVkIGxhdGVyIGJ5XG4gIC8vIHRoZSBSZWRpcmVjdEJvdW5kYXJ5LCBpbiBjYXNlIHRoZSB1c2VyIGdvZXMgYmFjayBhbmQgYEFjdGl2aXR5YCB0cmlnZ2VycyB0aGUgcmVkaXJlY3RcbiAgLy8gYWdhaW4sIGFzIGl0J3MgcnVuIHdpdGhpbiBhbiBlZmZlY3QuXG4gIC8vIFdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdGhlIFJlZGlyZWN0Qm91bmRhcnkgdG8gZG8gYSByb3V0ZXIucHVzaCBiZWNhdXNlIHdlIGFscmVhZHlcbiAgLy8gaGF2ZSBhbGwgdGhlIG5lY2Vzc2FyeSBSU0MgZGF0YSB0byByZW5kZXIgdGhlIG5ldyBwYWdlIHdpdGhpbiBhIHNpbmdsZSByb3VuZHRyaXAuXG4gIDsocmVkaXJlY3RFcnJvciBhcyBhbnkpLmhhbmRsZWQgPSB0cnVlXG4gIHJldHVybiByZWRpcmVjdEVycm9yXG59XG4iXSwibmFtZXMiOlsic2VydmVyQWN0aW9uUmVkdWNlciIsImNyZWF0ZUZyb21GZXRjaCIsImNyZWF0ZUZyb21GZXRjaEJyb3dzZXIiLCJjcmVhdGVEZWJ1Z0NoYW5uZWwiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfUkVBQ1RfREVCVUdfQ0hBTk5FTCIsInJlcXVpcmUiLCJmZXRjaFNlcnZlckFjdGlvbiIsInN0YXRlIiwibmV4dFVybCIsImFjdGlvbklkIiwiYWN0aW9uQXJncyIsInRlbXBvcmFyeVJlZmVyZW5jZXMiLCJjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQiLCJpbmZvIiwiZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQiLCJ1c2VkQXJncyIsInR5cGUiLCJvbWl0VW51c2VkQXJncyIsImJvZHkiLCJlbmNvZGVSZXBseSIsImhlYWRlcnMiLCJBY2NlcHQiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIkFDVElPTl9IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsInByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QiLCJ0cmVlIiwiZGVwbG95bWVudElkIiwiZ2V0RGVwbG95bWVudElkIiwiTkVYVF9VUkwiLCJzZWxmIiwiX19uZXh0X3IiLCJORVhUX0hUTUxfUkVRVUVTVF9JRF9IRUFERVIiLCJORVhUX1JFUVVFU1RfSURfSEVBREVSIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiVWludDMyQXJyYXkiLCJ0b1N0cmluZyIsInJlcyIsImZldGNoIiwiY2Fub25pY2FsVXJsIiwibWV0aG9kIiwidW5yZWNvZ25pemVkQWN0aW9uSGVhZGVyIiwiZ2V0IiwiTkVYVF9BQ1RJT05fTk9UX0ZPVU5EX0hFQURFUiIsIlVucmVjb2duaXplZEFjdGlvbkVycm9yIiwicmVkaXJlY3RIZWFkZXIiLCJsb2NhdGlvbiIsIl9yZWRpcmVjdFR5cGUiLCJzcGxpdCIsInJlZGlyZWN0VHlwZSIsIlJlZGlyZWN0VHlwZSIsInB1c2giLCJyZXBsYWNlIiwidW5kZWZpbmVkIiwiaXNQcmVyZW5kZXIiLCJORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIiLCJyZXZhbGlkYXRpb25LaW5kIiwiQWN0aW9uRGlkTm90UmV2YWxpZGF0ZSIsInJldmFsaWRhdGlvbkhlYWRlciIsInBhcnNlZEtpbmQiLCJKU09OIiwicGFyc2UiLCJBY3Rpb25EaWRSZXZhbGlkYXRlU3RhdGljQW5kRHluYW1pYyIsIkFjdGlvbkRpZFJldmFsaWRhdGVEeW5hbWljT25seSIsInJlZGlyZWN0TG9jYXRpb24iLCJhc3NpZ25Mb2NhdGlvbiIsIlVSTCIsIndpbmRvdyIsImhyZWYiLCJjb250ZW50VHlwZSIsImlzUnNjUmVzcG9uc2UiLCJzdGFydHNXaXRoIiwibWVzc2FnZSIsInN0YXR1cyIsInRleHQiLCJFcnJvciIsImFjdGlvblJlc3VsdCIsImFjdGlvbkZsaWdodERhdGEiLCJhY3Rpb25GbGlnaHREYXRhUmVuZGVyZWRTZWFyY2giLCJhY3Rpb25GbGlnaHREYXRhQ291bGRCZUludGVyY2VwdGVkIiwicmVzcG9uc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwiZGVidWdDaGFubmVsIiwiYSIsIm1heWJlRmxpZ2h0RGF0YSIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmIiwicSIsImkiLCJhY3Rpb24iLCJyZWplY3QiLCJtdXRhYmxlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJwcmV2aW91c05leHRVcmwiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsImZsaWdodERhdGFSZW5kZXJlZFNlYXJjaCIsImZsaWdodERhdGFDb3VsZEJlSW50ZXJjZXB0ZWQiLCJkaWRSZXZhbGlkYXRlIiwicmV2YWxpZGF0ZUVudGlyZUNhY2hlIiwicGVuZGluZ1B1c2giLCJwdXNoUmVmIiwicmVzb2x2ZWRSZWRpcmVjdFR5cGUiLCJpc0V4dGVybmFsVVJMIiwicmVkaXJlY3RIcmVmIiwicmVkaXJlY3RFcnJvciIsImNyZWF0ZVJlZGlyZWN0RXJyb3JGb3JBY3Rpb24iLCJoYW5kbGVFeHRlcm5hbFVybCIsInJlZGlyZWN0V2l0aEJhc2VwYXRoIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiY3VycmVudFVybCIsIm9yaWdpbiIsInJlZGlyZWN0VXJsIiwiY3VycmVudEZsaWdodFJvdXRlclN0YXRlIiwic2hvdWxkU2Nyb2xsIiwiZnJlc2huZXNzUG9saWN5IiwiRnJlc2huZXNzUG9saWN5IiwiRGVmYXVsdCIsIlJlZnJlc2hBbGwiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsImlzUm9vdFJlbmRlciIsInJlZGlyZWN0Q2Fub25pY2FsVXJsIiwibmF2aWdhdGlvblNlZWQiLCJyZW5kZXJlZFNlYXJjaCIsImRhdGEiLCJzZWVkRGF0YSIsImhlYWQiLCJub3ciLCJEYXRlIiwicmVzdWx0IiwibmF2aWdhdGVUb1NlZWRlZFJvdXRlIiwiY2FjaGUiLCJoYW5kbGVOYXZpZ2F0aW9uUmVzdWx0IiwibmF2aWdhdGVVc2luZ1NlZ21lbnRDYWNoZSIsImUiLCJnZXRSZWRpcmVjdEVycm9yIiwiaGFuZGxlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/cache.js":
/*!**************************************************************************!*\
  !*** ../node_modules/next/dist/client/components/segment-cache/cache.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    EntryStatus: function() {\n        return EntryStatus;\n    },\n    canNewFetchStrategyProvideMoreContent: function() {\n        return canNewFetchStrategyProvideMoreContent;\n    },\n    convertRouteTreeToFlightRouterState: function() {\n        return convertRouteTreeToFlightRouterState;\n    },\n    createDetachedSegmentCacheEntry: function() {\n        return createDetachedSegmentCacheEntry;\n    },\n    fetchRouteOnCacheMiss: function() {\n        return fetchRouteOnCacheMiss;\n    },\n    fetchSegmentOnCacheMiss: function() {\n        return fetchSegmentOnCacheMiss;\n    },\n    fetchSegmentPrefetchesUsingDynamicRequest: function() {\n        return fetchSegmentPrefetchesUsingDynamicRequest;\n    },\n    getCurrentCacheVersion: function() {\n        return getCurrentCacheVersion;\n    },\n    getStaleTimeMs: function() {\n        return getStaleTimeMs;\n    },\n    overwriteRevalidatingSegmentCacheEntry: function() {\n        return overwriteRevalidatingSegmentCacheEntry;\n    },\n    pingInvalidationListeners: function() {\n        return pingInvalidationListeners;\n    },\n    readOrCreateRevalidatingSegmentEntry: function() {\n        return readOrCreateRevalidatingSegmentEntry;\n    },\n    readOrCreateRouteCacheEntry: function() {\n        return readOrCreateRouteCacheEntry;\n    },\n    readOrCreateSegmentCacheEntry: function() {\n        return readOrCreateSegmentCacheEntry;\n    },\n    readRouteCacheEntry: function() {\n        return readRouteCacheEntry;\n    },\n    readSegmentCacheEntry: function() {\n        return readSegmentCacheEntry;\n    },\n    requestOptimisticRouteCacheEntry: function() {\n        return requestOptimisticRouteCacheEntry;\n    },\n    revalidateEntireCache: function() {\n        return revalidateEntireCache;\n    },\n    upgradeToPendingSegment: function() {\n        return upgradeToPendingSegment;\n    },\n    upsertSegmentEntry: function() {\n        return upsertSegmentEntry;\n    },\n    waitForSegmentCacheEntry: function() {\n        return waitForSegmentCacheEntry;\n    }\n});\nconst _approutertypes = __webpack_require__(/*! ../../../shared/lib/app-router-types */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/app-router-types.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-headers.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ../router-reducer/fetch-server-response */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _scheduler = __webpack_require__(/*! ./scheduler */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/scheduler.js\");\nconst _varypath = __webpack_require__(/*! ./vary-path */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/vary-path.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(app-pages-browser)/../node_modules/next/dist/client/app-build-id.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../router-reducer/create-href-from-url */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _cachekey = __webpack_require__(/*! ./cache-key */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/cache-key.js\");\nconst _routeparams = __webpack_require__(/*! ../../route-params */ \"(app-pages-browser)/../node_modules/next/dist/client/route-params.js\");\nconst _cachemap = __webpack_require__(/*! ./cache-map */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/cache-map.js\");\nconst _segmentvalueencoding = __webpack_require__(/*! ../../../shared/lib/segment-cache/segment-value-encoding */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/../node_modules/next/dist/client/flight-data-helpers.js\");\nconst _navigatereducer = __webpack_require__(/*! ../router-reducer/reducers/navigate-reducer */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _links = __webpack_require__(/*! ../links */ \"(app-pages-browser)/../node_modules/next/dist/client/components/links.js\");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/segment.js\");\nconst _types = __webpack_require__(/*! ./types */ \"(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/types.js\");\nconst _promisewithresolvers = __webpack_require__(/*! ../../../shared/lib/promise-with-resolvers */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/promise-with-resolvers.js\");\nfunction getStaleTimeMs(staleTimeSeconds) {\n    return Math.max(staleTimeSeconds, 30) * 1000;\n}\nvar EntryStatus = /*#__PURE__*/ function(EntryStatus) {\n    EntryStatus[EntryStatus[\"Empty\"] = 0] = \"Empty\";\n    EntryStatus[EntryStatus[\"Pending\"] = 1] = \"Pending\";\n    EntryStatus[EntryStatus[\"Fulfilled\"] = 2] = \"Fulfilled\";\n    EntryStatus[EntryStatus[\"Rejected\"] = 3] = \"Rejected\";\n    return EntryStatus;\n}({});\nconst isOutputExportMode =  false && 0;\nconst MetadataOnlyRequestTree = [\n    '',\n    {},\n    null,\n    'metadata-only'\n];\nlet routeCacheMap = (0, _cachemap.createCacheMap)();\nlet segmentCacheMap = (0, _cachemap.createCacheMap)();\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners = null;\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0;\nfunction getCurrentCacheVersion() {\n    return currentCacheVersion;\n}\nfunction revalidateEntireCache(nextUrl, tree) {\n    // Increment the current cache version. This does not eagerly evict anything\n    // from the cache, but because all the entries are versioned, and we check\n    // the version when reading from the cache, this effectively causes all\n    // entries to be evicted lazily. We do it lazily because in the future,\n    // actions like revalidateTag or refresh will not evict the entire cache,\n    // but rather some subset of the entries.\n    currentCacheVersion++;\n    // Start a cooldown before re-prefetching to allow CDN cache propagation.\n    (0, _scheduler.startRevalidationCooldown)();\n    // Prefetch all the currently visible links again, to re-fill the cache.\n    (0, _links.pingVisibleLinks)(nextUrl, tree);\n    // Similarly, notify all invalidation listeners (i.e. those passed to\n    // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n    // if needed.\n    pingInvalidationListeners(nextUrl, tree);\n}\nfunction attachInvalidationListener(task) {\n    // This function is called whenever a prefetch task reads a cache entry. If\n    // the task has an onInvalidate function associated with it  i.e. the one\n    // optionally passed to router.prefetch(onInvalidate)  then we attach that\n    // listener to the every cache entry that the task reads. Then, if an entry\n    // is invalidated, we call the function.\n    if (task.onInvalidate !== null) {\n        if (invalidationListeners === null) {\n            invalidationListeners = new Set([\n                task\n            ]);\n        } else {\n            invalidationListeners.add(task);\n        }\n    }\n}\nfunction notifyInvalidationListener(task) {\n    const onInvalidate = task.onInvalidate;\n    if (onInvalidate !== null) {\n        // Clear the callback from the task object to guarantee it's not called more\n        // than once.\n        task.onInvalidate = null;\n        // This is a user-space function, so we must wrap in try/catch.\n        try {\n            onInvalidate();\n        } catch (error) {\n            if (typeof reportError === 'function') {\n                reportError(error);\n            } else {\n                console.error(error);\n            }\n        }\n    }\n}\nfunction pingInvalidationListeners(nextUrl, tree) {\n    // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    if (invalidationListeners !== null) {\n        const tasks = invalidationListeners;\n        invalidationListeners = null;\n        for (const task of tasks){\n            if ((0, _scheduler.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n                notifyInvalidationListener(task);\n            }\n        }\n    }\n}\nfunction readRouteCacheEntry(now, key) {\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), routeCacheMap, varyPath, isRevalidation);\n}\nfunction readSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = false;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction readRevalidatingSegmentCacheEntry(now, varyPath) {\n    const isRevalidation = true;\n    return (0, _cachemap.getFromCacheMap)(now, getCurrentCacheVersion(), segmentCacheMap, varyPath, isRevalidation);\n}\nfunction waitForSegmentCacheEntry(pendingEntry) {\n    // Because the entry is pending, there's already a in-progress request.\n    // Attach a promise to the entry that will resolve when the server responds.\n    let promiseWithResolvers = pendingEntry.promise;\n    if (promiseWithResolvers === null) {\n        promiseWithResolvers = pendingEntry.promise = (0, _promisewithresolvers.createPromiseWithResolvers)();\n    } else {\n    // There's already a promise we can use\n    }\n    return promiseWithResolvers.promise;\n}\nfunction readOrCreateRouteCacheEntry(now, task, key) {\n    attachInvalidationListener(task);\n    const existingEntry = readRouteCacheEntry(now, key);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const pendingEntry = {\n        canonicalUrl: null,\n        status: 0,\n        blockedTasks: null,\n        tree: null,\n        metadata: null,\n        // This is initialized to true because we don't know yet whether the route\n        // could be intercepted. It's only set to false once we receive a response\n        // from the server.\n        couldBeIntercepted: true,\n        // Similarly, we don't yet know if the route supports PPR.\n        isPPREnabled: false,\n        renderedSearch: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        // Since this is an empty entry, there's no reason to ever evict it. It will\n        // be updated when the data is populated.\n        staleAt: Infinity,\n        version: getCurrentCacheVersion()\n    };\n    const varyPath = (0, _varypath.getRouteVaryPath)(key.pathname, key.search, key.nextUrl);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(routeCacheMap, varyPath, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction requestOptimisticRouteCacheEntry(now, requestedUrl, nextUrl) {\n    // This function is called during a navigation when there was no matching\n    // route tree in the prefetch cache. Before de-opting to a blocking,\n    // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n    // route tree by checking the cache for similar routes.\n    //\n    // Check if there's a route with the same pathname, but with different\n    // search params. We can then base our optimistic route tree on this entry.\n    //\n    // Conceptually, we are simulating what would happen if we did perform a\n    // prefetch the requested URL, under the assumption that the server will\n    // not redirect or rewrite the request in a different manner than the\n    // base route tree. This assumption might not hold, in which case we'll have\n    // to recover when we perform the dynamic navigation request. However, this\n    // is what would happen if a route were dynamically rewritten/redirected\n    // in between the prefetch and the navigation. So the logic needs to exist\n    // to handle this case regardless.\n    // Look for a route with the same pathname, but with an empty search string.\n    // TODO: There's nothing inherently special about the empty search string;\n    // it's chosen somewhat arbitrarily, with the rationale that it's the most\n    // likely one to exist. But we should update this to match _any_ search\n    // string. The plan is to generalize this logic alongside other improvements\n    // related to \"fallback\" cache entries.\n    const requestedSearch = requestedUrl.search;\n    if (requestedSearch === '') {\n        // The caller would have already checked if a route with an empty search\n        // string is in the cache. So we can bail out here.\n        return null;\n    }\n    const urlWithoutSearchParams = new URL(requestedUrl);\n    urlWithoutSearchParams.search = '';\n    const routeWithNoSearchParams = readRouteCacheEntry(now, (0, _cachekey.createCacheKey)(urlWithoutSearchParams.href, nextUrl));\n    if (routeWithNoSearchParams === null || routeWithNoSearchParams.status !== 2) {\n        // Bail out of constructing an optimistic route tree. This will result in\n        // a blocking, unprefetched navigation.\n        return null;\n    }\n    // Now we have a base route tree we can \"patch\" with our optimistic values.\n    // Optimistically assume that redirects for the requested pathname do\n    // not vary on the search string. Therefore, if the base route was\n    // redirected to a different search string, then the optimistic route\n    // should be redirected to the same search string. Otherwise, we use\n    // the requested search string.\n    const canonicalUrlForRouteWithNoSearchParams = new URL(routeWithNoSearchParams.canonicalUrl, requestedUrl.origin);\n    const optimisticCanonicalSearch = canonicalUrlForRouteWithNoSearchParams.search !== '' ? canonicalUrlForRouteWithNoSearchParams.search : requestedSearch;\n    // Similarly, optimistically assume that rewrites for the requested\n    // pathname do not vary on the search string. Therefore, if the base\n    // route was rewritten to a different search string, then the optimistic\n    // route should be rewritten to the same search string. Otherwise, we use\n    // the requested search string.\n    const optimisticRenderedSearch = routeWithNoSearchParams.renderedSearch !== '' ? routeWithNoSearchParams.renderedSearch : requestedSearch;\n    const optimisticUrl = new URL(routeWithNoSearchParams.canonicalUrl, location.origin);\n    optimisticUrl.search = optimisticCanonicalSearch;\n    const optimisticCanonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(optimisticUrl);\n    const optimisticRouteTree = createOptimisticRouteTree(routeWithNoSearchParams.tree, optimisticRenderedSearch);\n    const optimisticMetadataTree = createOptimisticRouteTree(routeWithNoSearchParams.metadata, optimisticRenderedSearch);\n    // Clone the base route tree, and override the relevant fields with our\n    // optimistic values.\n    const optimisticEntry = {\n        canonicalUrl: optimisticCanonicalUrl,\n        status: 2,\n        // This isn't cloned because it's instance-specific\n        blockedTasks: null,\n        tree: optimisticRouteTree,\n        metadata: optimisticMetadataTree,\n        couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n        isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n        // Override the rendered search with the optimistic value.\n        renderedSearch: optimisticRenderedSearch,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt: routeWithNoSearchParams.staleAt,\n        version: routeWithNoSearchParams.version\n    };\n    // Do not insert this entry into the cache. It only exists so we can\n    // perform the current navigation. Just return it to the caller.\n    return optimisticEntry;\n}\nfunction createOptimisticRouteTree(tree, newRenderedSearch) {\n    // Create a new route tree that identical to the original one except for\n    // the rendered search string, which is contained in the vary path.\n    let clonedSlots = null;\n    const originalSlots = tree.slots;\n    if (originalSlots !== null) {\n        clonedSlots = {};\n        for(const parallelRouteKey in originalSlots){\n            const childTree = originalSlots[parallelRouteKey];\n            clonedSlots[parallelRouteKey] = createOptimisticRouteTree(childTree, newRenderedSearch);\n        }\n    }\n    // We only need to clone the vary path if the route is a page.\n    if (tree.isPage) {\n        return {\n            requestKey: tree.requestKey,\n            segment: tree.segment,\n            varyPath: (0, _varypath.clonePageVaryPathWithNewSearchParams)(tree.varyPath, newRenderedSearch),\n            isPage: true,\n            slots: clonedSlots,\n            isRootLayout: tree.isRootLayout,\n            hasLoadingBoundary: tree.hasLoadingBoundary,\n            hasRuntimePrefetch: tree.hasRuntimePrefetch\n        };\n    }\n    return {\n        requestKey: tree.requestKey,\n        segment: tree.segment,\n        varyPath: tree.varyPath,\n        isPage: false,\n        slots: clonedSlots,\n        isRootLayout: tree.isRootLayout,\n        hasLoadingBoundary: tree.hasLoadingBoundary,\n        hasRuntimePrefetch: tree.hasRuntimePrefetch\n    };\n}\nfunction readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree) {\n    const existingEntry = readSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction readOrCreateRevalidatingSegmentEntry(now, fetchStrategy, route, tree) {\n    // This function is called when we've already confirmed that a particular\n    // segment is cached, but we want to perform another request anyway in case it\n    // returns more complete and/or fresher data than we already have. The logic\n    // for deciding whether to replace the existing entry is handled elsewhere;\n    // this function just handles retrieving a cache entry that we can use to\n    // track the revalidation.\n    //\n    // The reason revalidations are stored in the cache is because we need to be\n    // able to dedupe multiple revalidation requests. The reason they have to be\n    // handled specially is because we shouldn't overwrite a \"normal\" entry if\n    // one exists at the same keypath. So, for each internal cache location, there\n    // is a special \"revalidation\" slot that is used solely for this purpose.\n    //\n    // You can think of it as if all the revalidation entries were stored in a\n    // separate cache map from the canonical entries, and then transfered to the\n    // canonical cache map once the request is complete  this isn't how it's\n    // actually implemented, since it's more efficient to store them in the same\n    // data structure as the normal entries, but that's how it's modeled\n    // conceptually.\n    // TODO: Once we implement Fallback behavior for params, where an entry is\n    // re-keyed based on response information, we'll need to account for the\n    // possibility that the keypath of the previous entry is more generic than\n    // the keypath of the revalidating entry. In other words, the server could\n    // return a less generic entry upon revalidation. For now, though, this isn't\n    // a concern because the keypath is based solely on the prefetch strategy,\n    // not on data contained in the response.\n    const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath);\n    if (existingEntry !== null) {\n        return existingEntry;\n    }\n    // Create a pending entry and add it to the cache.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction overwriteRevalidatingSegmentCacheEntry(fetchStrategy, route, tree) {\n    // This function is called when we've already decided to replace an existing\n    // revalidation entry. Create a new entry and write it into the cache,\n    // overwriting the previous value.\n    const varyPathForRequest = (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree);\n    const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt);\n    const isRevalidation = true;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPathForRequest, pendingEntry, isRevalidation);\n    return pendingEntry;\n}\nfunction upsertSegmentEntry(now, varyPath, candidateEntry) {\n    // We have a new entry that has not yet been inserted into the cache. Before\n    // we do so, we need to confirm whether it takes precedence over the existing\n    // entry (if one exists).\n    // TODO: We should not upsert an entry if its key was invalidated in the time\n    // since the request was made. We can do that by passing the \"owner\" entry to\n    // this function and confirming it's the same as `existingEntry`.\n    if ((0, _cachemap.isValueExpired)(now, getCurrentCacheVersion(), candidateEntry)) {\n        // The entry is expired. We cannot upsert it.\n        return null;\n    }\n    const existingEntry = readSegmentCacheEntry(now, varyPath);\n    if (existingEntry !== null) {\n        // Don't replace a more specific segment with a less-specific one. A case where this\n        // might happen is if the existing segment was fetched via\n        // `<Link prefetch={true}>`.\n        if (// than the segment we already have in the cache, so it can't have more content.\n        candidateEntry.fetchStrategy !== existingEntry.fetchStrategy && !canNewFetchStrategyProvideMoreContent(existingEntry.fetchStrategy, candidateEntry.fetchStrategy) || // The existing entry isn't partial, but the new one is.\n        // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n        !existingEntry.isPartial && candidateEntry.isPartial) {\n            // We're going to leave revalidating entry in the cache so that it doesn't\n            // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n            // Rejected and null out the data so it can be garbage collected. We leave\n            // `staleAt` intact to prevent subsequent revalidation attempts only until\n            // the entry expires.\n            const rejectedEntry = candidateEntry;\n            rejectedEntry.status = 3;\n            rejectedEntry.loading = null;\n            rejectedEntry.rsc = null;\n            return null;\n        }\n        // Evict the existing entry from the cache.\n        (0, _cachemap.deleteFromCacheMap)(existingEntry);\n    }\n    const isRevalidation = false;\n    (0, _cachemap.setInCacheMap)(segmentCacheMap, varyPath, candidateEntry, isRevalidation);\n    return candidateEntry;\n}\nfunction createDetachedSegmentCacheEntry(staleAt) {\n    const emptyEntry = {\n        status: 0,\n        // Default to assuming the fetch strategy will be PPR. This will be updated\n        // when a fetch is actually initiated.\n        fetchStrategy: _types.FetchStrategy.PPR,\n        rsc: null,\n        loading: null,\n        isPartial: true,\n        promise: null,\n        // Map-related fields\n        ref: null,\n        size: 0,\n        staleAt,\n        version: 0\n    };\n    return emptyEntry;\n}\nfunction upgradeToPendingSegment(emptyEntry, fetchStrategy) {\n    const pendingEntry = emptyEntry;\n    pendingEntry.status = 1;\n    pendingEntry.fetchStrategy = fetchStrategy;\n    if (fetchStrategy === _types.FetchStrategy.Full) {\n        // We can assume the response will contain the full segment data. Set this\n        // to false so we know it's OK to omit this segment from any navigation\n        // requests that may happen while the data is still pending.\n        pendingEntry.isPartial = false;\n    }\n    // Set the version here, since this is right before the request is initiated.\n    // The next time the global cache version is incremented, the entry will\n    // effectively be evicted. This happens before initiating the request, rather\n    // than when receiving the response, because it's guaranteed to happen\n    // before the data is read on the server.\n    pendingEntry.version = getCurrentCacheVersion();\n    return pendingEntry;\n}\nfunction pingBlockedTasks(entry) {\n    const blockedTasks = entry.blockedTasks;\n    if (blockedTasks !== null) {\n        for (const task of blockedTasks){\n            (0, _scheduler.pingPrefetchTask)(task);\n        }\n        entry.blockedTasks = null;\n    }\n}\nfunction fulfillRouteCacheEntry(entry, tree, metadataVaryPath, staleAt, couldBeIntercepted, canonicalUrl, renderedSearch, isPPREnabled) {\n    // The Head is not actually part of the route tree, but other than that, it's\n    // fetched and cached like a segment. Some functions expect a RouteTree\n    // object, so rather than fork the logic in all those places, we use this\n    // \"fake\" one.\n    const metadata = {\n        requestKey: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        segment: _segmentvalueencoding.HEAD_REQUEST_KEY,\n        varyPath: metadataVaryPath,\n        // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n        // either) but for the purposes of how this field is used, it behaves like\n        // one. If this logic ever gets more complex we can change this to an enum.\n        isPage: true,\n        slots: null,\n        isRootLayout: false,\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        hasRuntimePrefetch: false\n    };\n    const fulfilledEntry = entry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.tree = tree;\n    fulfilledEntry.metadata = metadata;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.couldBeIntercepted = couldBeIntercepted;\n    fulfilledEntry.canonicalUrl = canonicalUrl;\n    fulfilledEntry.renderedSearch = renderedSearch;\n    fulfilledEntry.isPPREnabled = isPPREnabled;\n    pingBlockedTasks(entry);\n    return fulfilledEntry;\n}\nfunction fulfillSegmentCacheEntry(segmentCacheEntry, rsc, loading, staleAt, isPartial) {\n    const fulfilledEntry = segmentCacheEntry;\n    fulfilledEntry.status = 2;\n    fulfilledEntry.rsc = rsc;\n    fulfilledEntry.loading = loading;\n    fulfilledEntry.staleAt = staleAt;\n    fulfilledEntry.isPartial = isPartial;\n    // Resolve any listeners that were waiting for this data.\n    if (segmentCacheEntry.promise !== null) {\n        segmentCacheEntry.promise.resolve(fulfilledEntry);\n        // Free the promise for garbage collection.\n        fulfilledEntry.promise = null;\n    }\n    return fulfilledEntry;\n}\nfunction rejectRouteCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    pingBlockedTasks(entry);\n}\nfunction rejectSegmentCacheEntry(entry, staleAt) {\n    const rejectedEntry = entry;\n    rejectedEntry.status = 3;\n    rejectedEntry.staleAt = staleAt;\n    if (entry.promise !== null) {\n        // NOTE: We don't currently propagate the reason the prefetch was canceled\n        // but we could by accepting a `reason` argument.\n        entry.promise.resolve(null);\n        entry.promise = null;\n    }\n}\nfunction convertRootTreePrefetchToRouteTree(rootTree, renderedPathname, renderedSearch, acc) {\n    // Remove trailing and leading slashes\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\n    const index = 0;\n    const rootSegment = _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY;\n    return convertTreePrefetchToRouteTree(rootTree.tree, rootSegment, null, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, pathnameParts, index, renderedSearch, acc);\n}\nfunction convertTreePrefetchToRouteTree(prefetch, segment, partialVaryPath, requestKey, pathnameParts, pathnamePartsIndex, renderedSearch, acc) {\n    // Converts the route tree sent by the server into the format used by the\n    // cache. The cached version of the tree includes additional fields, such as a\n    // cache key for each segment. Since this is frequently accessed, we compute\n    // it once instead of on every access. This same cache key is also used to\n    // request the segment from the server.\n    let slots = null;\n    let isPage;\n    let varyPath;\n    const prefetchSlots = prefetch.slots;\n    if (prefetchSlots !== null) {\n        isPage = false;\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        slots = {};\n        for(let parallelRouteKey in prefetchSlots){\n            const childPrefetch = prefetchSlots[parallelRouteKey];\n            const childParamName = childPrefetch.name;\n            const childParamType = childPrefetch.paramType;\n            const childServerSentParamKey = childPrefetch.paramKey;\n            let childDoesAppearInURL;\n            let childSegment;\n            let childPartialVaryPath;\n            if (childParamType !== null) {\n                // This segment is parameterized. Get the param from the pathname.\n                const childParamValue = (0, _routeparams.parseDynamicParamFromURLPart)(childParamType, pathnameParts, pathnamePartsIndex);\n                // Assign a cache key to the segment, based on the param value. In the\n                // pre-Segment Cache implementation, the server computes this and sends\n                // it in the body of the response. In the Segment Cache implementation,\n                // the server sends an empty string and we fill it in here.\n                // TODO: We're intentionally not adding the search param to page\n                // segments here; it's tracked separately and added back during a read.\n                // This would clearer if we waited to construct the segment until it's\n                // read from the cache, since that's effectively what we're\n                // doing anyway.\n                const childParamKey = // cacheComponents is enabled.\n                childServerSentParamKey !== null ? childServerSentParamKey : (0, _routeparams.getCacheKeyForDynamicParam)(childParamValue, '');\n                childPartialVaryPath = (0, _varypath.appendLayoutVaryPath)(partialVaryPath, childParamKey);\n                childSegment = [\n                    childParamName,\n                    childParamKey,\n                    childParamType\n                ];\n                childDoesAppearInURL = true;\n            } else {\n                // This segment does not have a param. Inherit the partial vary path of\n                // the parent.\n                childPartialVaryPath = partialVaryPath;\n                childSegment = childParamName;\n                childDoesAppearInURL = (0, _routeparams.doesStaticSegmentAppearInURL)(childParamName);\n            }\n            // Only increment the index if the segment appears in the URL. If it's a\n            // \"virtual\" segment, like a route group, it remains the same.\n            const childPathnamePartsIndex = childDoesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\n            const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n            const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n            slots[parallelRouteKey] = convertTreePrefetchToRouteTree(childPrefetch, childSegment, childPartialVaryPath, childRequestKey, pathnameParts, childPathnamePartsIndex, renderedSearch, acc);\n        }\n    } else {\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: prefetch.isRootLayout,\n        // This field is only relevant to dynamic routes. For a PPR/static route,\n        // there's always some partial loading state we can fetch.\n        hasLoadingBoundary: _approutertypes.HasLoadingBoundary.SegmentHasLoadingBoundary,\n        hasRuntimePrefetch: prefetch.hasRuntimePrefetch\n    };\n}\nfunction convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc) {\n    return convertFlightRouterStateToRouteTree(flightRouterState, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, null, renderedSearch, acc);\n}\nfunction convertFlightRouterStateToRouteTree(flightRouterState, requestKey, parentPartialVaryPath, renderedSearch, acc) {\n    const originalSegment = flightRouterState[0];\n    let segment;\n    let partialVaryPath;\n    let isPage;\n    let varyPath;\n    if (Array.isArray(originalSegment)) {\n        isPage = false;\n        const paramCacheKey = originalSegment[1];\n        partialVaryPath = (0, _varypath.appendLayoutVaryPath)(parentPartialVaryPath, paramCacheKey);\n        varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        segment = originalSegment;\n    } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        partialVaryPath = parentPartialVaryPath;\n        if (requestKey.endsWith(_segment.PAGE_SEGMENT_KEY)) {\n            // This is a page segment.\n            isPage = true;\n            // The navigation implementation expects the search params to be included\n            // in the segment. However, in the case of a static response, the search\n            // params are omitted. So the client needs to add them back in when reading\n            // from the Segment Cache.\n            //\n            // For consistency, we'll do this for dynamic responses, too.\n            //\n            // TODO: We should move search params out of FlightRouterState and handle\n            // them entirely on the client, similar to our plan for dynamic params.\n            segment = _segment.PAGE_SEGMENT_KEY;\n            varyPath = (0, _varypath.finalizePageVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            // The metadata \"segment\" is not part the route tree, but it has the same\n            // conceptual params as a page segment. Write the vary path into the\n            // accumulator object. If there are multiple parallel pages, we use the\n            // first one. Which page we choose is arbitrary as long as it's\n            // consistently the same one every time every time. See\n            // finalizeMetadataVaryPath for more details.\n            if (acc.metadataVaryPath === null) {\n                acc.metadataVaryPath = (0, _varypath.finalizeMetadataVaryPath)(requestKey, renderedSearch, partialVaryPath);\n            }\n        } else {\n            // This is a layout segment.\n            isPage = false;\n            segment = originalSegment;\n            varyPath = (0, _varypath.finalizeLayoutVaryPath)(requestKey, partialVaryPath);\n        }\n    }\n    let slots = null;\n    const parallelRoutes = flightRouterState[1];\n    for(let parallelRouteKey in parallelRoutes){\n        const childRouterState = parallelRoutes[parallelRouteKey];\n        const childSegment = childRouterState[0];\n        // TODO: Eventually, the param values will not be included in the response\n        // from the server. We'll instead fill them in on the client by parsing\n        // the URL. This is where we'll do that.\n        const childRequestKeyPart = (0, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment);\n        const childRequestKey = (0, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, childRequestKeyPart);\n        const childTree = convertFlightRouterStateToRouteTree(childRouterState, childRequestKey, partialVaryPath, renderedSearch, acc);\n        if (slots === null) {\n            slots = {\n                [parallelRouteKey]: childTree\n            };\n        } else {\n            slots[parallelRouteKey] = childTree;\n        }\n    }\n    return {\n        requestKey,\n        segment,\n        varyPath,\n        // TODO: Cheating the type system here a bit because TypeScript can't tell\n        // that the type of isPage and varyPath are consistent. The fix would be to\n        // create separate constructors and call the appropriate one from each of\n        // the branches above. Just seems a bit overkill only for one field so I'll\n        // leave it as-is for now. If isPage were wrong it would break the behavior\n        // and we'd catch it quickly, anyway.\n        isPage: isPage,\n        slots,\n        isRootLayout: flightRouterState[4] === true,\n        hasLoadingBoundary: flightRouterState[5] !== undefined ? flightRouterState[5] : _approutertypes.HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n        // Non-static tree responses are only used by apps that haven't adopted\n        // Cache Components. So this is always false.\n        hasRuntimePrefetch: false\n    };\n}\nfunction convertRouteTreeToFlightRouterState(routeTree) {\n    const parallelRoutes = {};\n    if (routeTree.slots !== null) {\n        for(const parallelRouteKey in routeTree.slots){\n            parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(routeTree.slots[parallelRouteKey]);\n        }\n    }\n    const flightRouterState = [\n        routeTree.segment,\n        parallelRoutes,\n        null,\n        null,\n        routeTree.isRootLayout\n    ];\n    return flightRouterState;\n}\nasync function fetchRouteOnCacheMiss(entry, task, key) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    const pathname = key.pathname;\n    const search = key.search;\n    const nextUrl = key.nextUrl;\n    const segmentPath = '/_tree';\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        const url = new URL(pathname + search, location.origin);\n        let response;\n        let urlAfterRedirects;\n        if (isOutputExportMode) {\n            // In output: \"export\" mode, we can't use headers to request a particular\n            // segment. Instead, we encode the extra request information into the URL.\n            // This is not part of the \"public\" interface of the app; it's an internal\n            // Next.js implementation detail that the app developer should not need to\n            // concern themselves with.\n            //\n            // For example, to request a segment:\n            //\n            //   Path passed to <Link>:   /path/to/page\n            //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n            //\n            //   (This is not the exact protocol, just an illustration.)\n            //\n            // Before we do that, though, we need to account for redirects. Even in\n            // output: \"export\" mode, a proxy might redirect the page to a different\n            // location, but we shouldn't assume or expect that they also redirect all\n            // the segment files, too.\n            //\n            // To check whether the page is redirected, previously we perform a range\n            // request of 64 bytes of the HTML document to check if the target page\n            // is part of this app (by checking if build id matches). Only if the target\n            // page is part of this app do we determine the final canonical URL.\n            //\n            // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n            // some popular static hosting providers (like Cloudflare Pages or Render.com)\n            // do not support range requests, in the worst case, the entire HTML instead\n            // of 64 bytes could be returned, which is wasteful.\n            //\n            // So instead, we drops the check for build id here, and simply perform\n            // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n            // final URL after redirects.\n            //\n            // NOTE: We could embed the route tree into the HTML document, to avoid\n            // a second request. We're not doing that currently because it would make\n            // the HTML document larger and affect normal page loads.\n            const headResponse = await fetch(url, {\n                method: 'HEAD'\n            });\n            if (headResponse.status < 200 || headResponse.status >= 400) {\n                // The target page responded w/o a successful status code\n                // Could be a WAF serving a 403, or a 5xx from a backend\n                //\n                // Note that we can't use headResponse.ok here, because\n                // Response#ok returns `false` with 3xx responses.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            urlAfterRedirects = headResponse.redirected ? new URL(headResponse.url) : url;\n            response = await fetchPrefetchResponse(addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath), headers);\n        } else {\n            // \"Server\" mode. We can use request headers instead of the pathname.\n            // TODO: The eventual plan is to get rid of our custom request headers and\n            // encode everything into the URL, using a similar strategy to the\n            // \"output: export\" block above.\n            response = await fetchPrefetchResponse(url, headers);\n            urlAfterRedirects = response !== null && response.redirected ? new URL(response.url) : url;\n        }\n        if (!response || !response.ok || // 204 is a Cache miss. Though theoretically this shouldn't happen when\n        // PPR is enabled, because we always respond to route tree requests, even\n        // if it needs to be blockingly generated on demand.\n        response.status === 204 || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // TODO: The canonical URL is the href without the origin. I think\n        // historically the reason for this is because the initial canonical URL\n        // gets passed as a prop to the top-level React component, which means it\n        // needs to be computed during SSR. If it were to include the origin, it\n        // would need to always be same as location.origin on the client, to prevent\n        // a hydration mismatch. To sidestep this complexity, we omit the origin.\n        //\n        // However, since this is neither a native URL object nor a fully qualified\n        // URL string, we need to be careful about how we use it. To prevent subtle\n        // mistakes, we should create a special type for it, instead of just string.\n        // Or, we should just use a (readonly) URL object instead. The type of the\n        // prop that we pass to seed the initial state does not need to be the same\n        // type as the state itself.\n        const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(urlAfterRedirects);\n        // Check whether the response varies based on the Next-Url header.\n        const varyHeader = response.headers.get('vary');\n        const couldBeIntercepted = varyHeader !== null && varyHeader.includes(_approuterheaders.NEXT_URL);\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route.\n        const routeIsPPREnabled = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '2' || // In output: \"export\" mode, we can't rely on response headers. But if we\n        // receive a well-formed response, we can assume it's a static response,\n        // because all data is static in this mode.\n        isOutputExportMode;\n        if (routeIsPPREnabled) {\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            // Get the params that were used to render the target page. These may\n            // be different from the params in the request URL, if the page\n            // was rewritten.\n            const renderedPathname = (0, _routeparams.getRenderedPathname)(response);\n            const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n            // Convert the server-sent data into the RouteTree format used by the\n            // client cache.\n            //\n            // During this traversal, we accumulate additional data into this\n            // \"accumulator\" object.\n            const acc = {\n                metadataVaryPath: null\n            };\n            const routeTree = convertRootTreePrefetchToRouteTree(serverData, renderedPathname, renderedSearch, acc);\n            const metadataVaryPath = acc.metadataVaryPath;\n            if (metadataVaryPath === null) {\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            const staleTimeMs = getStaleTimeMs(serverData.staleTime);\n            fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, Date.now() + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n        } else {\n            // PPR is not enabled for this route. The server responds with a\n            // different format (FlightRouterState) that we need to convert.\n            // TODO: We will unify the responses eventually. I'm keeping the types\n            // separate for now because FlightRouterState has so many\n            // overloaded concerns.\n            const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n                (0, _cachemap.setSizeInCacheMap)(entry, size);\n            });\n            const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n            if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n                // The server build does not match the client. Treat as a 404. During\n                // an actual navigation, the router will trigger an MPA navigation.\n                // TODO: Consider moving the build ID to a response header so we can check\n                // it before decoding the response, and so there's one way of checking\n                // across all response types.\n                // TODO: We should cache the fact that this is an MPA navigation.\n                rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n                return null;\n            }\n            writeDynamicTreeResponseIntoCache(Date.now(), task, // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n            _types.FetchStrategy.LoadingBoundary, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled);\n        }\n        if (!couldBeIntercepted) {\n            // This route will never be intercepted. So we can use this entry for all\n            // requests to this route, regardless of the Next-Url header. This works\n            // because when reading the cache we always check for a valid\n            // non-intercepted entry first.\n            // Re-key the entry. The `set` implementation handles removing it from\n            // its previous position in the cache. We don't need to do anything to\n            // update the LRU, because the entry is already in it.\n            // TODO: Treat this as an upsert  should check if an entry already\n            // exists at the new keypath, and if so, whether we should keep that\n            // one instead.\n            const fulfilledVaryPath = (0, _varypath.getFulfilledRouteVaryPath)(pathname, search, nextUrl, couldBeIntercepted);\n            const isRevalidation = false;\n            (0, _cachemap.setInCacheMap)(routeCacheMap, fulfilledVaryPath, entry, isRevalidation);\n        }\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentOnCacheMiss(route, segmentCacheEntry, routeKey, tree) {\n    // This function is allowed to use async/await because it contains the actual\n    // fetch that gets issued on a cache miss. Notice it writes the result to the\n    // cache entry directly, rather than return data that is then written by\n    // the caller.\n    //\n    // Segment fetches are non-blocking so we don't need to ping the scheduler\n    // on completion.\n    // Use the canonical URL to request the segment, not the original URL. These\n    // are usually the same, but the canonical URL will be different if the route\n    // tree response was redirected. To avoid an extra waterfall on every segment\n    // request, we pass the redirected URL instead of the original one.\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = routeKey.nextUrl;\n    const requestKey = tree.requestKey;\n    const normalizedRequestKey = requestKey === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY ? // `_index` instead of as an empty string. This should be treated as\n    // an implementation detail and not as a stable part of the protocol.\n    // It just needs to match the equivalent logic that happens when\n    // prerendering the responses. It should not leak outside of Next.js.\n    '/_index' : requestKey;\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    const requestUrl = isOutputExportMode ? addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey) : url;\n    try {\n        const response = await fetchPrefetchResponse(requestUrl, headers);\n        if (!response || !response.ok || response.status === 204 || // Cache miss\n        // This checks whether the response was served from the per-segment cache,\n        // rather than the old prefetching flow. If it fails, it implies that PPR\n        // is disabled on this route. Theoretically this should never happen\n        // because we only issue requests for segments once we've verified that\n        // the route supports PPR.\n        response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) !== '2' && // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        // Wrap the original stream in a new stream that never closes. That way the\n        // Flight client doesn't error if there's a hanging promise.\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(size) {\n            (0, _cachemap.setSizeInCacheMap)(segmentCacheEntry, size);\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        if (serverData.buildId !== (0, _appbuildid.getAppBuildId)()) {\n            // The server build does not match the client. Treat as a 404. During\n            // an actual navigation, the router will trigger an MPA navigation.\n            // TODO: Consider moving the build ID to a response header so we can check\n            // it before decoding the response, and so there's one way of checking\n            // across all response types.\n            rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n            return null;\n        }\n        return {\n            value: fulfillSegmentCacheEntry(segmentCacheEntry, serverData.rsc, serverData.loading, // So we use the stale time of the route.\n            route.staleAt, serverData.isPartial),\n            // Return a promise that resolves when the network connection closes, so\n            // the scheduler can track the number of concurrent network connections.\n            closed: closed.promise\n        };\n    } catch (error) {\n        // Either the connection itself failed, or something bad happened while\n        // decoding the response.\n        rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nasync function fetchSegmentPrefetchesUsingDynamicRequest(task, route, fetchStrategy, dynamicRequestTree, spawnedEntries) {\n    const key = task.key;\n    const url = new URL(route.canonicalUrl, location.origin);\n    const nextUrl = key.nextUrl;\n    if (spawnedEntries.size === 1 && spawnedEntries.has(route.metadata.requestKey)) {\n        // The only thing pending is the head. Instruct the server to\n        // skip over everything else.\n        dynamicRequestTree = MetadataOnlyRequestTree;\n    }\n    const headers = {\n        [_approuterheaders.RSC_HEADER]: '1',\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(dynamicRequestTree)\n    };\n    if (nextUrl !== null) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    switch(fetchStrategy){\n        case _types.FetchStrategy.Full:\n            {\n                break;\n            }\n        case _types.FetchStrategy.PPRRuntime:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '2';\n                break;\n            }\n        case _types.FetchStrategy.LoadingBoundary:\n            {\n                headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n                break;\n            }\n        default:\n            {\n                fetchStrategy;\n            }\n    }\n    try {\n        const response = await fetchPrefetchResponse(url, headers);\n        if (!response || !response.ok || !response.body) {\n            // Server responded with an error, or with a miss. We should still cache\n            // the response, but we can try again after 10 seconds.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n        if (renderedSearch !== route.renderedSearch) {\n            // The search params that were used to render the target page are\n            // different from the search params in the request URL. This only happens\n            // when there's a dynamic rewrite in between the tree prefetch and the\n            // data prefetch.\n            // TODO: For now, since this is an edge case, we reject the prefetch, but\n            // the proper way to handle this is to evict the stale route tree entry\n            // then fill the cache with the new response.\n            rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n            return null;\n        }\n        // Track when the network connection closes.\n        const closed = (0, _promisewithresolvers.createPromiseWithResolvers)();\n        let fulfilledEntries = null;\n        const prefetchStream = createPrefetchResponseStream(response.body, closed.resolve, function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n            // When processing a dynamic response, we don't know how large each\n            // individual segment is, so approximate by assiging each segment\n            // the average of the total response size.\n            if (fulfilledEntries === null) {\n                // Haven't received enough data yet to know which segments\n                // were included.\n                return;\n            }\n            const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length;\n            for (const entry of fulfilledEntries){\n                (0, _cachemap.setSizeInCacheMap)(entry, averageSize);\n            }\n        });\n        const serverData = await (0, _fetchserverresponse.createFromNextReadableStream)(prefetchStream, headers);\n        const isResponsePartial = fetchStrategy === _types.FetchStrategy.PPRRuntime ? serverData.rp?.[0] === true : false;\n        // Aside from writing the data into the cache, this function also returns\n        // the entries that were fulfilled, so we can streamingly update their sizes\n        // in the LRU as more data comes in.\n        fulfilledEntries = writeDynamicRenderResponseIntoCache(Date.now(), task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries);\n        // Return a promise that resolves when the network connection closes, so\n        // the scheduler can track the number of concurrent network connections.\n        return {\n            value: null,\n            closed: closed.promise\n        };\n    } catch (error) {\n        rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000);\n        return null;\n    }\n}\nfunction writeDynamicTreeResponseIntoCache(now, task, fetchStrategy, response, serverData, entry, couldBeIntercepted, canonicalUrl, routeIsPPREnabled) {\n    // Get the URL that was used to render the target page. This may be different\n    // from the URL in the request URL, if the page was rewritten.\n    const renderedSearch = (0, _routeparams.getRenderedSearch)(response);\n    const normalizedFlightDataResult = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (// MPA navigation.\n    typeof normalizedFlightDataResult === 'string' || normalizedFlightDataResult.length !== 1) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightData = normalizedFlightDataResult[0];\n    if (!flightData.isRootRender) {\n        // Unexpected response format.\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const flightRouterState = flightData.tree;\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    // If the response contains dynamic holes, then we must conservatively assume\n    // that any individual segment might contain dynamic holes, and also the\n    // head. If it did not contain dynamic holes, then we can assume every segment\n    // and the head is completely static.\n    const isResponsePartial = response.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER) === '1';\n    // Convert the server-sent data into the RouteTree format used by the\n    // client cache.\n    //\n    // During this traversal, we accumulate additional data into this\n    // \"accumulator\" object.\n    const acc = {\n        metadataVaryPath: null\n    };\n    const routeTree = convertRootFlightRouterStateToRouteTree(flightRouterState, renderedSearch, acc);\n    const metadataVaryPath = acc.metadataVaryPath;\n    if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, now + 10 * 1000);\n        return;\n    }\n    const fulfilledEntry = fulfillRouteCacheEntry(entry, routeTree, metadataVaryPath, now + staleTimeMs, couldBeIntercepted, canonicalUrl, renderedSearch, routeIsPPREnabled);\n    // If the server sent segment data as part of the response, we should write\n    // it into the cache to prevent a second, redundant prefetch request.\n    //\n    // TODO: When `clientSegmentCache` is enabled, the server does not include\n    // segment data when responding to a route tree prefetch request. However,\n    // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n    // the page is fully static), the normal check is bypassed and the server\n    // responds with the full page. This is a temporary situation until we can\n    // remove the \"client-only\" option. Then, we can delete this function call.\n    writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, fulfilledEntry, null);\n}\nfunction rejectSegmentEntriesIfStillPending(entries, staleAt) {\n    const fulfilledEntries = [];\n    for (const entry of entries.values()){\n        if (entry.status === 1) {\n            rejectSegmentCacheEntry(entry, staleAt);\n        } else if (entry.status === 2) {\n            fulfilledEntries.push(entry);\n        }\n    }\n    return fulfilledEntries;\n}\nfunction writeDynamicRenderResponseIntoCache(now, task, fetchStrategy, response, serverData, isResponsePartial, route, spawnedEntries) {\n    if (serverData.b !== (0, _appbuildid.getAppBuildId)()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        }\n        return null;\n    }\n    const flightDatas = (0, _flightdatahelpers.normalizeFlightData)(serverData.f);\n    if (typeof flightDatas === 'string') {\n        // This means navigating to this route will result in an MPA navigation.\n        // TODO: We should cache this, too, so that the MPA navigation is immediate.\n        return null;\n    }\n    // For runtime prefetches, stale time is in the payload at rp[1].\n    // For other responses, fall back to the header.\n    const staleTimeSeconds = typeof serverData.rp?.[1] === 'number' ? serverData.rp[1] : parseInt(response.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10);\n    const staleTimeMs = !isNaN(staleTimeSeconds) ? getStaleTimeMs(staleTimeSeconds) : _navigatereducer.STATIC_STALETIME_MS;\n    const staleAt = now + staleTimeMs;\n    for (const flightData of flightDatas){\n        const seedData = flightData.seedData;\n        if (seedData !== null) {\n            // The data sent by the server represents only a subtree of the app. We\n            // need to find the part of the task tree that matches the response.\n            //\n            // segmentPath represents the parent path of subtree. It's a repeating\n            // pattern of parallel route key and segment:\n            //\n            //   [string, Segment, string, Segment, string, Segment, ...]\n            const segmentPath = flightData.segmentPath;\n            let tree = route.tree;\n            for(let i = 0; i < segmentPath.length; i += 2){\n                const parallelRouteKey = segmentPath[i];\n                if (tree?.slots?.[parallelRouteKey] !== undefined) {\n                    tree = tree.slots[parallelRouteKey];\n                } else {\n                    if (spawnedEntries !== null) {\n                        rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n                    }\n                    return null;\n                }\n            }\n            writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, spawnedEntries);\n        }\n        const head = flightData.head;\n        if (head !== null) {\n            fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, head, null, flightData.isHeadPartial, staleAt, route.metadata, spawnedEntries);\n        }\n    }\n    // Any entry that's still pending was intentionally not rendered by the\n    // server, because it was inside the loading boundary. Mark them as rejected\n    // so we know not to fetch them again.\n    // TODO: If PPR is enabled on some routes but not others, then it's possible\n    // that a different page is able to do a per-segment prefetch of one of the\n    // segments we're marking as rejected here. We should mark on the segment\n    // somehow that the reason for the rejection is because of a non-PPR prefetch.\n    // That way a per-segment prefetch knows to disregard the rejection.\n    if (spawnedEntries !== null) {\n        const fulfilledEntries = rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000);\n        return fulfilledEntries;\n    }\n    return null;\n}\nfunction writeSeedDataIntoCache(now, task, fetchStrategy, route, tree, staleAt, seedData, isResponsePartial, entriesOwnedByCurrentTask) {\n    // This function is used to write the result of a runtime server request\n    // (CacheNodeSeedData) into the prefetch cache.\n    const rsc = seedData[0];\n    const loading = seedData[2];\n    const isPartial = rsc === null || isResponsePartial;\n    fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask);\n    // Recursively write the child data into the cache.\n    const slots = tree.slots;\n    if (slots !== null) {\n        const seedDataChildren = seedData[1];\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childSeedData = seedDataChildren[parallelRouteKey];\n            if (childSeedData !== null && childSeedData !== undefined) {\n                writeSeedDataIntoCache(now, task, fetchStrategy, route, childTree, staleAt, childSeedData, isResponsePartial, entriesOwnedByCurrentTask);\n            }\n        }\n    }\n}\nfunction fulfillEntrySpawnedByRuntimePrefetch(now, fetchStrategy, route, rsc, loading, isPartial, staleAt, tree, entriesOwnedByCurrentTask) {\n    // We should only write into cache entries that are owned by us. Or create\n    // a new one and write into that. We must never write over an entry that was\n    // created by a different task, because that causes data races.\n    const ownedEntry = entriesOwnedByCurrentTask !== null ? entriesOwnedByCurrentTask.get(tree.requestKey) : undefined;\n    if (ownedEntry !== undefined) {\n        fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial);\n    } else {\n        // There's no matching entry. Attempt to create a new one.\n        const possiblyNewEntry = readOrCreateSegmentCacheEntry(now, fetchStrategy, route, tree);\n        if (possiblyNewEntry.status === 0) {\n            // Confirmed this is a new entry. We can fulfill it.\n            const newEntry = possiblyNewEntry;\n            fulfillSegmentCacheEntry(upgradeToPendingSegment(newEntry, fetchStrategy), rsc, loading, staleAt, isPartial);\n        } else {\n            // There was already an entry in the cache. But we may be able to\n            // replace it with the new one from the server.\n            const newEntry = fulfillSegmentCacheEntry(upgradeToPendingSegment(createDetachedSegmentCacheEntry(staleAt), fetchStrategy), rsc, loading, staleAt, isPartial);\n            upsertSegmentEntry(now, (0, _varypath.getSegmentVaryPathForRequest)(fetchStrategy, tree), newEntry);\n        }\n    }\n}\nasync function fetchPrefetchResponse(url, headers) {\n    const fetchPriority = 'low';\n    // When issuing a prefetch request, don't immediately decode the response; we\n    // use the lower level `createFromResponse` API instead because we need to do\n    // some extra processing of the response stream. See\n    // `createPrefetchResponseStream` for more details.\n    const shouldImmediatelyDecode = false;\n    const response = await (0, _fetchserverresponse.createFetch)(url, headers, fetchPriority, shouldImmediatelyDecode);\n    if (!response.ok) {\n        return null;\n    }\n    // Check the content type\n    if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n    } else {\n        const contentType = response.headers.get('content-type');\n        const isFlightResponse = contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (!isFlightResponse) {\n            return null;\n        }\n    }\n    return response;\n}\nfunction createPrefetchResponseStream(originalFlightStream, onStreamClose, onResponseSizeUpdate) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    //\n    // While processing the original stream, we also incrementally update the size\n    // of the cache entry in the LRU.\n    let totalByteLength = 0;\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    // Incrementally update the size of the cache entry in the LRU.\n                    // NOTE: Since prefetch responses are delivered in a single chunk,\n                    // it's not really necessary to do this streamingly, but I'm doing it\n                    // anyway in case this changes in the future.\n                    totalByteLength += value.byteLength;\n                    onResponseSizeUpdate(totalByteLength);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream. We do notify the caller, though.\n                onStreamClose();\n                return;\n            }\n        }\n    });\n}\nfunction addSegmentPathToUrlInOutputExportMode(url, segmentPath) {\n    if (isOutputExportMode) {\n        // In output: \"export\" mode, we cannot use a header to encode the segment\n        // path. Instead, we append it to the end of the pathname.\n        const staticUrl = new URL(url);\n        const routeDir = staticUrl.pathname.endsWith('/') ? staticUrl.pathname.slice(0, -1) : staticUrl.pathname;\n        const staticExportFilename = (0, _segmentvalueencoding.convertSegmentPathToStaticExportFilename)(segmentPath);\n        staticUrl.pathname = `${routeDir}/${staticExportFilename}`;\n        return staticUrl;\n    }\n    return url;\n}\nfunction canNewFetchStrategyProvideMoreContent(currentStrategy, newStrategy) {\n    return currentStrategy < newStrategy;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3NlZ21lbnQtY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBK0trQkEsV0FBVztlQUFYQTs7SUFxa0VGQyxxQ0FBcUM7ZUFBckNBOztJQWhnQ0FDLG1DQUFtQztlQUFuQ0E7O0lBcGNBQywrQkFBK0I7ZUFBL0JBOztJQXlkTUMscUJBQXFCO2VBQXJCQTs7SUFvUkFDLHVCQUF1QjtlQUF2QkE7O0lBcUhBQyx5Q0FBeUM7ZUFBekNBOztJQTMyQ05DLHNCQUFzQjtlQUF0QkE7O0lBdk1BQyxjQUFjO2VBQWRBOztJQXFvQkFDLHNDQUFzQztlQUF0Q0E7O0lBelhBQyx5QkFBeUI7ZUFBekJBOztJQXVVQUMsb0NBQW9DO2VBQXBDQTs7SUFsUEFDLDJCQUEyQjtlQUEzQkE7O0lBMk5BQyw2QkFBNkI7ZUFBN0JBOztJQTdSQUMsbUJBQW1CO2VBQW5CQTs7SUFtQkFDLHFCQUFxQjtlQUFyQkE7O0lBMkZBQyxnQ0FBZ0M7ZUFBaENBOztJQTVMQUMscUJBQXFCO2VBQXJCQTs7SUFxaEJBQyx1QkFBdUI7ZUFBdkJBOztJQTdFQUMsa0JBQWtCO2VBQWxCQTs7SUEzVUFDLHdCQUF3QjtlQUF4QkE7Ozs0Q0FwYW1COzhDQVU1QjtpREFNQTt1Q0FPQTtzQ0FjQTt3Q0FDdUI7K0NBQ0k7c0NBR3lCO3lDQU9wRDtzQ0FVQTtrREFRQTsrQ0FRQTs2Q0FDNkI7bUNBQ0g7cUNBQ0E7bUNBQ0g7a0RBQ2E7QUFNcEMsU0FBU1osZUFBZWEsZ0JBQXdCO0lBQ3JELE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0Ysa0JBQWtCLE1BQU07QUFDMUM7QUE2RU8sSUFBV3JCLGNBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLFdBQUFBOzs7OztXQUFBQTs7QUErRmxCLE1BQU13QixxQkFDSkMsTUFBb0IsSUFDcEJBLENBQTZDO0FBRS9DLE1BQU1JLDBCQUE2QztJQUNqRDtJQUNB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SUFBSSxFQUFFMUQsS0FBSyxFQUFFLEdBQUcsTUFBTXFELE9BQU9NLElBQUk7Z0JBQ3pDLElBQUksQ0FBQ0QsTUFBTTtvQkFDVCxtRUFBbUU7b0JBQ25FLG1CQUFtQjtvQkFDbkJELFdBQVdHLE9BQU8sQ0FBQzVEO29CQUVuQiwrREFBK0Q7b0JBQy9ELGtFQUFrRTtvQkFDbEUscUVBQXFFO29CQUNyRSw2Q0FBNkM7b0JBQzdDb0QsbUJBQW1CcEQsTUFBTTZELFVBQVU7b0JBQ25DNUUscUJBQXFCbUU7b0JBQ3JCO2dCQUNGO2dCQUNBLHFFQUFxRTtnQkFDckUsc0RBQXNEO2dCQUN0REQ7Z0JBQ0E7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVM3RSxzQ0FDUFQsR0FBUSxFQUNSTixXQUE4QjtJQUU5QixJQUFJekssb0JBQW9CO1FBQ3RCLHlFQUF5RTtRQUN6RSwwREFBMEQ7UUFDMUQsTUFBTWdSLFlBQVksSUFBSXhOLElBQUl1SDtRQUMxQixNQUFNa0csV0FBV0QsVUFBVWxQLFFBQVEsQ0FBQzBILFFBQVEsQ0FBQyxPQUN6Q3dILFVBQVVsUCxRQUFRLENBQUNvUCxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQzdCRixVQUFVbFAsUUFBUTtRQUN0QixNQUFNcVAsdUJBQ0pDLENBQUFBLEdBQUFBLHNCQUFBQSx3Q0FBQUEsRUFBeUMzRztRQUMzQ3VHLFVBQVVsUCxRQUFRLEdBQUcsR0FBR21QLFNBQVMsQ0FBQyxFQUFFRSxzQkFBc0I7UUFDMUQsT0FBT0g7SUFDVDtJQUNBLE9BQU9qRztBQUNUO0FBdUJPLFNBQVN0TSxzQ0FDZDRTLGVBQThCLEVBQzlCQyxXQUEwQjtJQUUxQixPQUFPRCxrQkFBa0JDO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL2NsaWVudC9jb21wb25lbnRzL3NlZ21lbnQtY2FjaGUvY2FjaGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBUcmVlUHJlZmV0Y2gsXG4gIFJvb3RUcmVlUHJlZmV0Y2gsXG4gIFNlZ21lbnRQcmVmZXRjaCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvY29sbGVjdC1zZWdtZW50LWRhdGEnXG5pbXBvcnQgdHlwZSB7IExvYWRpbmdNb2R1bGVEYXRhIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgU2VnbWVudCBhcyBGbGlnaHRSb3V0ZXJTdGF0ZVNlZ21lbnQsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7IEhhc0xvYWRpbmdCb3VuZGFyeSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7XG4gIE5FWFRfRElEX1BPU1RQT05FX0hFQURFUixcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1VSTCxcbiAgUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsXG4gIFJTQ19IRUFERVIsXG59IGZyb20gJy4uL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB7XG4gIGNyZWF0ZUZldGNoLFxuICBjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtLFxuICB0eXBlIFJTQ1Jlc3BvbnNlLFxuICB0eXBlIFJlcXVlc3RIZWFkZXJzLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQge1xuICBwaW5nUHJlZmV0Y2hUYXNrLFxuICBpc1ByZWZldGNoVGFza0RpcnR5LFxuICB0eXBlIFByZWZldGNoVGFzayxcbiAgdHlwZSBQcmVmZXRjaFN1YnRhc2tSZXN1bHQsXG4gIHN0YXJ0UmV2YWxpZGF0aW9uQ29vbGRvd24sXG59IGZyb20gJy4vc2NoZWR1bGVyJ1xuaW1wb3J0IHtcbiAgdHlwZSBSb3V0ZVZhcnlQYXRoLFxuICB0eXBlIFNlZ21lbnRWYXJ5UGF0aCxcbiAgdHlwZSBQYXJ0aWFsU2VnbWVudFZhcnlQYXRoLFxuICBnZXRSb3V0ZVZhcnlQYXRoLFxuICBnZXRGdWxmaWxsZWRSb3V0ZVZhcnlQYXRoLFxuICBnZXRTZWdtZW50VmFyeVBhdGhGb3JSZXF1ZXN0LFxuICBhcHBlbmRMYXlvdXRWYXJ5UGF0aCxcbiAgZmluYWxpemVMYXlvdXRWYXJ5UGF0aCxcbiAgZmluYWxpemVQYWdlVmFyeVBhdGgsXG4gIGNsb25lUGFnZVZhcnlQYXRoV2l0aE5ld1NlYXJjaFBhcmFtcyxcbiAgdHlwZSBQYWdlVmFyeVBhdGgsXG4gIGZpbmFsaXplTWV0YWRhdGFWYXJ5UGF0aCxcbn0gZnJvbSAnLi92YXJ5LXBhdGgnXG5pbXBvcnQgeyBnZXRBcHBCdWlsZElkIH0gZnJvbSAnLi4vLi4vYXBwLWJ1aWxkLWlkJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZFNlYXJjaCwgUm91dGVDYWNoZUtleSB9IGZyb20gJy4vY2FjaGUta2V5J1xuLy8gVE9ETzogUmVuYW1lIHRoaXMgbW9kdWxlIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIG90aGVyIHR5cGVzIG9mIGNhY2hlIGtleXNcbmltcG9ydCB7IGNyZWF0ZUNhY2hlS2V5IGFzIGNyZWF0ZVByZWZldGNoUmVxdWVzdEtleSB9IGZyb20gJy4vY2FjaGUta2V5J1xuaW1wb3J0IHtcbiAgZG9lc1N0YXRpY1NlZ21lbnRBcHBlYXJJblVSTCxcbiAgZ2V0Q2FjaGVLZXlGb3JEeW5hbWljUGFyYW0sXG4gIGdldFJlbmRlcmVkUGF0aG5hbWUsXG4gIGdldFJlbmRlcmVkU2VhcmNoLFxuICBwYXJzZUR5bmFtaWNQYXJhbUZyb21VUkxQYXJ0LFxufSBmcm9tICcuLi8uLi9yb3V0ZS1wYXJhbXMnXG5pbXBvcnQge1xuICBjcmVhdGVDYWNoZU1hcCxcbiAgZ2V0RnJvbUNhY2hlTWFwLFxuICBzZXRJbkNhY2hlTWFwLFxuICBzZXRTaXplSW5DYWNoZU1hcCxcbiAgZGVsZXRlRnJvbUNhY2hlTWFwLFxuICBpc1ZhbHVlRXhwaXJlZCxcbiAgdHlwZSBDYWNoZU1hcCxcbiAgdHlwZSBVbmtub3duTWFwRW50cnksXG59IGZyb20gJy4vY2FjaGUtbWFwJ1xuaW1wb3J0IHtcbiAgYXBwZW5kU2VnbWVudFJlcXVlc3RLZXlQYXJ0LFxuICBjb252ZXJ0U2VnbWVudFBhdGhUb1N0YXRpY0V4cG9ydEZpbGVuYW1lLFxuICBjcmVhdGVTZWdtZW50UmVxdWVzdEtleVBhcnQsXG4gIEhFQURfUkVRVUVTVF9LRVksXG4gIFJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSxcbiAgdHlwZSBTZWdtZW50UmVxdWVzdEtleSxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50LWNhY2hlL3NlZ21lbnQtdmFsdWUtZW5jb2RpbmcnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2UsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUZsaWdodERhdGEsXG4gIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QsXG59IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBTVEFUSUNfU1RBTEVUSU1FX01TIH0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IHBpbmdWaXNpYmxlTGlua3MgfSBmcm9tICcuLi9saW5rcydcbmltcG9ydCB7IFBBR0VfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBGZXRjaFN0cmF0ZWd5IH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IGNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9wcm9taXNlLXdpdGgtcmVzb2x2ZXJzJ1xuXG4vKipcbiAqIEVuc3VyZXMgYSBtaW5pbXVtIHN0YWxlIHRpbWUgb2YgMzBzIHRvIGF2b2lkIGlzc3VlcyB3aGVyZSB0aGUgc2VydmVyIHNlbmRzIGEgdG9vXG4gKiBzaG9ydC1saXZlZCBzdGFsZSB0aW1lLCB3aGljaCB3b3VsZCBwcmV2ZW50IGFueXRoaW5nIGZyb20gYmVpbmcgcHJlZmV0Y2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YWxlVGltZU1zKHN0YWxlVGltZVNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLm1heChzdGFsZVRpbWVTZWNvbmRzLCAzMCkgKiAxMDAwXG59XG5cbi8vIEEgbm90ZSBvbiBhc3luYy9hd2FpdCB3aGVuIHdvcmtpbmcgaW4gdGhlIHByZWZldGNoIGNhY2hlOlxuLy9cbi8vIE1vc3QgYXN5bmMgb3BlcmF0aW9ucyBpbiB0aGUgcHJlZmV0Y2ggY2FjaGUgc2hvdWxkICpub3QqIHVzZSBhc3luYy9hd2FpdCxcbi8vIEluc3RlYWQsIHNwYXduIGEgc3VidGFzayB0aGF0IHdyaXRlcyB0aGUgcmVzdWx0cyB0byBhIGNhY2hlIGVudHJ5LCBhbmQgYXR0YWNoXG4vLyBhIFwicGluZ1wiIGxpc3RlbmVyIHRvIG5vdGlmeSB0aGUgcHJlZmV0Y2ggcXVldWUgdG8gdHJ5IGFnYWluLlxuLy9cbi8vIFRoZSByZWFzb24gaXMgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgc2VnbWVudCBjYWNoZSBhbmQgdHJhdmVyc2UgaXRzXG4vLyBkYXRhIHN0cnVjdHVyZXMgc3luY2hyb25vdXNseS4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlJ3MgYSBzeW5jaHJvbm91cyB1cGRhdGVcbi8vIHdlIGNhbiB0YWtlIGFuIGltbWVkaWF0ZSBzbmFwc2hvdCBvZiB0aGUgY2FjaGUgdG8gcHJvZHVjZSBzb21ldGhpbmcgd2UgY2FuXG4vLyByZW5kZXIuIExpbWl0aW5nIHRoZSB1c2Ugb2YgYXN5bmMvYXdhaXQgYWxzbyBtYWtlcyBpdCBlYXNpZXIgdG8gYXZvaWQgcmFjZVxuLy8gY29uZGl0aW9ucywgd2hpY2ggaXMgZXNwZWNpYWxseSBpbXBvcnRhbnQgYmVjYXVzZSBpcyBjYWNoZSBpcyBtdXRhYmxlLlxuLy9cbi8vIEFub3RoZXIgcmVhc29uIGlzIHRoYXQgd2hpbGUgd2UncmUgcGVyZm9ybWluZyBhc3luYyB3b3JrLCBpdCdzIHBvc3NpYmxlIGZvclxuLy8gZXhpc3RpbmcgZW50cmllcyB0byBiZWNvbWUgc3RhbGUsIG9yIGZvciBMaW5rIHByZWZldGNoZXMgdG8gYmUgcmVtb3ZlZCBmcm9tXG4vLyB0aGUgcXVldWUuIEZvciBvcHRpbWFsIHNjaGVkdWxpbmcsIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBcImNhbmNlbFwiIHN1YnRhc2tzXG4vLyB0aGF0IGFyZSBubyBsb25nZXIgbmVlZGVkLiBTbywgd2hlbiBhIHNlZ21lbnQgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCB3ZVxuLy8gcmVzdGFydCBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlIHRoYXQncyBiZWluZyBwcmVmZXRjaGVkLCB0byBjb25maXJtIGFsbCB0aGVcbi8vIHBhcmVudCBzZWdtZW50cyBhcmUgc3RpbGwgY2FjaGVkLiBJZiB0aGUgc2VnbWVudCBpcyBubyBsb25nZXIgcmVhY2hhYmxlIGZyb21cbi8vIHRoZSByb290LCB0aGVuIGl0J3MgZWZmZWN0aXZlbHkgY2FuY2VsZWQuIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgZGVzaWduIG9mXG4vLyBSdXN0IEZ1dHVyZXMsIG9yIFJlYWN0IFN1c3BlbnNlLlxuXG50eXBlIFJvdXRlVHJlZVNoYXJlZCA9IHtcbiAgcmVxdWVzdEtleTogU2VnbWVudFJlcXVlc3RLZXlcbiAgLy8gVE9ETzogUmVtb3ZlIHRoZSBgc2VnbWVudGAgZmllbGQsIG5vdyB0aGF0IGl0IGNhbiBiZSByZWNvbnN0cnVjdGVkXG4gIC8vIGZyb20gYHBhcmFtYC5cbiAgc2VnbWVudDogRmxpZ2h0Um91dGVyU3RhdGVTZWdtZW50XG4gIHNsb3RzOiBudWxsIHwge1xuICAgIFtwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmddOiBSb3V0ZVRyZWVcbiAgfVxuICBpc1Jvb3RMYXlvdXQ6IGJvb2xlYW5cblxuICAvLyBJZiB0aGlzIGlzIGEgZHluYW1pYyByb3V0ZSwgaW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYSBsb2FkaW5nIGJvdW5kYXJ5XG4gIC8vIHNvbWV3aGVyZSBpbiB0aGUgdHJlZS4gSWYgbm90LCB3ZSBjYW4gc2tpcCB0aGUgcHJlZmV0Y2ggZm9yIHRoZSBkYXRhLFxuICAvLyBiZWNhdXNlIHdlIGtub3cgaXQgd291bGQgYmUgYW4gZW1wdHkgcmVzcG9uc2UuIChGb3IgYSBzdGF0aWMvUFBSIHJvdXRlLFxuICAvLyB0aGlzIHZhbHVlIGlzIGRpc3JlZ2FyZGVkLCBiZWNhdXNlIGluIHRoYXQgbW9kZWwgYGxvYWRpbmcudHN4YCBpcyB0cmVhdGVkXG4gIC8vIGxpa2UgYW55IG90aGVyIFN1c3BlbnNlIGJvdW5kYXJ5LilcbiAgaGFzTG9hZGluZ0JvdW5kYXJ5OiBIYXNMb2FkaW5nQm91bmRhcnlcblxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHJvdXRlIGhhcyBhIHJ1bnRpbWUgcHJlZmV0Y2ggdGhhdCB3ZSBjYW4gcmVxdWVzdC5cbiAgLy8gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzZXJ2ZXI7IGl0J3Mgbm90IHB1cmVseSBhIHVzZXIgY29uZmlndXJhdGlvblxuICAvLyBiZWNhdXNlIHRoZSBzZXJ2ZXIgbWF5IGRldGVybWluZSB0aGF0IGEgcm91dGUgaXMgZnVsbHkgc3RhdGljIGFuZCBkb2Vzbid0XG4gIC8vIG5lZWQgcnVudGltZSBwcmVmZXRjaGluZyByZWdhcmRsZXNzIG9mIHRoZSBjb25maWd1cmF0aW9uLlxuICBoYXNSdW50aW1lUHJlZmV0Y2g6IGJvb2xlYW5cbn1cblxudHlwZSBMYXlvdXRSb3V0ZVRyZWUgPSBSb3V0ZVRyZWVTaGFyZWQgJiB7XG4gIGlzUGFnZTogZmFsc2VcbiAgdmFyeVBhdGg6IFNlZ21lbnRWYXJ5UGF0aFxufVxuXG50eXBlIFBhZ2VSb3V0ZVRyZWUgPSBSb3V0ZVRyZWVTaGFyZWQgJiB7XG4gIGlzUGFnZTogdHJ1ZVxuICB2YXJ5UGF0aDogUGFnZVZhcnlQYXRoXG59XG5cbmV4cG9ydCB0eXBlIFJvdXRlVHJlZSA9IExheW91dFJvdXRlVHJlZSB8IFBhZ2VSb3V0ZVRyZWVcblxudHlwZSBSb3V0ZUNhY2hlRW50cnlTaGFyZWQgPSB7XG4gIC8vIFRoaXMgaXMgZmFsc2Ugb25seSBpZiB3ZSdyZSBjZXJ0YWluIHRoZSByb3V0ZSBjYW5ub3QgYmUgaW50ZXJjZXB0ZWQuIEl0J3NcbiAgLy8gdHJ1ZSBpbiBhbGwgb3RoZXIgY2FzZXMsIGluY2x1ZGluZyBvbiBpbml0aWFsaXphdGlvbiB3aGVuIHdlIGhhdmVuJ3QgeWV0XG4gIC8vIHJlY2VpdmVkIGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cblxuICAvLyBNYXAtcmVsYXRlZCBmaWVsZHMuXG4gIHJlZjogVW5rbm93bk1hcEVudHJ5IHwgbnVsbFxuICBzaXplOiBudW1iZXJcbiAgc3RhbGVBdDogbnVtYmVyXG4gIHZlcnNpb246IG51bWJlclxufVxuXG4vKipcbiAqIFRyYWNrcyB0aGUgc3RhdHVzIG9mIGEgY2FjaGUgZW50cnkgYXMgaXQgcHJvZ3Jlc3NlcyBmcm9tIG5vIGRhdGEgKEVtcHR5KSxcbiAqIHdhaXRpbmcgZm9yIHNlcnZlciBkYXRhIChQZW5kaW5nKSwgYW5kIGZpbmlzaGVkIChlaXRoZXIgRnVsZmlsbGVkIG9yXG4gKiBSZWplY3RlZCBkZXBlbmRpbmcgb24gdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRW50cnlTdGF0dXMge1xuICBFbXB0eSA9IDAsXG4gIFBlbmRpbmcgPSAxLFxuICBGdWxmaWxsZWQgPSAyLFxuICBSZWplY3RlZCA9IDMsXG59XG5cbnR5cGUgUGVuZGluZ1JvdXRlQ2FjaGVFbnRyeSA9IFJvdXRlQ2FjaGVFbnRyeVNoYXJlZCAmIHtcbiAgc3RhdHVzOiBFbnRyeVN0YXR1cy5FbXB0eSB8IEVudHJ5U3RhdHVzLlBlbmRpbmdcbiAgYmxvY2tlZFRhc2tzOiBTZXQ8UHJlZmV0Y2hUYXNrPiB8IG51bGxcbiAgY2Fub25pY2FsVXJsOiBudWxsXG4gIHJlbmRlcmVkU2VhcmNoOiBudWxsXG4gIHRyZWU6IG51bGxcbiAgbWV0YWRhdGE6IG51bGxcbiAgaXNQUFJFbmFibGVkOiBmYWxzZVxufVxuXG50eXBlIFJlamVjdGVkUm91dGVDYWNoZUVudHJ5ID0gUm91dGVDYWNoZUVudHJ5U2hhcmVkICYge1xuICBzdGF0dXM6IEVudHJ5U3RhdHVzLlJlamVjdGVkXG4gIGJsb2NrZWRUYXNrczogU2V0PFByZWZldGNoVGFzaz4gfCBudWxsXG4gIGNhbm9uaWNhbFVybDogbnVsbFxuICByZW5kZXJlZFNlYXJjaDogbnVsbFxuICB0cmVlOiBudWxsXG4gIG1ldGFkYXRhOiBudWxsXG4gIGlzUFBSRW5hYmxlZDogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnkgPSBSb3V0ZUNhY2hlRW50cnlTaGFyZWQgJiB7XG4gIHN0YXR1czogRW50cnlTdGF0dXMuRnVsZmlsbGVkXG4gIGJsb2NrZWRUYXNrczogbnVsbFxuICBjYW5vbmljYWxVcmw6IHN0cmluZ1xuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaFxuICB0cmVlOiBSb3V0ZVRyZWVcbiAgbWV0YWRhdGE6IFJvdXRlVHJlZVxuICBpc1BQUkVuYWJsZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUm91dGVDYWNoZUVudHJ5ID1cbiAgfCBQZW5kaW5nUm91dGVDYWNoZUVudHJ5XG4gIHwgRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5XG4gIHwgUmVqZWN0ZWRSb3V0ZUNhY2hlRW50cnlcblxudHlwZSBTZWdtZW50Q2FjaGVFbnRyeVNoYXJlZCA9IHtcbiAgZmV0Y2hTdHJhdGVneTogRmV0Y2hTdHJhdGVneVxuXG4gIC8vIE1hcC1yZWxhdGVkIGZpZWxkcy5cbiAgcmVmOiBVbmtub3duTWFwRW50cnkgfCBudWxsXG4gIHNpemU6IG51bWJlclxuICBzdGFsZUF0OiBudW1iZXJcbiAgdmVyc2lvbjogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIEVtcHR5U2VnbWVudENhY2hlRW50cnkgPSBTZWdtZW50Q2FjaGVFbnRyeVNoYXJlZCAmIHtcbiAgc3RhdHVzOiBFbnRyeVN0YXR1cy5FbXB0eVxuICByc2M6IG51bGxcbiAgbG9hZGluZzogbnVsbFxuICBpc1BhcnRpYWw6IHRydWVcbiAgcHJvbWlzZTogbnVsbFxufVxuXG5leHBvcnQgdHlwZSBQZW5kaW5nU2VnbWVudENhY2hlRW50cnkgPSBTZWdtZW50Q2FjaGVFbnRyeVNoYXJlZCAmIHtcbiAgc3RhdHVzOiBFbnRyeVN0YXR1cy5QZW5kaW5nXG4gIHJzYzogbnVsbFxuICBsb2FkaW5nOiBudWxsXG4gIGlzUGFydGlhbDogYm9vbGVhblxuICBwcm9taXNlOiBudWxsIHwgUHJvbWlzZVdpdGhSZXNvbHZlcnM8RnVsZmlsbGVkU2VnbWVudENhY2hlRW50cnkgfCBudWxsPlxufVxuXG50eXBlIFJlamVjdGVkU2VnbWVudENhY2hlRW50cnkgPSBTZWdtZW50Q2FjaGVFbnRyeVNoYXJlZCAmIHtcbiAgc3RhdHVzOiBFbnRyeVN0YXR1cy5SZWplY3RlZFxuICByc2M6IG51bGxcbiAgbG9hZGluZzogbnVsbFxuICBpc1BhcnRpYWw6IHRydWVcbiAgcHJvbWlzZTogbnVsbFxufVxuXG5leHBvcnQgdHlwZSBGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeSA9IFNlZ21lbnRDYWNoZUVudHJ5U2hhcmVkICYge1xuICBzdGF0dXM6IEVudHJ5U3RhdHVzLkZ1bGZpbGxlZFxuICByc2M6IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGxcbiAgbG9hZGluZzogTG9hZGluZ01vZHVsZURhdGEgfCBQcm9taXNlPExvYWRpbmdNb2R1bGVEYXRhPlxuICBpc1BhcnRpYWw6IGJvb2xlYW5cbiAgcHJvbWlzZTogbnVsbFxufVxuXG5leHBvcnQgdHlwZSBTZWdtZW50Q2FjaGVFbnRyeSA9XG4gIHwgRW1wdHlTZWdtZW50Q2FjaGVFbnRyeVxuICB8IFBlbmRpbmdTZWdtZW50Q2FjaGVFbnRyeVxuICB8IFJlamVjdGVkU2VnbWVudENhY2hlRW50cnlcbiAgfCBGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeVxuXG5leHBvcnQgdHlwZSBOb25FbXB0eVNlZ21lbnRDYWNoZUVudHJ5ID0gRXhjbHVkZTxcbiAgU2VnbWVudENhY2hlRW50cnksXG4gIEVtcHR5U2VnbWVudENhY2hlRW50cnlcbj5cblxuY29uc3QgaXNPdXRwdXRFeHBvcnRNb2RlID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxuICBwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCdcblxuY29uc3QgTWV0YWRhdGFPbmx5UmVxdWVzdFRyZWU6IEZsaWdodFJvdXRlclN0YXRlID0gW1xuICAnJyxcbiAge30sXG4gIG51bGwsXG4gICdtZXRhZGF0YS1vbmx5Jyxcbl1cblxubGV0IHJvdXRlQ2FjaGVNYXA6IENhY2hlTWFwPFJvdXRlQ2FjaGVFbnRyeT4gPSBjcmVhdGVDYWNoZU1hcCgpXG5sZXQgc2VnbWVudENhY2hlTWFwOiBDYWNoZU1hcDxTZWdtZW50Q2FjaGVFbnRyeT4gPSBjcmVhdGVDYWNoZU1hcCgpXG5cbi8vIEFsbCBpbnZhbGlkYXRpb24gbGlzdGVuZXJzIGZvciB0aGUgd2hvbGUgY2FjaGUgYXJlIHRyYWNrZWQgaW4gc2luZ2xlIHNldC5cbi8vIFNpbmNlIHdlIGRvbid0IHlldCBzdXBwb3J0IHRhZyBvciBwYXRoLWJhc2VkIGludmFsaWRhdGlvbiwgdGhlcmUncyBubyBwb2ludFxuLy8gdHJhY2tpbmcgdGhlbSBhbnkgbW9yZSBncmFudWxhcmx5IHRoYW4gdGhpcy4gT25jZSB3ZSBhZGQgZ3JhbnVsYXJcbi8vIGludmFsaWRhdGlvbiwgdGhhdCBtYXkgY2hhbmdlLCB0aG91Z2ggZ2VuZXJhbGx5IHRoZSBtb2RlbCBpcyB0byBqdXN0IG5vdGlmeVxuLy8gdGhlIGxpc3RlbmVycyBhbmQgYWxsb3cgdGhlIGNhbGxlciB0byBwb2xsIHRoZSBwcmVmZXRjaCBjYWNoZSB3aXRoIGEgbmV3XG4vLyBwcmVmZXRjaCB0YXNrIGlmIGRlc2lyZWQuXG5sZXQgaW52YWxpZGF0aW9uTGlzdGVuZXJzOiBTZXQ8UHJlZmV0Y2hUYXNrPiB8IG51bGwgPSBudWxsXG5cbi8vIEluY3JlbWVudGluZyBjb3VudGVyIHVzZWQgdG8gdHJhY2sgY2FjaGUgaW52YWxpZGF0aW9ucy5cbmxldCBjdXJyZW50Q2FjaGVWZXJzaW9uID0gMFxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpOiBudW1iZXIge1xuICByZXR1cm4gY3VycmVudENhY2hlVmVyc2lvblxufVxuXG4vKipcbiAqIFVzZWQgdG8gY2xlYXIgdGhlIGNsaWVudCBwcmVmZXRjaCBjYWNoZSB3aGVuIGEgc2VydmVyIGFjdGlvbiBjYWxsc1xuICogcmV2YWxpZGF0ZVBhdGggb3IgcmV2YWxpZGF0ZVRhZy4gRXZlbnR1YWxseSB3ZSB3aWxsIHN1cHBvcnQgb25seSBjbGVhcmluZyB0aGVcbiAqIHNlZ21lbnRzIHRoYXQgd2VyZSBhY3R1YWxseSBhZmZlY3RlZCwgYnV0IHRoZXJlJ3MgbW9yZSB3b3JrIHRvIGJlIGRvbmUgb24gdGhlXG4gKiBzZXJ2ZXIgYmVmb3JlIHRoZSBjbGllbnQgaXMgYWJsZSB0byBkbyB0aGlzIGNvcnJlY3RseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmFsaWRhdGVFbnRpcmVDYWNoZShcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbCxcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbikge1xuICAvLyBJbmNyZW1lbnQgdGhlIGN1cnJlbnQgY2FjaGUgdmVyc2lvbi4gVGhpcyBkb2VzIG5vdCBlYWdlcmx5IGV2aWN0IGFueXRoaW5nXG4gIC8vIGZyb20gdGhlIGNhY2hlLCBidXQgYmVjYXVzZSBhbGwgdGhlIGVudHJpZXMgYXJlIHZlcnNpb25lZCwgYW5kIHdlIGNoZWNrXG4gIC8vIHRoZSB2ZXJzaW9uIHdoZW4gcmVhZGluZyBmcm9tIHRoZSBjYWNoZSwgdGhpcyBlZmZlY3RpdmVseSBjYXVzZXMgYWxsXG4gIC8vIGVudHJpZXMgdG8gYmUgZXZpY3RlZCBsYXppbHkuIFdlIGRvIGl0IGxhemlseSBiZWNhdXNlIGluIHRoZSBmdXR1cmUsXG4gIC8vIGFjdGlvbnMgbGlrZSByZXZhbGlkYXRlVGFnIG9yIHJlZnJlc2ggd2lsbCBub3QgZXZpY3QgdGhlIGVudGlyZSBjYWNoZSxcbiAgLy8gYnV0IHJhdGhlciBzb21lIHN1YnNldCBvZiB0aGUgZW50cmllcy5cbiAgY3VycmVudENhY2hlVmVyc2lvbisrXG5cbiAgLy8gU3RhcnQgYSBjb29sZG93biBiZWZvcmUgcmUtcHJlZmV0Y2hpbmcgdG8gYWxsb3cgQ0ROIGNhY2hlIHByb3BhZ2F0aW9uLlxuICBzdGFydFJldmFsaWRhdGlvbkNvb2xkb3duKClcblxuICAvLyBQcmVmZXRjaCBhbGwgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGxpbmtzIGFnYWluLCB0byByZS1maWxsIHRoZSBjYWNoZS5cbiAgcGluZ1Zpc2libGVMaW5rcyhuZXh0VXJsLCB0cmVlKVxuXG4gIC8vIFNpbWlsYXJseSwgbm90aWZ5IGFsbCBpbnZhbGlkYXRpb24gbGlzdGVuZXJzIChpLmUuIHRob3NlIHBhc3NlZCB0b1xuICAvLyBgcm91dGVyLnByZWZldGNoKG9uSW52YWxpZGF0ZSlgKSwgc28gdGhleSBjYW4gdHJpZ2dlciBhIG5ldyBwcmVmZXRjaFxuICAvLyBpZiBuZWVkZWQuXG4gIHBpbmdJbnZhbGlkYXRpb25MaXN0ZW5lcnMobmV4dFVybCwgdHJlZSlcbn1cblxuZnVuY3Rpb24gYXR0YWNoSW52YWxpZGF0aW9uTGlzdGVuZXIodGFzazogUHJlZmV0Y2hUYXNrKTogdm9pZCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIGEgcHJlZmV0Y2ggdGFzayByZWFkcyBhIGNhY2hlIGVudHJ5LiBJZlxuICAvLyB0aGUgdGFzayBoYXMgYW4gb25JbnZhbGlkYXRlIGZ1bmN0aW9uIGFzc29jaWF0ZWQgd2l0aCBpdCDigJQgaS5lLiB0aGUgb25lXG4gIC8vIG9wdGlvbmFsbHkgcGFzc2VkIHRvIHJvdXRlci5wcmVmZXRjaChvbkludmFsaWRhdGUpIOKAlCB0aGVuIHdlIGF0dGFjaCB0aGF0XG4gIC8vIGxpc3RlbmVyIHRvIHRoZSBldmVyeSBjYWNoZSBlbnRyeSB0aGF0IHRoZSB0YXNrIHJlYWRzLiBUaGVuLCBpZiBhbiBlbnRyeVxuICAvLyBpcyBpbnZhbGlkYXRlZCwgd2UgY2FsbCB0aGUgZnVuY3Rpb24uXG4gIGlmICh0YXNrLm9uSW52YWxpZGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChpbnZhbGlkYXRpb25MaXN0ZW5lcnMgPT09IG51bGwpIHtcbiAgICAgIGludmFsaWRhdGlvbkxpc3RlbmVycyA9IG5ldyBTZXQoW3Rhc2tdKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhbGlkYXRpb25MaXN0ZW5lcnMuYWRkKHRhc2spXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vdGlmeUludmFsaWRhdGlvbkxpc3RlbmVyKHRhc2s6IFByZWZldGNoVGFzayk6IHZvaWQge1xuICBjb25zdCBvbkludmFsaWRhdGUgPSB0YXNrLm9uSW52YWxpZGF0ZVxuICBpZiAob25JbnZhbGlkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gQ2xlYXIgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHRhc2sgb2JqZWN0IHRvIGd1YXJhbnRlZSBpdCdzIG5vdCBjYWxsZWQgbW9yZVxuICAgIC8vIHRoYW4gb25jZS5cbiAgICB0YXNrLm9uSW52YWxpZGF0ZSA9IG51bGxcblxuICAgIC8vIFRoaXMgaXMgYSB1c2VyLXNwYWNlIGZ1bmN0aW9uLCBzbyB3ZSBtdXN0IHdyYXAgaW4gdHJ5L2NhdGNoLlxuICAgIHRyeSB7XG4gICAgICBvbkludmFsaWRhdGUoKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcG9ydEVycm9yKGVycm9yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpbmdJbnZhbGlkYXRpb25MaXN0ZW5lcnMoXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiB2b2lkIHtcbiAgLy8gVGhlIHJvdWdoIGVxdWl2YWxlbnQgb2YgcGluZ1Zpc2libGVMaW5rcywgYnV0IGZvciBvbkludmFsaWRhdGUgY2FsbGJhY2tzLlxuICAvLyBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBOZXh0LVVybCBvciB0aGUgYmFzZSB0cmVlIGNoYW5nZXMsIHNpbmNlIHRob3NlXG4gIC8vIG1heSBhZmZlY3QgdGhlIHJlc3VsdCBvZiBhIHByZWZldGNoIHRhc2suIEl0J3MgYWxzbyBjYWxsZWQgYWZ0ZXIgYVxuICAvLyBjYWNoZSBpbnZhbGlkYXRpb24uXG4gIGlmIChpbnZhbGlkYXRpb25MaXN0ZW5lcnMgIT09IG51bGwpIHtcbiAgICBjb25zdCB0YXNrcyA9IGludmFsaWRhdGlvbkxpc3RlbmVyc1xuICAgIGludmFsaWRhdGlvbkxpc3RlbmVycyA9IG51bGxcbiAgICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICAgIGlmIChpc1ByZWZldGNoVGFza0RpcnR5KHRhc2ssIG5leHRVcmwsIHRyZWUpKSB7XG4gICAgICAgIG5vdGlmeUludmFsaWRhdGlvbkxpc3RlbmVyKHRhc2spXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkUm91dGVDYWNoZUVudHJ5KFxuICBub3c6IG51bWJlcixcbiAga2V5OiBSb3V0ZUNhY2hlS2V5XG4pOiBSb3V0ZUNhY2hlRW50cnkgfCBudWxsIHtcbiAgY29uc3QgdmFyeVBhdGg6IFJvdXRlVmFyeVBhdGggPSBnZXRSb3V0ZVZhcnlQYXRoKFxuICAgIGtleS5wYXRobmFtZSxcbiAgICBrZXkuc2VhcmNoLFxuICAgIGtleS5uZXh0VXJsXG4gIClcbiAgY29uc3QgaXNSZXZhbGlkYXRpb24gPSBmYWxzZVxuICByZXR1cm4gZ2V0RnJvbUNhY2hlTWFwKFxuICAgIG5vdyxcbiAgICBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uKCksXG4gICAgcm91dGVDYWNoZU1hcCxcbiAgICB2YXJ5UGF0aCxcbiAgICBpc1JldmFsaWRhdGlvblxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU2VnbWVudENhY2hlRW50cnkoXG4gIG5vdzogbnVtYmVyLFxuICB2YXJ5UGF0aDogU2VnbWVudFZhcnlQYXRoXG4pOiBTZWdtZW50Q2FjaGVFbnRyeSB8IG51bGwge1xuICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IGZhbHNlXG4gIHJldHVybiBnZXRGcm9tQ2FjaGVNYXAoXG4gICAgbm93LFxuICAgIGdldEN1cnJlbnRDYWNoZVZlcnNpb24oKSxcbiAgICBzZWdtZW50Q2FjaGVNYXAsXG4gICAgdmFyeVBhdGgsXG4gICAgaXNSZXZhbGlkYXRpb25cbiAgKVxufVxuXG5mdW5jdGlvbiByZWFkUmV2YWxpZGF0aW5nU2VnbWVudENhY2hlRW50cnkoXG4gIG5vdzogbnVtYmVyLFxuICB2YXJ5UGF0aDogU2VnbWVudFZhcnlQYXRoXG4pOiBTZWdtZW50Q2FjaGVFbnRyeSB8IG51bGwge1xuICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IHRydWVcbiAgcmV0dXJuIGdldEZyb21DYWNoZU1hcChcbiAgICBub3csXG4gICAgZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpLFxuICAgIHNlZ21lbnRDYWNoZU1hcCxcbiAgICB2YXJ5UGF0aCxcbiAgICBpc1JldmFsaWRhdGlvblxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWl0Rm9yU2VnbWVudENhY2hlRW50cnkoXG4gIHBlbmRpbmdFbnRyeTogUGVuZGluZ1NlZ21lbnRDYWNoZUVudHJ5XG4pOiBQcm9taXNlPEZ1bGZpbGxlZFNlZ21lbnRDYWNoZUVudHJ5IHwgbnVsbD4ge1xuICAvLyBCZWNhdXNlIHRoZSBlbnRyeSBpcyBwZW5kaW5nLCB0aGVyZSdzIGFscmVhZHkgYSBpbi1wcm9ncmVzcyByZXF1ZXN0LlxuICAvLyBBdHRhY2ggYSBwcm9taXNlIHRvIHRoZSBlbnRyeSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uZHMuXG4gIGxldCBwcm9taXNlV2l0aFJlc29sdmVycyA9IHBlbmRpbmdFbnRyeS5wcm9taXNlXG4gIGlmIChwcm9taXNlV2l0aFJlc29sdmVycyA9PT0gbnVsbCkge1xuICAgIHByb21pc2VXaXRoUmVzb2x2ZXJzID0gcGVuZGluZ0VudHJ5LnByb21pc2UgPVxuICAgICAgY3JlYXRlUHJvbWlzZVdpdGhSZXNvbHZlcnM8RnVsZmlsbGVkU2VnbWVudENhY2hlRW50cnkgfCBudWxsPigpXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgcHJvbWlzZSB3ZSBjYW4gdXNlXG4gIH1cbiAgcmV0dXJuIHByb21pc2VXaXRoUmVzb2x2ZXJzLnByb21pc2Vcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZW50cnkgZm9yIGEgcm91dGUgZXhpc3RzIGluIHRoZSBjYWNoZS4gSWYgc28sIGl0IHJldHVybnMgdGhlXG4gKiBlbnRyeSwgSWYgbm90LCBpdCBhZGRzIGFuIGVtcHR5IGVudHJ5IHRvIHRoZSBjYWNoZSBhbmQgcmV0dXJucyBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRPckNyZWF0ZVJvdXRlQ2FjaGVFbnRyeShcbiAgbm93OiBudW1iZXIsXG4gIHRhc2s6IFByZWZldGNoVGFzayxcbiAga2V5OiBSb3V0ZUNhY2hlS2V5XG4pOiBSb3V0ZUNhY2hlRW50cnkge1xuICBhdHRhY2hJbnZhbGlkYXRpb25MaXN0ZW5lcih0YXNrKVxuXG4gIGNvbnN0IGV4aXN0aW5nRW50cnkgPSByZWFkUm91dGVDYWNoZUVudHJ5KG5vdywga2V5KVxuICBpZiAoZXhpc3RpbmdFbnRyeSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBleGlzdGluZ0VudHJ5XG4gIH1cbiAgLy8gQ3JlYXRlIGEgcGVuZGluZyBlbnRyeSBhbmQgYWRkIGl0IHRvIHRoZSBjYWNoZS5cbiAgY29uc3QgcGVuZGluZ0VudHJ5OiBQZW5kaW5nUm91dGVDYWNoZUVudHJ5ID0ge1xuICAgIGNhbm9uaWNhbFVybDogbnVsbCxcbiAgICBzdGF0dXM6IEVudHJ5U3RhdHVzLkVtcHR5LFxuICAgIGJsb2NrZWRUYXNrczogbnVsbCxcbiAgICB0cmVlOiBudWxsLFxuICAgIG1ldGFkYXRhOiBudWxsLFxuICAgIC8vIFRoaXMgaXMgaW5pdGlhbGl6ZWQgdG8gdHJ1ZSBiZWNhdXNlIHdlIGRvbid0IGtub3cgeWV0IHdoZXRoZXIgdGhlIHJvdXRlXG4gICAgLy8gY291bGQgYmUgaW50ZXJjZXB0ZWQuIEl0J3Mgb25seSBzZXQgdG8gZmFsc2Ugb25jZSB3ZSByZWNlaXZlIGEgcmVzcG9uc2VcbiAgICAvLyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgY291bGRCZUludGVyY2VwdGVkOiB0cnVlLFxuICAgIC8vIFNpbWlsYXJseSwgd2UgZG9uJ3QgeWV0IGtub3cgaWYgdGhlIHJvdXRlIHN1cHBvcnRzIFBQUi5cbiAgICBpc1BQUkVuYWJsZWQ6IGZhbHNlLFxuICAgIHJlbmRlcmVkU2VhcmNoOiBudWxsLFxuXG4gICAgLy8gTWFwLXJlbGF0ZWQgZmllbGRzXG4gICAgcmVmOiBudWxsLFxuICAgIHNpemU6IDAsXG4gICAgLy8gU2luY2UgdGhpcyBpcyBhbiBlbXB0eSBlbnRyeSwgdGhlcmUncyBubyByZWFzb24gdG8gZXZlciBldmljdCBpdC4gSXQgd2lsbFxuICAgIC8vIGJlIHVwZGF0ZWQgd2hlbiB0aGUgZGF0YSBpcyBwb3B1bGF0ZWQuXG4gICAgc3RhbGVBdDogSW5maW5pdHksXG4gICAgdmVyc2lvbjogZ2V0Q3VycmVudENhY2hlVmVyc2lvbigpLFxuICB9XG4gIGNvbnN0IHZhcnlQYXRoOiBSb3V0ZVZhcnlQYXRoID0gZ2V0Um91dGVWYXJ5UGF0aChcbiAgICBrZXkucGF0aG5hbWUsXG4gICAga2V5LnNlYXJjaCxcbiAgICBrZXkubmV4dFVybFxuICApXG4gIGNvbnN0IGlzUmV2YWxpZGF0aW9uID0gZmFsc2VcbiAgc2V0SW5DYWNoZU1hcChyb3V0ZUNhY2hlTWFwLCB2YXJ5UGF0aCwgcGVuZGluZ0VudHJ5LCBpc1JldmFsaWRhdGlvbilcbiAgcmV0dXJuIHBlbmRpbmdFbnRyeVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdE9wdGltaXN0aWNSb3V0ZUNhY2hlRW50cnkoXG4gIG5vdzogbnVtYmVyLFxuICByZXF1ZXN0ZWRVcmw6IFVSTCxcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbFxuKTogRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5IHwgbnVsbCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyBhIG5hdmlnYXRpb24gd2hlbiB0aGVyZSB3YXMgbm8gbWF0Y2hpbmdcbiAgLy8gcm91dGUgdHJlZSBpbiB0aGUgcHJlZmV0Y2ggY2FjaGUuIEJlZm9yZSBkZS1vcHRpbmcgdG8gYSBibG9ja2luZyxcbiAgLy8gdW5wcmVmZXRjaGVkIG5hdmlnYXRpb24sIHdlIHdpbGwgZmlyc3QgYXR0ZW1wdCB0byBjb25zdHJ1Y3QgYW4gXCJvcHRpbWlzdGljXCJcbiAgLy8gcm91dGUgdHJlZSBieSBjaGVja2luZyB0aGUgY2FjaGUgZm9yIHNpbWlsYXIgcm91dGVzLlxuICAvL1xuICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBwYXRobmFtZSwgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIHNlYXJjaCBwYXJhbXMuIFdlIGNhbiB0aGVuIGJhc2Ugb3VyIG9wdGltaXN0aWMgcm91dGUgdHJlZSBvbiB0aGlzIGVudHJ5LlxuICAvL1xuICAvLyBDb25jZXB0dWFsbHksIHdlIGFyZSBzaW11bGF0aW5nIHdoYXQgd291bGQgaGFwcGVuIGlmIHdlIGRpZCBwZXJmb3JtIGFcbiAgLy8gcHJlZmV0Y2ggdGhlIHJlcXVlc3RlZCBVUkwsIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIHNlcnZlciB3aWxsXG4gIC8vIG5vdCByZWRpcmVjdCBvciByZXdyaXRlIHRoZSByZXF1ZXN0IGluIGEgZGlmZmVyZW50IG1hbm5lciB0aGFuIHRoZVxuICAvLyBiYXNlIHJvdXRlIHRyZWUuIFRoaXMgYXNzdW1wdGlvbiBtaWdodCBub3QgaG9sZCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCBoYXZlXG4gIC8vIHRvIHJlY292ZXIgd2hlbiB3ZSBwZXJmb3JtIHRoZSBkeW5hbWljIG5hdmlnYXRpb24gcmVxdWVzdC4gSG93ZXZlciwgdGhpc1xuICAvLyBpcyB3aGF0IHdvdWxkIGhhcHBlbiBpZiBhIHJvdXRlIHdlcmUgZHluYW1pY2FsbHkgcmV3cml0dGVuL3JlZGlyZWN0ZWRcbiAgLy8gaW4gYmV0d2VlbiB0aGUgcHJlZmV0Y2ggYW5kIHRoZSBuYXZpZ2F0aW9uLiBTbyB0aGUgbG9naWMgbmVlZHMgdG8gZXhpc3RcbiAgLy8gdG8gaGFuZGxlIHRoaXMgY2FzZSByZWdhcmRsZXNzLlxuXG4gIC8vIExvb2sgZm9yIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBwYXRobmFtZSwgYnV0IHdpdGggYW4gZW1wdHkgc2VhcmNoIHN0cmluZy5cbiAgLy8gVE9ETzogVGhlcmUncyBub3RoaW5nIGluaGVyZW50bHkgc3BlY2lhbCBhYm91dCB0aGUgZW1wdHkgc2VhcmNoIHN0cmluZztcbiAgLy8gaXQncyBjaG9zZW4gc29tZXdoYXQgYXJiaXRyYXJpbHksIHdpdGggdGhlIHJhdGlvbmFsZSB0aGF0IGl0J3MgdGhlIG1vc3RcbiAgLy8gbGlrZWx5IG9uZSB0byBleGlzdC4gQnV0IHdlIHNob3VsZCB1cGRhdGUgdGhpcyB0byBtYXRjaCBfYW55XyBzZWFyY2hcbiAgLy8gc3RyaW5nLiBUaGUgcGxhbiBpcyB0byBnZW5lcmFsaXplIHRoaXMgbG9naWMgYWxvbmdzaWRlIG90aGVyIGltcHJvdmVtZW50c1xuICAvLyByZWxhdGVkIHRvIFwiZmFsbGJhY2tcIiBjYWNoZSBlbnRyaWVzLlxuICBjb25zdCByZXF1ZXN0ZWRTZWFyY2ggPSByZXF1ZXN0ZWRVcmwuc2VhcmNoIGFzIE5vcm1hbGl6ZWRTZWFyY2hcbiAgaWYgKHJlcXVlc3RlZFNlYXJjaCA9PT0gJycpIHtcbiAgICAvLyBUaGUgY2FsbGVyIHdvdWxkIGhhdmUgYWxyZWFkeSBjaGVja2VkIGlmIGEgcm91dGUgd2l0aCBhbiBlbXB0eSBzZWFyY2hcbiAgICAvLyBzdHJpbmcgaXMgaW4gdGhlIGNhY2hlLiBTbyB3ZSBjYW4gYmFpbCBvdXQgaGVyZS5cbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IHVybFdpdGhvdXRTZWFyY2hQYXJhbXMgPSBuZXcgVVJMKHJlcXVlc3RlZFVybClcbiAgdXJsV2l0aG91dFNlYXJjaFBhcmFtcy5zZWFyY2ggPSAnJ1xuICBjb25zdCByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcyA9IHJlYWRSb3V0ZUNhY2hlRW50cnkoXG4gICAgbm93LFxuICAgIGNyZWF0ZVByZWZldGNoUmVxdWVzdEtleSh1cmxXaXRob3V0U2VhcmNoUGFyYW1zLmhyZWYsIG5leHRVcmwpXG4gIClcblxuICBpZiAoXG4gICAgcm91dGVXaXRoTm9TZWFyY2hQYXJhbXMgPT09IG51bGwgfHxcbiAgICByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5zdGF0dXMgIT09IEVudHJ5U3RhdHVzLkZ1bGZpbGxlZFxuICApIHtcbiAgICAvLyBCYWlsIG91dCBvZiBjb25zdHJ1Y3RpbmcgYW4gb3B0aW1pc3RpYyByb3V0ZSB0cmVlLiBUaGlzIHdpbGwgcmVzdWx0IGluXG4gICAgLy8gYSBibG9ja2luZywgdW5wcmVmZXRjaGVkIG5hdmlnYXRpb24uXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIE5vdyB3ZSBoYXZlIGEgYmFzZSByb3V0ZSB0cmVlIHdlIGNhbiBcInBhdGNoXCIgd2l0aCBvdXIgb3B0aW1pc3RpYyB2YWx1ZXMuXG5cbiAgLy8gT3B0aW1pc3RpY2FsbHkgYXNzdW1lIHRoYXQgcmVkaXJlY3RzIGZvciB0aGUgcmVxdWVzdGVkIHBhdGhuYW1lIGRvXG4gIC8vIG5vdCB2YXJ5IG9uIHRoZSBzZWFyY2ggc3RyaW5nLiBUaGVyZWZvcmUsIGlmIHRoZSBiYXNlIHJvdXRlIHdhc1xuICAvLyByZWRpcmVjdGVkIHRvIGEgZGlmZmVyZW50IHNlYXJjaCBzdHJpbmcsIHRoZW4gdGhlIG9wdGltaXN0aWMgcm91dGVcbiAgLy8gc2hvdWxkIGJlIHJlZGlyZWN0ZWQgdG8gdGhlIHNhbWUgc2VhcmNoIHN0cmluZy4gT3RoZXJ3aXNlLCB3ZSB1c2VcbiAgLy8gdGhlIHJlcXVlc3RlZCBzZWFyY2ggc3RyaW5nLlxuICBjb25zdCBjYW5vbmljYWxVcmxGb3JSb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcyA9IG5ldyBVUkwoXG4gICAgcm91dGVXaXRoTm9TZWFyY2hQYXJhbXMuY2Fub25pY2FsVXJsLFxuICAgIHJlcXVlc3RlZFVybC5vcmlnaW5cbiAgKVxuICBjb25zdCBvcHRpbWlzdGljQ2Fub25pY2FsU2VhcmNoID1cbiAgICBjYW5vbmljYWxVcmxGb3JSb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5zZWFyY2ggIT09ICcnXG4gICAgICA/IC8vIEJhc2Ugcm91dGUgd2FzIHJlZGlyZWN0ZWQuIFJldXNlIHRoZSBzYW1lIHJlZGlyZWN0ZWQgc2VhcmNoIHN0cmluZy5cbiAgICAgICAgY2Fub25pY2FsVXJsRm9yUm91dGVXaXRoTm9TZWFyY2hQYXJhbXMuc2VhcmNoXG4gICAgICA6IHJlcXVlc3RlZFNlYXJjaFxuXG4gIC8vIFNpbWlsYXJseSwgb3B0aW1pc3RpY2FsbHkgYXNzdW1lIHRoYXQgcmV3cml0ZXMgZm9yIHRoZSByZXF1ZXN0ZWRcbiAgLy8gcGF0aG5hbWUgZG8gbm90IHZhcnkgb24gdGhlIHNlYXJjaCBzdHJpbmcuIFRoZXJlZm9yZSwgaWYgdGhlIGJhc2VcbiAgLy8gcm91dGUgd2FzIHJld3JpdHRlbiB0byBhIGRpZmZlcmVudCBzZWFyY2ggc3RyaW5nLCB0aGVuIHRoZSBvcHRpbWlzdGljXG4gIC8vIHJvdXRlIHNob3VsZCBiZSByZXdyaXR0ZW4gdG8gdGhlIHNhbWUgc2VhcmNoIHN0cmluZy4gT3RoZXJ3aXNlLCB3ZSB1c2VcbiAgLy8gdGhlIHJlcXVlc3RlZCBzZWFyY2ggc3RyaW5nLlxuICBjb25zdCBvcHRpbWlzdGljUmVuZGVyZWRTZWFyY2ggPVxuICAgIHJvdXRlV2l0aE5vU2VhcmNoUGFyYW1zLnJlbmRlcmVkU2VhcmNoICE9PSAnJ1xuICAgICAgPyAvLyBCYXNlIHJvdXRlIHdhcyByZXdyaXR0ZW4uIFJldXNlIHRoZSBzYW1lIHJld3JpdHRlbiBzZWFyY2ggc3RyaW5nLlxuICAgICAgICByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5yZW5kZXJlZFNlYXJjaFxuICAgICAgOiByZXF1ZXN0ZWRTZWFyY2hcblxuICBjb25zdCBvcHRpbWlzdGljVXJsID0gbmV3IFVSTChcbiAgICByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5jYW5vbmljYWxVcmwsXG4gICAgbG9jYXRpb24ub3JpZ2luXG4gIClcbiAgb3B0aW1pc3RpY1VybC5zZWFyY2ggPSBvcHRpbWlzdGljQ2Fub25pY2FsU2VhcmNoXG4gIGNvbnN0IG9wdGltaXN0aWNDYW5vbmljYWxVcmwgPSBjcmVhdGVIcmVmRnJvbVVybChvcHRpbWlzdGljVXJsKVxuXG4gIGNvbnN0IG9wdGltaXN0aWNSb3V0ZVRyZWUgPSBjcmVhdGVPcHRpbWlzdGljUm91dGVUcmVlKFxuICAgIHJvdXRlV2l0aE5vU2VhcmNoUGFyYW1zLnRyZWUsXG4gICAgb3B0aW1pc3RpY1JlbmRlcmVkU2VhcmNoXG4gIClcbiAgY29uc3Qgb3B0aW1pc3RpY01ldGFkYXRhVHJlZSA9IGNyZWF0ZU9wdGltaXN0aWNSb3V0ZVRyZWUoXG4gICAgcm91dGVXaXRoTm9TZWFyY2hQYXJhbXMubWV0YWRhdGEsXG4gICAgb3B0aW1pc3RpY1JlbmRlcmVkU2VhcmNoXG4gIClcblxuICAvLyBDbG9uZSB0aGUgYmFzZSByb3V0ZSB0cmVlLCBhbmQgb3ZlcnJpZGUgdGhlIHJlbGV2YW50IGZpZWxkcyB3aXRoIG91clxuICAvLyBvcHRpbWlzdGljIHZhbHVlcy5cbiAgY29uc3Qgb3B0aW1pc3RpY0VudHJ5OiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnkgPSB7XG4gICAgY2Fub25pY2FsVXJsOiBvcHRpbWlzdGljQ2Fub25pY2FsVXJsLFxuXG4gICAgc3RhdHVzOiBFbnRyeVN0YXR1cy5GdWxmaWxsZWQsXG4gICAgLy8gVGhpcyBpc24ndCBjbG9uZWQgYmVjYXVzZSBpdCdzIGluc3RhbmNlLXNwZWNpZmljXG4gICAgYmxvY2tlZFRhc2tzOiBudWxsLFxuICAgIHRyZWU6IG9wdGltaXN0aWNSb3V0ZVRyZWUsXG4gICAgbWV0YWRhdGE6IG9wdGltaXN0aWNNZXRhZGF0YVRyZWUsXG4gICAgY291bGRCZUludGVyY2VwdGVkOiByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5jb3VsZEJlSW50ZXJjZXB0ZWQsXG4gICAgaXNQUFJFbmFibGVkOiByb3V0ZVdpdGhOb1NlYXJjaFBhcmFtcy5pc1BQUkVuYWJsZWQsXG5cbiAgICAvLyBPdmVycmlkZSB0aGUgcmVuZGVyZWQgc2VhcmNoIHdpdGggdGhlIG9wdGltaXN0aWMgdmFsdWUuXG4gICAgcmVuZGVyZWRTZWFyY2g6IG9wdGltaXN0aWNSZW5kZXJlZFNlYXJjaCxcblxuICAgIC8vIE1hcC1yZWxhdGVkIGZpZWxkc1xuICAgIHJlZjogbnVsbCxcbiAgICBzaXplOiAwLFxuICAgIHN0YWxlQXQ6IHJvdXRlV2l0aE5vU2VhcmNoUGFyYW1zLnN0YWxlQXQsXG4gICAgdmVyc2lvbjogcm91dGVXaXRoTm9TZWFyY2hQYXJhbXMudmVyc2lvbixcbiAgfVxuXG4gIC8vIERvIG5vdCBpbnNlcnQgdGhpcyBlbnRyeSBpbnRvIHRoZSBjYWNoZS4gSXQgb25seSBleGlzdHMgc28gd2UgY2FuXG4gIC8vIHBlcmZvcm0gdGhlIGN1cnJlbnQgbmF2aWdhdGlvbi4gSnVzdCByZXR1cm4gaXQgdG8gdGhlIGNhbGxlci5cbiAgcmV0dXJuIG9wdGltaXN0aWNFbnRyeVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljUm91dGVUcmVlKFxuICB0cmVlOiBSb3V0ZVRyZWUsXG4gIG5ld1JlbmRlcmVkU2VhcmNoOiBOb3JtYWxpemVkU2VhcmNoXG4pOiBSb3V0ZVRyZWUge1xuICAvLyBDcmVhdGUgYSBuZXcgcm91dGUgdHJlZSB0aGF0IGlkZW50aWNhbCB0byB0aGUgb3JpZ2luYWwgb25lIGV4Y2VwdCBmb3JcbiAgLy8gdGhlIHJlbmRlcmVkIHNlYXJjaCBzdHJpbmcsIHdoaWNoIGlzIGNvbnRhaW5lZCBpbiB0aGUgdmFyeSBwYXRoLlxuXG4gIGxldCBjbG9uZWRTbG90czogUmVjb3JkPHN0cmluZywgUm91dGVUcmVlPiB8IG51bGwgPSBudWxsXG4gIGNvbnN0IG9yaWdpbmFsU2xvdHMgPSB0cmVlLnNsb3RzXG4gIGlmIChvcmlnaW5hbFNsb3RzICE9PSBudWxsKSB7XG4gICAgY2xvbmVkU2xvdHMgPSB7fVxuICAgIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBpbiBvcmlnaW5hbFNsb3RzKSB7XG4gICAgICBjb25zdCBjaGlsZFRyZWUgPSBvcmlnaW5hbFNsb3RzW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICBjbG9uZWRTbG90c1twYXJhbGxlbFJvdXRlS2V5XSA9IGNyZWF0ZU9wdGltaXN0aWNSb3V0ZVRyZWUoXG4gICAgICAgIGNoaWxkVHJlZSxcbiAgICAgICAgbmV3UmVuZGVyZWRTZWFyY2hcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBXZSBvbmx5IG5lZWQgdG8gY2xvbmUgdGhlIHZhcnkgcGF0aCBpZiB0aGUgcm91dGUgaXMgYSBwYWdlLlxuICBpZiAodHJlZS5pc1BhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdEtleTogdHJlZS5yZXF1ZXN0S2V5LFxuICAgICAgc2VnbWVudDogdHJlZS5zZWdtZW50LFxuICAgICAgdmFyeVBhdGg6IGNsb25lUGFnZVZhcnlQYXRoV2l0aE5ld1NlYXJjaFBhcmFtcyhcbiAgICAgICAgdHJlZS52YXJ5UGF0aCxcbiAgICAgICAgbmV3UmVuZGVyZWRTZWFyY2hcbiAgICAgICksXG4gICAgICBpc1BhZ2U6IHRydWUsXG4gICAgICBzbG90czogY2xvbmVkU2xvdHMsXG4gICAgICBpc1Jvb3RMYXlvdXQ6IHRyZWUuaXNSb290TGF5b3V0LFxuICAgICAgaGFzTG9hZGluZ0JvdW5kYXJ5OiB0cmVlLmhhc0xvYWRpbmdCb3VuZGFyeSxcbiAgICAgIGhhc1J1bnRpbWVQcmVmZXRjaDogdHJlZS5oYXNSdW50aW1lUHJlZmV0Y2gsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZXF1ZXN0S2V5OiB0cmVlLnJlcXVlc3RLZXksXG4gICAgc2VnbWVudDogdHJlZS5zZWdtZW50LFxuICAgIHZhcnlQYXRoOiB0cmVlLnZhcnlQYXRoLFxuICAgIGlzUGFnZTogZmFsc2UsXG4gICAgc2xvdHM6IGNsb25lZFNsb3RzLFxuICAgIGlzUm9vdExheW91dDogdHJlZS5pc1Jvb3RMYXlvdXQsXG4gICAgaGFzTG9hZGluZ0JvdW5kYXJ5OiB0cmVlLmhhc0xvYWRpbmdCb3VuZGFyeSxcbiAgICBoYXNSdW50aW1lUHJlZmV0Y2g6IHRyZWUuaGFzUnVudGltZVByZWZldGNoLFxuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGVudHJ5IGZvciBhIHNlZ21lbnQgZXhpc3RzIGluIHRoZSBjYWNoZS4gSWYgc28sIGl0IHJldHVybnMgdGhlXG4gKiBlbnRyeSwgSWYgbm90LCBpdCBhZGRzIGFuIGVtcHR5IGVudHJ5IHRvIHRoZSBjYWNoZSBhbmQgcmV0dXJucyBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRPckNyZWF0ZVNlZ21lbnRDYWNoZUVudHJ5KFxuICBub3c6IG51bWJlcixcbiAgZmV0Y2hTdHJhdGVneTogRmV0Y2hTdHJhdGVneSxcbiAgcm91dGU6IEZ1bGZpbGxlZFJvdXRlQ2FjaGVFbnRyeSxcbiAgdHJlZTogUm91dGVUcmVlXG4pOiBTZWdtZW50Q2FjaGVFbnRyeSB7XG4gIGNvbnN0IGV4aXN0aW5nRW50cnkgPSByZWFkU2VnbWVudENhY2hlRW50cnkobm93LCB0cmVlLnZhcnlQYXRoKVxuICBpZiAoZXhpc3RpbmdFbnRyeSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBleGlzdGluZ0VudHJ5XG4gIH1cbiAgLy8gQ3JlYXRlIGEgcGVuZGluZyBlbnRyeSBhbmQgYWRkIGl0IHRvIHRoZSBjYWNoZS5cbiAgY29uc3QgdmFyeVBhdGhGb3JSZXF1ZXN0ID0gZ2V0U2VnbWVudFZhcnlQYXRoRm9yUmVxdWVzdChmZXRjaFN0cmF0ZWd5LCB0cmVlKVxuICBjb25zdCBwZW5kaW5nRW50cnkgPSBjcmVhdGVEZXRhY2hlZFNlZ21lbnRDYWNoZUVudHJ5KHJvdXRlLnN0YWxlQXQpXG4gIGNvbnN0IGlzUmV2YWxpZGF0aW9uID0gZmFsc2VcbiAgc2V0SW5DYWNoZU1hcChcbiAgICBzZWdtZW50Q2FjaGVNYXAsXG4gICAgdmFyeVBhdGhGb3JSZXF1ZXN0LFxuICAgIHBlbmRpbmdFbnRyeSxcbiAgICBpc1JldmFsaWRhdGlvblxuICApXG4gIHJldHVybiBwZW5kaW5nRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRPckNyZWF0ZVJldmFsaWRhdGluZ1NlZ21lbnRFbnRyeShcbiAgbm93OiBudW1iZXIsXG4gIGZldGNoU3RyYXRlZ3k6IEZldGNoU3RyYXRlZ3ksXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIHRyZWU6IFJvdXRlVHJlZVxuKTogU2VnbWVudENhY2hlRW50cnkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHdlJ3ZlIGFscmVhZHkgY29uZmlybWVkIHRoYXQgYSBwYXJ0aWN1bGFyXG4gIC8vIHNlZ21lbnQgaXMgY2FjaGVkLCBidXQgd2Ugd2FudCB0byBwZXJmb3JtIGFub3RoZXIgcmVxdWVzdCBhbnl3YXkgaW4gY2FzZSBpdFxuICAvLyByZXR1cm5zIG1vcmUgY29tcGxldGUgYW5kL29yIGZyZXNoZXIgZGF0YSB0aGFuIHdlIGFscmVhZHkgaGF2ZS4gVGhlIGxvZ2ljXG4gIC8vIGZvciBkZWNpZGluZyB3aGV0aGVyIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGVudHJ5IGlzIGhhbmRsZWQgZWxzZXdoZXJlO1xuICAvLyB0aGlzIGZ1bmN0aW9uIGp1c3QgaGFuZGxlcyByZXRyaWV2aW5nIGEgY2FjaGUgZW50cnkgdGhhdCB3ZSBjYW4gdXNlIHRvXG4gIC8vIHRyYWNrIHRoZSByZXZhbGlkYXRpb24uXG4gIC8vXG4gIC8vIFRoZSByZWFzb24gcmV2YWxpZGF0aW9ucyBhcmUgc3RvcmVkIGluIHRoZSBjYWNoZSBpcyBiZWNhdXNlIHdlIG5lZWQgdG8gYmVcbiAgLy8gYWJsZSB0byBkZWR1cGUgbXVsdGlwbGUgcmV2YWxpZGF0aW9uIHJlcXVlc3RzLiBUaGUgcmVhc29uIHRoZXkgaGF2ZSB0byBiZVxuICAvLyBoYW5kbGVkIHNwZWNpYWxseSBpcyBiZWNhdXNlIHdlIHNob3VsZG4ndCBvdmVyd3JpdGUgYSBcIm5vcm1hbFwiIGVudHJ5IGlmXG4gIC8vIG9uZSBleGlzdHMgYXQgdGhlIHNhbWUga2V5cGF0aC4gU28sIGZvciBlYWNoIGludGVybmFsIGNhY2hlIGxvY2F0aW9uLCB0aGVyZVxuICAvLyBpcyBhIHNwZWNpYWwgXCJyZXZhbGlkYXRpb25cIiBzbG90IHRoYXQgaXMgdXNlZCBzb2xlbHkgZm9yIHRoaXMgcHVycG9zZS5cbiAgLy9cbiAgLy8gWW91IGNhbiB0aGluayBvZiBpdCBhcyBpZiBhbGwgdGhlIHJldmFsaWRhdGlvbiBlbnRyaWVzIHdlcmUgc3RvcmVkIGluIGFcbiAgLy8gc2VwYXJhdGUgY2FjaGUgbWFwIGZyb20gdGhlIGNhbm9uaWNhbCBlbnRyaWVzLCBhbmQgdGhlbiB0cmFuc2ZlcmVkIHRvIHRoZVxuICAvLyBjYW5vbmljYWwgY2FjaGUgbWFwIG9uY2UgdGhlIHJlcXVlc3QgaXMgY29tcGxldGUg4oCUIHRoaXMgaXNuJ3QgaG93IGl0J3NcbiAgLy8gYWN0dWFsbHkgaW1wbGVtZW50ZWQsIHNpbmNlIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8gc3RvcmUgdGhlbSBpbiB0aGUgc2FtZVxuICAvLyBkYXRhIHN0cnVjdHVyZSBhcyB0aGUgbm9ybWFsIGVudHJpZXMsIGJ1dCB0aGF0J3MgaG93IGl0J3MgbW9kZWxlZFxuICAvLyBjb25jZXB0dWFsbHkuXG5cbiAgLy8gVE9ETzogT25jZSB3ZSBpbXBsZW1lbnQgRmFsbGJhY2sgYmVoYXZpb3IgZm9yIHBhcmFtcywgd2hlcmUgYW4gZW50cnkgaXNcbiAgLy8gcmUta2V5ZWQgYmFzZWQgb24gcmVzcG9uc2UgaW5mb3JtYXRpb24sIHdlJ2xsIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlXG4gIC8vIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGtleXBhdGggb2YgdGhlIHByZXZpb3VzIGVudHJ5IGlzIG1vcmUgZ2VuZXJpYyB0aGFuXG4gIC8vIHRoZSBrZXlwYXRoIG9mIHRoZSByZXZhbGlkYXRpbmcgZW50cnkuIEluIG90aGVyIHdvcmRzLCB0aGUgc2VydmVyIGNvdWxkXG4gIC8vIHJldHVybiBhIGxlc3MgZ2VuZXJpYyBlbnRyeSB1cG9uIHJldmFsaWRhdGlvbi4gRm9yIG5vdywgdGhvdWdoLCB0aGlzIGlzbid0XG4gIC8vIGEgY29uY2VybiBiZWNhdXNlIHRoZSBrZXlwYXRoIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgcHJlZmV0Y2ggc3RyYXRlZ3ksXG4gIC8vIG5vdCBvbiBkYXRhIGNvbnRhaW5lZCBpbiB0aGUgcmVzcG9uc2UuXG4gIGNvbnN0IGV4aXN0aW5nRW50cnkgPSByZWFkUmV2YWxpZGF0aW5nU2VnbWVudENhY2hlRW50cnkobm93LCB0cmVlLnZhcnlQYXRoKVxuICBpZiAoZXhpc3RpbmdFbnRyeSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBleGlzdGluZ0VudHJ5XG4gIH1cbiAgLy8gQ3JlYXRlIGEgcGVuZGluZyBlbnRyeSBhbmQgYWRkIGl0IHRvIHRoZSBjYWNoZS5cbiAgY29uc3QgdmFyeVBhdGhGb3JSZXF1ZXN0ID0gZ2V0U2VnbWVudFZhcnlQYXRoRm9yUmVxdWVzdChmZXRjaFN0cmF0ZWd5LCB0cmVlKVxuICBjb25zdCBwZW5kaW5nRW50cnkgPSBjcmVhdGVEZXRhY2hlZFNlZ21lbnRDYWNoZUVudHJ5KHJvdXRlLnN0YWxlQXQpXG4gIGNvbnN0IGlzUmV2YWxpZGF0aW9uID0gdHJ1ZVxuICBzZXRJbkNhY2hlTWFwKFxuICAgIHNlZ21lbnRDYWNoZU1hcCxcbiAgICB2YXJ5UGF0aEZvclJlcXVlc3QsXG4gICAgcGVuZGluZ0VudHJ5LFxuICAgIGlzUmV2YWxpZGF0aW9uXG4gIClcbiAgcmV0dXJuIHBlbmRpbmdFbnRyeVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcndyaXRlUmV2YWxpZGF0aW5nU2VnbWVudENhY2hlRW50cnkoXG4gIGZldGNoU3RyYXRlZ3k6IEZldGNoU3RyYXRlZ3ksXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIHRyZWU6IFJvdXRlVHJlZVxuKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gd2UndmUgYWxyZWFkeSBkZWNpZGVkIHRvIHJlcGxhY2UgYW4gZXhpc3RpbmdcbiAgLy8gcmV2YWxpZGF0aW9uIGVudHJ5LiBDcmVhdGUgYSBuZXcgZW50cnkgYW5kIHdyaXRlIGl0IGludG8gdGhlIGNhY2hlLFxuICAvLyBvdmVyd3JpdGluZyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gIGNvbnN0IHZhcnlQYXRoRm9yUmVxdWVzdCA9IGdldFNlZ21lbnRWYXJ5UGF0aEZvclJlcXVlc3QoZmV0Y2hTdHJhdGVneSwgdHJlZSlcbiAgY29uc3QgcGVuZGluZ0VudHJ5ID0gY3JlYXRlRGV0YWNoZWRTZWdtZW50Q2FjaGVFbnRyeShyb3V0ZS5zdGFsZUF0KVxuICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IHRydWVcbiAgc2V0SW5DYWNoZU1hcChcbiAgICBzZWdtZW50Q2FjaGVNYXAsXG4gICAgdmFyeVBhdGhGb3JSZXF1ZXN0LFxuICAgIHBlbmRpbmdFbnRyeSxcbiAgICBpc1JldmFsaWRhdGlvblxuICApXG4gIHJldHVybiBwZW5kaW5nRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwc2VydFNlZ21lbnRFbnRyeShcbiAgbm93OiBudW1iZXIsXG4gIHZhcnlQYXRoOiBTZWdtZW50VmFyeVBhdGgsXG4gIGNhbmRpZGF0ZUVudHJ5OiBTZWdtZW50Q2FjaGVFbnRyeVxuKTogU2VnbWVudENhY2hlRW50cnkgfCBudWxsIHtcbiAgLy8gV2UgaGF2ZSBhIG5ldyBlbnRyeSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgY2FjaGUuIEJlZm9yZVxuICAvLyB3ZSBkbyBzbywgd2UgbmVlZCB0byBjb25maXJtIHdoZXRoZXIgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBleGlzdGluZ1xuICAvLyBlbnRyeSAoaWYgb25lIGV4aXN0cykuXG4gIC8vIFRPRE86IFdlIHNob3VsZCBub3QgdXBzZXJ0IGFuIGVudHJ5IGlmIGl0cyBrZXkgd2FzIGludmFsaWRhdGVkIGluIHRoZSB0aW1lXG4gIC8vIHNpbmNlIHRoZSByZXF1ZXN0IHdhcyBtYWRlLiBXZSBjYW4gZG8gdGhhdCBieSBwYXNzaW5nIHRoZSBcIm93bmVyXCIgZW50cnkgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiBhbmQgY29uZmlybWluZyBpdCdzIHRoZSBzYW1lIGFzIGBleGlzdGluZ0VudHJ5YC5cblxuICBpZiAoaXNWYWx1ZUV4cGlyZWQobm93LCBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uKCksIGNhbmRpZGF0ZUVudHJ5KSkge1xuICAgIC8vIFRoZSBlbnRyeSBpcyBleHBpcmVkLiBXZSBjYW5ub3QgdXBzZXJ0IGl0LlxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBleGlzdGluZ0VudHJ5ID0gcmVhZFNlZ21lbnRDYWNoZUVudHJ5KG5vdywgdmFyeVBhdGgpXG4gIGlmIChleGlzdGluZ0VudHJ5ICE9PSBudWxsKSB7XG4gICAgLy8gRG9uJ3QgcmVwbGFjZSBhIG1vcmUgc3BlY2lmaWMgc2VnbWVudCB3aXRoIGEgbGVzcy1zcGVjaWZpYyBvbmUuIEEgY2FzZSB3aGVyZSB0aGlzXG4gICAgLy8gbWlnaHQgaGFwcGVuIGlzIGlmIHRoZSBleGlzdGluZyBzZWdtZW50IHdhcyBmZXRjaGVkIHZpYVxuICAgIC8vIGA8TGluayBwcmVmZXRjaD17dHJ1ZX0+YC5cbiAgICBpZiAoXG4gICAgICAvLyBXZSBmZXRjaGVkIHRoZSBuZXcgc2VnbWVudCB1c2luZyBhIGRpZmZlcmVudCwgbGVzcyBzcGVjaWZpYyBmZXRjaCBzdHJhdGVneVxuICAgICAgLy8gdGhhbiB0aGUgc2VnbWVudCB3ZSBhbHJlYWR5IGhhdmUgaW4gdGhlIGNhY2hlLCBzbyBpdCBjYW4ndCBoYXZlIG1vcmUgY29udGVudC5cbiAgICAgIChjYW5kaWRhdGVFbnRyeS5mZXRjaFN0cmF0ZWd5ICE9PSBleGlzdGluZ0VudHJ5LmZldGNoU3RyYXRlZ3kgJiZcbiAgICAgICAgIWNhbk5ld0ZldGNoU3RyYXRlZ3lQcm92aWRlTW9yZUNvbnRlbnQoXG4gICAgICAgICAgZXhpc3RpbmdFbnRyeS5mZXRjaFN0cmF0ZWd5LFxuICAgICAgICAgIGNhbmRpZGF0ZUVudHJ5LmZldGNoU3RyYXRlZ3lcbiAgICAgICAgKSkgfHxcbiAgICAgIC8vIFRoZSBleGlzdGluZyBlbnRyeSBpc24ndCBwYXJ0aWFsLCBidXQgdGhlIG5ldyBvbmUgaXMuXG4gICAgICAvLyAoVE9ETzogY2FuIHRoaXMgYmUgdHJ1ZSBpZiBgY2FuZGlkYXRlRW50cnkuZmV0Y2hTdHJhdGVneSA+PSBleGlzdGluZ0VudHJ5LmZldGNoU3RyYXRlZ3lgPylcbiAgICAgICghZXhpc3RpbmdFbnRyeS5pc1BhcnRpYWwgJiYgY2FuZGlkYXRlRW50cnkuaXNQYXJ0aWFsKVxuICAgICkge1xuICAgICAgLy8gV2UncmUgZ29pbmcgdG8gbGVhdmUgcmV2YWxpZGF0aW5nIGVudHJ5IGluIHRoZSBjYWNoZSBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgIC8vIGdldCByZXZhbGlkYXRlZCBhZ2FpbiB1bm5lY2Vzc2FyaWx5LiBEb3duZ3JhZGUgdGhlIEZ1bGZpbGxlZCBlbnRyeSB0b1xuICAgICAgLy8gUmVqZWN0ZWQgYW5kIG51bGwgb3V0IHRoZSBkYXRhIHNvIGl0IGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC4gV2UgbGVhdmVcbiAgICAgIC8vIGBzdGFsZUF0YCBpbnRhY3QgdG8gcHJldmVudCBzdWJzZXF1ZW50IHJldmFsaWRhdGlvbiBhdHRlbXB0cyBvbmx5IHVudGlsXG4gICAgICAvLyB0aGUgZW50cnkgZXhwaXJlcy5cbiAgICAgIGNvbnN0IHJlamVjdGVkRW50cnk6IFJlamVjdGVkU2VnbWVudENhY2hlRW50cnkgPSBjYW5kaWRhdGVFbnRyeSBhcyBhbnlcbiAgICAgIHJlamVjdGVkRW50cnkuc3RhdHVzID0gRW50cnlTdGF0dXMuUmVqZWN0ZWRcbiAgICAgIHJlamVjdGVkRW50cnkubG9hZGluZyA9IG51bGxcbiAgICAgIHJlamVjdGVkRW50cnkucnNjID0gbnVsbFxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBFdmljdCB0aGUgZXhpc3RpbmcgZW50cnkgZnJvbSB0aGUgY2FjaGUuXG4gICAgZGVsZXRlRnJvbUNhY2hlTWFwKGV4aXN0aW5nRW50cnkpXG4gIH1cblxuICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IGZhbHNlXG4gIHNldEluQ2FjaGVNYXAoc2VnbWVudENhY2hlTWFwLCB2YXJ5UGF0aCwgY2FuZGlkYXRlRW50cnksIGlzUmV2YWxpZGF0aW9uKVxuICByZXR1cm4gY2FuZGlkYXRlRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURldGFjaGVkU2VnbWVudENhY2hlRW50cnkoXG4gIHN0YWxlQXQ6IG51bWJlclxuKTogRW1wdHlTZWdtZW50Q2FjaGVFbnRyeSB7XG4gIGNvbnN0IGVtcHR5RW50cnk6IEVtcHR5U2VnbWVudENhY2hlRW50cnkgPSB7XG4gICAgc3RhdHVzOiBFbnRyeVN0YXR1cy5FbXB0eSxcbiAgICAvLyBEZWZhdWx0IHRvIGFzc3VtaW5nIHRoZSBmZXRjaCBzdHJhdGVneSB3aWxsIGJlIFBQUi4gVGhpcyB3aWxsIGJlIHVwZGF0ZWRcbiAgICAvLyB3aGVuIGEgZmV0Y2ggaXMgYWN0dWFsbHkgaW5pdGlhdGVkLlxuICAgIGZldGNoU3RyYXRlZ3k6IEZldGNoU3RyYXRlZ3kuUFBSLFxuICAgIHJzYzogbnVsbCxcbiAgICBsb2FkaW5nOiBudWxsLFxuICAgIGlzUGFydGlhbDogdHJ1ZSxcbiAgICBwcm9taXNlOiBudWxsLFxuXG4gICAgLy8gTWFwLXJlbGF0ZWQgZmllbGRzXG4gICAgcmVmOiBudWxsLFxuICAgIHNpemU6IDAsXG4gICAgc3RhbGVBdCxcbiAgICB2ZXJzaW9uOiAwLFxuICB9XG4gIHJldHVybiBlbXB0eUVudHJ5XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGdyYWRlVG9QZW5kaW5nU2VnbWVudChcbiAgZW1wdHlFbnRyeTogRW1wdHlTZWdtZW50Q2FjaGVFbnRyeSxcbiAgZmV0Y2hTdHJhdGVneTogRmV0Y2hTdHJhdGVneVxuKTogUGVuZGluZ1NlZ21lbnRDYWNoZUVudHJ5IHtcbiAgY29uc3QgcGVuZGluZ0VudHJ5OiBQZW5kaW5nU2VnbWVudENhY2hlRW50cnkgPSBlbXB0eUVudHJ5IGFzIGFueVxuICBwZW5kaW5nRW50cnkuc3RhdHVzID0gRW50cnlTdGF0dXMuUGVuZGluZ1xuICBwZW5kaW5nRW50cnkuZmV0Y2hTdHJhdGVneSA9IGZldGNoU3RyYXRlZ3lcblxuICBpZiAoZmV0Y2hTdHJhdGVneSA9PT0gRmV0Y2hTdHJhdGVneS5GdWxsKSB7XG4gICAgLy8gV2UgY2FuIGFzc3VtZSB0aGUgcmVzcG9uc2Ugd2lsbCBjb250YWluIHRoZSBmdWxsIHNlZ21lbnQgZGF0YS4gU2V0IHRoaXNcbiAgICAvLyB0byBmYWxzZSBzbyB3ZSBrbm93IGl0J3MgT0sgdG8gb21pdCB0aGlzIHNlZ21lbnQgZnJvbSBhbnkgbmF2aWdhdGlvblxuICAgIC8vIHJlcXVlc3RzIHRoYXQgbWF5IGhhcHBlbiB3aGlsZSB0aGUgZGF0YSBpcyBzdGlsbCBwZW5kaW5nLlxuICAgIHBlbmRpbmdFbnRyeS5pc1BhcnRpYWwgPSBmYWxzZVxuICB9XG5cbiAgLy8gU2V0IHRoZSB2ZXJzaW9uIGhlcmUsIHNpbmNlIHRoaXMgaXMgcmlnaHQgYmVmb3JlIHRoZSByZXF1ZXN0IGlzIGluaXRpYXRlZC5cbiAgLy8gVGhlIG5leHQgdGltZSB0aGUgZ2xvYmFsIGNhY2hlIHZlcnNpb24gaXMgaW5jcmVtZW50ZWQsIHRoZSBlbnRyeSB3aWxsXG4gIC8vIGVmZmVjdGl2ZWx5IGJlIGV2aWN0ZWQuIFRoaXMgaGFwcGVucyBiZWZvcmUgaW5pdGlhdGluZyB0aGUgcmVxdWVzdCwgcmF0aGVyXG4gIC8vIHRoYW4gd2hlbiByZWNlaXZpbmcgdGhlIHJlc3BvbnNlLCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBoYXBwZW5cbiAgLy8gYmVmb3JlIHRoZSBkYXRhIGlzIHJlYWQgb24gdGhlIHNlcnZlci5cbiAgcGVuZGluZ0VudHJ5LnZlcnNpb24gPSBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uKClcbiAgcmV0dXJuIHBlbmRpbmdFbnRyeVxufVxuXG5mdW5jdGlvbiBwaW5nQmxvY2tlZFRhc2tzKGVudHJ5OiB7XG4gIGJsb2NrZWRUYXNrczogU2V0PFByZWZldGNoVGFzaz4gfCBudWxsXG59KTogdm9pZCB7XG4gIGNvbnN0IGJsb2NrZWRUYXNrcyA9IGVudHJ5LmJsb2NrZWRUYXNrc1xuICBpZiAoYmxvY2tlZFRhc2tzICE9PSBudWxsKSB7XG4gICAgZm9yIChjb25zdCB0YXNrIG9mIGJsb2NrZWRUYXNrcykge1xuICAgICAgcGluZ1ByZWZldGNoVGFzayh0YXNrKVxuICAgIH1cbiAgICBlbnRyeS5ibG9ja2VkVGFza3MgPSBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gZnVsZmlsbFJvdXRlQ2FjaGVFbnRyeShcbiAgZW50cnk6IFJvdXRlQ2FjaGVFbnRyeSxcbiAgdHJlZTogUm91dGVUcmVlLFxuICBtZXRhZGF0YVZhcnlQYXRoOiBQYWdlVmFyeVBhdGgsXG4gIHN0YWxlQXQ6IG51bWJlcixcbiAgY291bGRCZUludGVyY2VwdGVkOiBib29sZWFuLFxuICBjYW5vbmljYWxVcmw6IHN0cmluZyxcbiAgcmVuZGVyZWRTZWFyY2g6IE5vcm1hbGl6ZWRTZWFyY2gsXG4gIGlzUFBSRW5hYmxlZDogYm9vbGVhblxuKTogRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5IHtcbiAgLy8gVGhlIEhlYWQgaXMgbm90IGFjdHVhbGx5IHBhcnQgb2YgdGhlIHJvdXRlIHRyZWUsIGJ1dCBvdGhlciB0aGFuIHRoYXQsIGl0J3NcbiAgLy8gZmV0Y2hlZCBhbmQgY2FjaGVkIGxpa2UgYSBzZWdtZW50LiBTb21lIGZ1bmN0aW9ucyBleHBlY3QgYSBSb3V0ZVRyZWVcbiAgLy8gb2JqZWN0LCBzbyByYXRoZXIgdGhhbiBmb3JrIHRoZSBsb2dpYyBpbiBhbGwgdGhvc2UgcGxhY2VzLCB3ZSB1c2UgdGhpc1xuICAvLyBcImZha2VcIiBvbmUuXG4gIGNvbnN0IG1ldGFkYXRhOiBSb3V0ZVRyZWUgPSB7XG4gICAgcmVxdWVzdEtleTogSEVBRF9SRVFVRVNUX0tFWSxcbiAgICBzZWdtZW50OiBIRUFEX1JFUVVFU1RfS0VZLFxuICAgIHZhcnlQYXRoOiBtZXRhZGF0YVZhcnlQYXRoLFxuICAgIC8vIFRoZSBtZXRhZGF0YSBpc24ndCByZWFsbHkgYSBcInBhZ2VcIiAodGhvdWdoIGl0IGlzbid0IHJlYWxseSBhIFwic2VnbWVudFwiXG4gICAgLy8gZWl0aGVyKSBidXQgZm9yIHRoZSBwdXJwb3NlcyBvZiBob3cgdGhpcyBmaWVsZCBpcyB1c2VkLCBpdCBiZWhhdmVzIGxpa2VcbiAgICAvLyBvbmUuIElmIHRoaXMgbG9naWMgZXZlciBnZXRzIG1vcmUgY29tcGxleCB3ZSBjYW4gY2hhbmdlIHRoaXMgdG8gYW4gZW51bS5cbiAgICBpc1BhZ2U6IHRydWUsXG4gICAgc2xvdHM6IG51bGwsXG4gICAgaXNSb290TGF5b3V0OiBmYWxzZSxcbiAgICBoYXNMb2FkaW5nQm91bmRhcnk6IEhhc0xvYWRpbmdCb3VuZGFyeS5TdWJ0cmVlSGFzTm9Mb2FkaW5nQm91bmRhcnksXG4gICAgaGFzUnVudGltZVByZWZldGNoOiBmYWxzZSxcbiAgfVxuICBjb25zdCBmdWxmaWxsZWRFbnRyeTogRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5ID0gZW50cnkgYXMgYW55XG4gIGZ1bGZpbGxlZEVudHJ5LnN0YXR1cyA9IEVudHJ5U3RhdHVzLkZ1bGZpbGxlZFxuICBmdWxmaWxsZWRFbnRyeS50cmVlID0gdHJlZVxuICBmdWxmaWxsZWRFbnRyeS5tZXRhZGF0YSA9IG1ldGFkYXRhXG4gIGZ1bGZpbGxlZEVudHJ5LnN0YWxlQXQgPSBzdGFsZUF0XG4gIGZ1bGZpbGxlZEVudHJ5LmNvdWxkQmVJbnRlcmNlcHRlZCA9IGNvdWxkQmVJbnRlcmNlcHRlZFxuICBmdWxmaWxsZWRFbnRyeS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxcbiAgZnVsZmlsbGVkRW50cnkucmVuZGVyZWRTZWFyY2ggPSByZW5kZXJlZFNlYXJjaFxuICBmdWxmaWxsZWRFbnRyeS5pc1BQUkVuYWJsZWQgPSBpc1BQUkVuYWJsZWRcbiAgcGluZ0Jsb2NrZWRUYXNrcyhlbnRyeSlcbiAgcmV0dXJuIGZ1bGZpbGxlZEVudHJ5XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGxTZWdtZW50Q2FjaGVFbnRyeShcbiAgc2VnbWVudENhY2hlRW50cnk6IFBlbmRpbmdTZWdtZW50Q2FjaGVFbnRyeSxcbiAgcnNjOiBSZWFjdC5SZWFjdE5vZGUsXG4gIGxvYWRpbmc6IExvYWRpbmdNb2R1bGVEYXRhIHwgUHJvbWlzZTxMb2FkaW5nTW9kdWxlRGF0YT4sXG4gIHN0YWxlQXQ6IG51bWJlcixcbiAgaXNQYXJ0aWFsOiBib29sZWFuXG4pOiBGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeSB7XG4gIGNvbnN0IGZ1bGZpbGxlZEVudHJ5OiBGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeSA9IHNlZ21lbnRDYWNoZUVudHJ5IGFzIGFueVxuICBmdWxmaWxsZWRFbnRyeS5zdGF0dXMgPSBFbnRyeVN0YXR1cy5GdWxmaWxsZWRcbiAgZnVsZmlsbGVkRW50cnkucnNjID0gcnNjXG4gIGZ1bGZpbGxlZEVudHJ5LmxvYWRpbmcgPSBsb2FkaW5nXG4gIGZ1bGZpbGxlZEVudHJ5LnN0YWxlQXQgPSBzdGFsZUF0XG4gIGZ1bGZpbGxlZEVudHJ5LmlzUGFydGlhbCA9IGlzUGFydGlhbFxuICAvLyBSZXNvbHZlIGFueSBsaXN0ZW5lcnMgdGhhdCB3ZXJlIHdhaXRpbmcgZm9yIHRoaXMgZGF0YS5cbiAgaWYgKHNlZ21lbnRDYWNoZUVudHJ5LnByb21pc2UgIT09IG51bGwpIHtcbiAgICBzZWdtZW50Q2FjaGVFbnRyeS5wcm9taXNlLnJlc29sdmUoZnVsZmlsbGVkRW50cnkpXG4gICAgLy8gRnJlZSB0aGUgcHJvbWlzZSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgIGZ1bGZpbGxlZEVudHJ5LnByb21pc2UgPSBudWxsXG4gIH1cbiAgcmV0dXJuIGZ1bGZpbGxlZEVudHJ5XG59XG5cbmZ1bmN0aW9uIHJlamVjdFJvdXRlQ2FjaGVFbnRyeShcbiAgZW50cnk6IFBlbmRpbmdSb3V0ZUNhY2hlRW50cnksXG4gIHN0YWxlQXQ6IG51bWJlclxuKTogdm9pZCB7XG4gIGNvbnN0IHJlamVjdGVkRW50cnk6IFJlamVjdGVkUm91dGVDYWNoZUVudHJ5ID0gZW50cnkgYXMgYW55XG4gIHJlamVjdGVkRW50cnkuc3RhdHVzID0gRW50cnlTdGF0dXMuUmVqZWN0ZWRcbiAgcmVqZWN0ZWRFbnRyeS5zdGFsZUF0ID0gc3RhbGVBdFxuICBwaW5nQmxvY2tlZFRhc2tzKGVudHJ5KVxufVxuXG5mdW5jdGlvbiByZWplY3RTZWdtZW50Q2FjaGVFbnRyeShcbiAgZW50cnk6IFBlbmRpbmdTZWdtZW50Q2FjaGVFbnRyeSxcbiAgc3RhbGVBdDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgY29uc3QgcmVqZWN0ZWRFbnRyeTogUmVqZWN0ZWRTZWdtZW50Q2FjaGVFbnRyeSA9IGVudHJ5IGFzIGFueVxuICByZWplY3RlZEVudHJ5LnN0YXR1cyA9IEVudHJ5U3RhdHVzLlJlamVjdGVkXG4gIHJlamVjdGVkRW50cnkuc3RhbGVBdCA9IHN0YWxlQXRcbiAgaWYgKGVudHJ5LnByb21pc2UgIT09IG51bGwpIHtcbiAgICAvLyBOT1RFOiBXZSBkb24ndCBjdXJyZW50bHkgcHJvcGFnYXRlIHRoZSByZWFzb24gdGhlIHByZWZldGNoIHdhcyBjYW5jZWxlZFxuICAgIC8vIGJ1dCB3ZSBjb3VsZCBieSBhY2NlcHRpbmcgYSBgcmVhc29uYCBhcmd1bWVudC5cbiAgICBlbnRyeS5wcm9taXNlLnJlc29sdmUobnVsbClcbiAgICBlbnRyeS5wcm9taXNlID0gbnVsbFxuICB9XG59XG5cbnR5cGUgUm91dGVUcmVlQWNjdW11bGF0b3IgPSB7XG4gIG1ldGFkYXRhVmFyeVBhdGg6IFBhZ2VWYXJ5UGF0aCB8IG51bGxcbn1cblxuZnVuY3Rpb24gY29udmVydFJvb3RUcmVlUHJlZmV0Y2hUb1JvdXRlVHJlZShcbiAgcm9vdFRyZWU6IFJvb3RUcmVlUHJlZmV0Y2gsXG4gIHJlbmRlcmVkUGF0aG5hbWU6IHN0cmluZyxcbiAgcmVuZGVyZWRTZWFyY2g6IE5vcm1hbGl6ZWRTZWFyY2gsXG4gIGFjYzogUm91dGVUcmVlQWNjdW11bGF0b3Jcbikge1xuICAvLyBSZW1vdmUgdHJhaWxpbmcgYW5kIGxlYWRpbmcgc2xhc2hlc1xuICBjb25zdCBwYXRobmFtZVBhcnRzID0gcmVuZGVyZWRQYXRobmFtZS5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gcCAhPT0gJycpXG4gIGNvbnN0IGluZGV4ID0gMFxuICBjb25zdCByb290U2VnbWVudCA9IFJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWVxuICByZXR1cm4gY29udmVydFRyZWVQcmVmZXRjaFRvUm91dGVUcmVlKFxuICAgIHJvb3RUcmVlLnRyZWUsXG4gICAgcm9vdFNlZ21lbnQsXG4gICAgbnVsbCxcbiAgICBST09UX1NFR01FTlRfUkVRVUVTVF9LRVksXG4gICAgcGF0aG5hbWVQYXJ0cyxcbiAgICBpbmRleCxcbiAgICByZW5kZXJlZFNlYXJjaCxcbiAgICBhY2NcbiAgKVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0VHJlZVByZWZldGNoVG9Sb3V0ZVRyZWUoXG4gIHByZWZldGNoOiBUcmVlUHJlZmV0Y2gsXG4gIHNlZ21lbnQ6IEZsaWdodFJvdXRlclN0YXRlU2VnbWVudCxcbiAgcGFydGlhbFZhcnlQYXRoOiBQYXJ0aWFsU2VnbWVudFZhcnlQYXRoIHwgbnVsbCxcbiAgcmVxdWVzdEtleTogU2VnbWVudFJlcXVlc3RLZXksXG4gIHBhdGhuYW1lUGFydHM6IEFycmF5PHN0cmluZz4sXG4gIHBhdGhuYW1lUGFydHNJbmRleDogbnVtYmVyLFxuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaCxcbiAgYWNjOiBSb3V0ZVRyZWVBY2N1bXVsYXRvclxuKTogUm91dGVUcmVlIHtcbiAgLy8gQ29udmVydHMgdGhlIHJvdXRlIHRyZWUgc2VudCBieSB0aGUgc2VydmVyIGludG8gdGhlIGZvcm1hdCB1c2VkIGJ5IHRoZVxuICAvLyBjYWNoZS4gVGhlIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSB0cmVlIGluY2x1ZGVzIGFkZGl0aW9uYWwgZmllbGRzLCBzdWNoIGFzIGFcbiAgLy8gY2FjaGUga2V5IGZvciBlYWNoIHNlZ21lbnQuIFNpbmNlIHRoaXMgaXMgZnJlcXVlbnRseSBhY2Nlc3NlZCwgd2UgY29tcHV0ZVxuICAvLyBpdCBvbmNlIGluc3RlYWQgb2Ygb24gZXZlcnkgYWNjZXNzLiBUaGlzIHNhbWUgY2FjaGUga2V5IGlzIGFsc28gdXNlZCB0b1xuICAvLyByZXF1ZXN0IHRoZSBzZWdtZW50IGZyb20gdGhlIHNlcnZlci5cblxuICBsZXQgc2xvdHM6IHsgW3BhcmFsbGVsUm91dGVLZXk6IHN0cmluZ106IFJvdXRlVHJlZSB9IHwgbnVsbCA9IG51bGxcbiAgbGV0IGlzUGFnZTogYm9vbGVhblxuICBsZXQgdmFyeVBhdGg6IFNlZ21lbnRWYXJ5UGF0aFxuICBjb25zdCBwcmVmZXRjaFNsb3RzID0gcHJlZmV0Y2guc2xvdHNcbiAgaWYgKHByZWZldGNoU2xvdHMgIT09IG51bGwpIHtcbiAgICBpc1BhZ2UgPSBmYWxzZVxuICAgIHZhcnlQYXRoID0gZmluYWxpemVMYXlvdXRWYXJ5UGF0aChyZXF1ZXN0S2V5LCBwYXJ0aWFsVmFyeVBhdGgpXG5cbiAgICBzbG90cyA9IHt9XG4gICAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiBwcmVmZXRjaFNsb3RzKSB7XG4gICAgICBjb25zdCBjaGlsZFByZWZldGNoID0gcHJlZmV0Y2hTbG90c1twYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgY29uc3QgY2hpbGRQYXJhbU5hbWUgPSBjaGlsZFByZWZldGNoLm5hbWVcbiAgICAgIGNvbnN0IGNoaWxkUGFyYW1UeXBlID0gY2hpbGRQcmVmZXRjaC5wYXJhbVR5cGVcbiAgICAgIGNvbnN0IGNoaWxkU2VydmVyU2VudFBhcmFtS2V5ID0gY2hpbGRQcmVmZXRjaC5wYXJhbUtleVxuXG4gICAgICBsZXQgY2hpbGREb2VzQXBwZWFySW5VUkw6IGJvb2xlYW5cbiAgICAgIGxldCBjaGlsZFNlZ21lbnQ6IEZsaWdodFJvdXRlclN0YXRlU2VnbWVudFxuICAgICAgbGV0IGNoaWxkUGFydGlhbFZhcnlQYXRoOiBQYXJ0aWFsU2VnbWVudFZhcnlQYXRoIHwgbnVsbFxuICAgICAgaWYgKGNoaWxkUGFyYW1UeXBlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgc2VnbWVudCBpcyBwYXJhbWV0ZXJpemVkLiBHZXQgdGhlIHBhcmFtIGZyb20gdGhlIHBhdGhuYW1lLlxuICAgICAgICBjb25zdCBjaGlsZFBhcmFtVmFsdWUgPSBwYXJzZUR5bmFtaWNQYXJhbUZyb21VUkxQYXJ0KFxuICAgICAgICAgIGNoaWxkUGFyYW1UeXBlLFxuICAgICAgICAgIHBhdGhuYW1lUGFydHMsXG4gICAgICAgICAgcGF0aG5hbWVQYXJ0c0luZGV4XG4gICAgICAgIClcblxuICAgICAgICAvLyBBc3NpZ24gYSBjYWNoZSBrZXkgdG8gdGhlIHNlZ21lbnQsIGJhc2VkIG9uIHRoZSBwYXJhbSB2YWx1ZS4gSW4gdGhlXG4gICAgICAgIC8vIHByZS1TZWdtZW50IENhY2hlIGltcGxlbWVudGF0aW9uLCB0aGUgc2VydmVyIGNvbXB1dGVzIHRoaXMgYW5kIHNlbmRzXG4gICAgICAgIC8vIGl0IGluIHRoZSBib2R5IG9mIHRoZSByZXNwb25zZS4gSW4gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24sXG4gICAgICAgIC8vIHRoZSBzZXJ2ZXIgc2VuZHMgYW4gZW1wdHkgc3RyaW5nIGFuZCB3ZSBmaWxsIGl0IGluIGhlcmUuXG5cbiAgICAgICAgLy8gVE9ETzogV2UncmUgaW50ZW50aW9uYWxseSBub3QgYWRkaW5nIHRoZSBzZWFyY2ggcGFyYW0gdG8gcGFnZVxuICAgICAgICAvLyBzZWdtZW50cyBoZXJlOyBpdCdzIHRyYWNrZWQgc2VwYXJhdGVseSBhbmQgYWRkZWQgYmFjayBkdXJpbmcgYSByZWFkLlxuICAgICAgICAvLyBUaGlzIHdvdWxkIGNsZWFyZXIgaWYgd2Ugd2FpdGVkIHRvIGNvbnN0cnVjdCB0aGUgc2VnbWVudCB1bnRpbCBpdCdzXG4gICAgICAgIC8vIHJlYWQgZnJvbSB0aGUgY2FjaGUsIHNpbmNlIHRoYXQncyBlZmZlY3RpdmVseSB3aGF0IHdlJ3JlXG4gICAgICAgIC8vIGRvaW5nIGFueXdheS5cbiAgICAgICAgY29uc3QgY2hpbGRQYXJhbUtleSA9XG4gICAgICAgICAgLy8gVGhlIHNlcnZlciBvbWl0cyB0aGlzIGZpZWxkIGZyb20gdGhlIHByZWZldGNoIHJlc3BvbnNlIHdoZW5cbiAgICAgICAgICAvLyBjYWNoZUNvbXBvbmVudHMgaXMgZW5hYmxlZC5cbiAgICAgICAgICBjaGlsZFNlcnZlclNlbnRQYXJhbUtleSAhPT0gbnVsbFxuICAgICAgICAgICAgPyBjaGlsZFNlcnZlclNlbnRQYXJhbUtleVxuICAgICAgICAgICAgOiAvLyBJZiBubyBwYXJhbSBrZXkgd2FzIHNlbnQsIHVzZSB0aGUgdmFsdWUgcGFyc2VkIG9uIHRoZSBjbGllbnQuXG4gICAgICAgICAgICAgIGdldENhY2hlS2V5Rm9yRHluYW1pY1BhcmFtKFxuICAgICAgICAgICAgICAgIGNoaWxkUGFyYW1WYWx1ZSxcbiAgICAgICAgICAgICAgICAnJyBhcyBOb3JtYWxpemVkU2VhcmNoXG4gICAgICAgICAgICAgIClcblxuICAgICAgICBjaGlsZFBhcnRpYWxWYXJ5UGF0aCA9IGFwcGVuZExheW91dFZhcnlQYXRoKFxuICAgICAgICAgIHBhcnRpYWxWYXJ5UGF0aCxcbiAgICAgICAgICBjaGlsZFBhcmFtS2V5XG4gICAgICAgIClcbiAgICAgICAgY2hpbGRTZWdtZW50ID0gW2NoaWxkUGFyYW1OYW1lLCBjaGlsZFBhcmFtS2V5LCBjaGlsZFBhcmFtVHlwZV1cbiAgICAgICAgY2hpbGREb2VzQXBwZWFySW5VUkwgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHNlZ21lbnQgZG9lcyBub3QgaGF2ZSBhIHBhcmFtLiBJbmhlcml0IHRoZSBwYXJ0aWFsIHZhcnkgcGF0aCBvZlxuICAgICAgICAvLyB0aGUgcGFyZW50LlxuICAgICAgICBjaGlsZFBhcnRpYWxWYXJ5UGF0aCA9IHBhcnRpYWxWYXJ5UGF0aFxuICAgICAgICBjaGlsZFNlZ21lbnQgPSBjaGlsZFBhcmFtTmFtZVxuICAgICAgICBjaGlsZERvZXNBcHBlYXJJblVSTCA9IGRvZXNTdGF0aWNTZWdtZW50QXBwZWFySW5VUkwoY2hpbGRQYXJhbU5hbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgaW5jcmVtZW50IHRoZSBpbmRleCBpZiB0aGUgc2VnbWVudCBhcHBlYXJzIGluIHRoZSBVUkwuIElmIGl0J3MgYVxuICAgICAgLy8gXCJ2aXJ0dWFsXCIgc2VnbWVudCwgbGlrZSBhIHJvdXRlIGdyb3VwLCBpdCByZW1haW5zIHRoZSBzYW1lLlxuICAgICAgY29uc3QgY2hpbGRQYXRobmFtZVBhcnRzSW5kZXggPSBjaGlsZERvZXNBcHBlYXJJblVSTFxuICAgICAgICA/IHBhdGhuYW1lUGFydHNJbmRleCArIDFcbiAgICAgICAgOiBwYXRobmFtZVBhcnRzSW5kZXhcblxuICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0S2V5UGFydCA9IGNyZWF0ZVNlZ21lbnRSZXF1ZXN0S2V5UGFydChjaGlsZFNlZ21lbnQpXG4gICAgICBjb25zdCBjaGlsZFJlcXVlc3RLZXkgPSBhcHBlbmRTZWdtZW50UmVxdWVzdEtleVBhcnQoXG4gICAgICAgIHJlcXVlc3RLZXksXG4gICAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICAgIGNoaWxkUmVxdWVzdEtleVBhcnRcbiAgICAgIClcbiAgICAgIHNsb3RzW3BhcmFsbGVsUm91dGVLZXldID0gY29udmVydFRyZWVQcmVmZXRjaFRvUm91dGVUcmVlKFxuICAgICAgICBjaGlsZFByZWZldGNoLFxuICAgICAgICBjaGlsZFNlZ21lbnQsXG4gICAgICAgIGNoaWxkUGFydGlhbFZhcnlQYXRoLFxuICAgICAgICBjaGlsZFJlcXVlc3RLZXksXG4gICAgICAgIHBhdGhuYW1lUGFydHMsXG4gICAgICAgIGNoaWxkUGF0aG5hbWVQYXJ0c0luZGV4LFxuICAgICAgICByZW5kZXJlZFNlYXJjaCxcbiAgICAgICAgYWNjXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXF1ZXN0S2V5LmVuZHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgcGFnZSBzZWdtZW50LlxuICAgICAgaXNQYWdlID0gdHJ1ZVxuICAgICAgdmFyeVBhdGggPSBmaW5hbGl6ZVBhZ2VWYXJ5UGF0aChcbiAgICAgICAgcmVxdWVzdEtleSxcbiAgICAgICAgcmVuZGVyZWRTZWFyY2gsXG4gICAgICAgIHBhcnRpYWxWYXJ5UGF0aFxuICAgICAgKVxuICAgICAgLy8gVGhlIG1ldGFkYXRhIFwic2VnbWVudFwiIGlzIG5vdCBwYXJ0IHRoZSByb3V0ZSB0cmVlLCBidXQgaXQgaGFzIHRoZSBzYW1lXG4gICAgICAvLyBjb25jZXB0dWFsIHBhcmFtcyBhcyBhIHBhZ2Ugc2VnbWVudC4gV3JpdGUgdGhlIHZhcnkgcGF0aCBpbnRvIHRoZVxuICAgICAgLy8gYWNjdW11bGF0b3Igb2JqZWN0LiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGFyYWxsZWwgcGFnZXMsIHdlIHVzZSB0aGVcbiAgICAgIC8vIGZpcnN0IG9uZS4gV2hpY2ggcGFnZSB3ZSBjaG9vc2UgaXMgYXJiaXRyYXJ5IGFzIGxvbmcgYXMgaXQnc1xuICAgICAgLy8gY29uc2lzdGVudGx5IHRoZSBzYW1lIG9uZSBldmVyeSB0aW1lIGV2ZXJ5IHRpbWUuIFNlZVxuICAgICAgLy8gZmluYWxpemVNZXRhZGF0YVZhcnlQYXRoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAoYWNjLm1ldGFkYXRhVmFyeVBhdGggPT09IG51bGwpIHtcbiAgICAgICAgYWNjLm1ldGFkYXRhVmFyeVBhdGggPSBmaW5hbGl6ZU1ldGFkYXRhVmFyeVBhdGgoXG4gICAgICAgICAgcmVxdWVzdEtleSxcbiAgICAgICAgICByZW5kZXJlZFNlYXJjaCxcbiAgICAgICAgICBwYXJ0aWFsVmFyeVBhdGhcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGEgbGF5b3V0IHNlZ21lbnQuXG4gICAgICBpc1BhZ2UgPSBmYWxzZVxuICAgICAgdmFyeVBhdGggPSBmaW5hbGl6ZUxheW91dFZhcnlQYXRoKHJlcXVlc3RLZXksIHBhcnRpYWxWYXJ5UGF0aClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlcXVlc3RLZXksXG4gICAgc2VnbWVudCxcbiAgICB2YXJ5UGF0aCxcbiAgICAvLyBUT0RPOiBDaGVhdGluZyB0aGUgdHlwZSBzeXN0ZW0gaGVyZSBhIGJpdCBiZWNhdXNlIFR5cGVTY3JpcHQgY2FuJ3QgdGVsbFxuICAgIC8vIHRoYXQgdGhlIHR5cGUgb2YgaXNQYWdlIGFuZCB2YXJ5UGF0aCBhcmUgY29uc2lzdGVudC4gVGhlIGZpeCB3b3VsZCBiZSB0b1xuICAgIC8vIGNyZWF0ZSBzZXBhcmF0ZSBjb25zdHJ1Y3RvcnMgYW5kIGNhbGwgdGhlIGFwcHJvcHJpYXRlIG9uZSBmcm9tIGVhY2ggb2ZcbiAgICAvLyB0aGUgYnJhbmNoZXMgYWJvdmUuIEp1c3Qgc2VlbXMgYSBiaXQgb3ZlcmtpbGwgb25seSBmb3Igb25lIGZpZWxkIHNvIEknbGxcbiAgICAvLyBsZWF2ZSBpdCBhcy1pcyBmb3Igbm93LiBJZiBpc1BhZ2Ugd2VyZSB3cm9uZyBpdCB3b3VsZCBicmVhayB0aGUgYmVoYXZpb3JcbiAgICAvLyBhbmQgd2UnZCBjYXRjaCBpdCBxdWlja2x5LCBhbnl3YXkuXG4gICAgaXNQYWdlOiBpc1BhZ2UgYXMgYm9vbGVhbiBhcyBhbnksXG4gICAgc2xvdHMsXG4gICAgaXNSb290TGF5b3V0OiBwcmVmZXRjaC5pc1Jvb3RMYXlvdXQsXG4gICAgLy8gVGhpcyBmaWVsZCBpcyBvbmx5IHJlbGV2YW50IHRvIGR5bmFtaWMgcm91dGVzLiBGb3IgYSBQUFIvc3RhdGljIHJvdXRlLFxuICAgIC8vIHRoZXJlJ3MgYWx3YXlzIHNvbWUgcGFydGlhbCBsb2FkaW5nIHN0YXRlIHdlIGNhbiBmZXRjaC5cbiAgICBoYXNMb2FkaW5nQm91bmRhcnk6IEhhc0xvYWRpbmdCb3VuZGFyeS5TZWdtZW50SGFzTG9hZGluZ0JvdW5kYXJ5LFxuICAgIGhhc1J1bnRpbWVQcmVmZXRjaDogcHJlZmV0Y2guaGFzUnVudGltZVByZWZldGNoLFxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRSb290RmxpZ2h0Um91dGVyU3RhdGVUb1JvdXRlVHJlZShcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaCxcbiAgYWNjOiBSb3V0ZVRyZWVBY2N1bXVsYXRvclxuKTogUm91dGVUcmVlIHtcbiAgcmV0dXJuIGNvbnZlcnRGbGlnaHRSb3V0ZXJTdGF0ZVRvUm91dGVUcmVlKFxuICAgIGZsaWdodFJvdXRlclN0YXRlLFxuICAgIFJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSxcbiAgICBudWxsLFxuICAgIHJlbmRlcmVkU2VhcmNoLFxuICAgIGFjY1xuICApXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGbGlnaHRSb3V0ZXJTdGF0ZVRvUm91dGVUcmVlKFxuICBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHJlcXVlc3RLZXk6IFNlZ21lbnRSZXF1ZXN0S2V5LFxuICBwYXJlbnRQYXJ0aWFsVmFyeVBhdGg6IFBhcnRpYWxTZWdtZW50VmFyeVBhdGggfCBudWxsLFxuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaCxcbiAgYWNjOiBSb3V0ZVRyZWVBY2N1bXVsYXRvclxuKTogUm91dGVUcmVlIHtcbiAgY29uc3Qgb3JpZ2luYWxTZWdtZW50ID0gZmxpZ2h0Um91dGVyU3RhdGVbMF1cblxuICBsZXQgc2VnbWVudDogRmxpZ2h0Um91dGVyU3RhdGVTZWdtZW50XG4gIGxldCBwYXJ0aWFsVmFyeVBhdGg6IFBhcnRpYWxTZWdtZW50VmFyeVBhdGggfCBudWxsXG4gIGxldCBpc1BhZ2U6IGJvb2xlYW5cbiAgbGV0IHZhcnlQYXRoOiBTZWdtZW50VmFyeVBhdGhcbiAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luYWxTZWdtZW50KSkge1xuICAgIGlzUGFnZSA9IGZhbHNlXG4gICAgY29uc3QgcGFyYW1DYWNoZUtleSA9IG9yaWdpbmFsU2VnbWVudFsxXVxuICAgIHBhcnRpYWxWYXJ5UGF0aCA9IGFwcGVuZExheW91dFZhcnlQYXRoKHBhcmVudFBhcnRpYWxWYXJ5UGF0aCwgcGFyYW1DYWNoZUtleSlcbiAgICB2YXJ5UGF0aCA9IGZpbmFsaXplTGF5b3V0VmFyeVBhdGgocmVxdWVzdEtleSwgcGFydGlhbFZhcnlQYXRoKVxuICAgIHNlZ21lbnQgPSBvcmlnaW5hbFNlZ21lbnRcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIHNlZ21lbnQgZG9lcyBub3QgaGF2ZSBhIHBhcmFtLiBJbmhlcml0IHRoZSBwYXJ0aWFsIHZhcnkgcGF0aCBvZlxuICAgIC8vIHRoZSBwYXJlbnQuXG4gICAgcGFydGlhbFZhcnlQYXRoID0gcGFyZW50UGFydGlhbFZhcnlQYXRoXG4gICAgaWYgKHJlcXVlc3RLZXkuZW5kc1dpdGgoUEFHRV9TRUdNRU5UX0tFWSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBwYWdlIHNlZ21lbnQuXG4gICAgICBpc1BhZ2UgPSB0cnVlXG5cbiAgICAgIC8vIFRoZSBuYXZpZ2F0aW9uIGltcGxlbWVudGF0aW9uIGV4cGVjdHMgdGhlIHNlYXJjaCBwYXJhbXMgdG8gYmUgaW5jbHVkZWRcbiAgICAgIC8vIGluIHRoZSBzZWdtZW50LiBIb3dldmVyLCBpbiB0aGUgY2FzZSBvZiBhIHN0YXRpYyByZXNwb25zZSwgdGhlIHNlYXJjaFxuICAgICAgLy8gcGFyYW1zIGFyZSBvbWl0dGVkLiBTbyB0aGUgY2xpZW50IG5lZWRzIHRvIGFkZCB0aGVtIGJhY2sgaW4gd2hlbiByZWFkaW5nXG4gICAgICAvLyBmcm9tIHRoZSBTZWdtZW50IENhY2hlLlxuICAgICAgLy9cbiAgICAgIC8vIEZvciBjb25zaXN0ZW5jeSwgd2UnbGwgZG8gdGhpcyBmb3IgZHluYW1pYyByZXNwb25zZXMsIHRvby5cbiAgICAgIC8vXG4gICAgICAvLyBUT0RPOiBXZSBzaG91bGQgbW92ZSBzZWFyY2ggcGFyYW1zIG91dCBvZiBGbGlnaHRSb3V0ZXJTdGF0ZSBhbmQgaGFuZGxlXG4gICAgICAvLyB0aGVtIGVudGlyZWx5IG9uIHRoZSBjbGllbnQsIHNpbWlsYXIgdG8gb3VyIHBsYW4gZm9yIGR5bmFtaWMgcGFyYW1zLlxuICAgICAgc2VnbWVudCA9IFBBR0VfU0VHTUVOVF9LRVlcbiAgICAgIHZhcnlQYXRoID0gZmluYWxpemVQYWdlVmFyeVBhdGgoXG4gICAgICAgIHJlcXVlc3RLZXksXG4gICAgICAgIHJlbmRlcmVkU2VhcmNoLFxuICAgICAgICBwYXJ0aWFsVmFyeVBhdGhcbiAgICAgIClcbiAgICAgIC8vIFRoZSBtZXRhZGF0YSBcInNlZ21lbnRcIiBpcyBub3QgcGFydCB0aGUgcm91dGUgdHJlZSwgYnV0IGl0IGhhcyB0aGUgc2FtZVxuICAgICAgLy8gY29uY2VwdHVhbCBwYXJhbXMgYXMgYSBwYWdlIHNlZ21lbnQuIFdyaXRlIHRoZSB2YXJ5IHBhdGggaW50byB0aGVcbiAgICAgIC8vIGFjY3VtdWxhdG9yIG9iamVjdC4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHBhcmFsbGVsIHBhZ2VzLCB3ZSB1c2UgdGhlXG4gICAgICAvLyBmaXJzdCBvbmUuIFdoaWNoIHBhZ2Ugd2UgY2hvb3NlIGlzIGFyYml0cmFyeSBhcyBsb25nIGFzIGl0J3NcbiAgICAgIC8vIGNvbnNpc3RlbnRseSB0aGUgc2FtZSBvbmUgZXZlcnkgdGltZSBldmVyeSB0aW1lLiBTZWVcbiAgICAgIC8vIGZpbmFsaXplTWV0YWRhdGFWYXJ5UGF0aCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKGFjYy5tZXRhZGF0YVZhcnlQYXRoID09PSBudWxsKSB7XG4gICAgICAgIGFjYy5tZXRhZGF0YVZhcnlQYXRoID0gZmluYWxpemVNZXRhZGF0YVZhcnlQYXRoKFxuICAgICAgICAgIHJlcXVlc3RLZXksXG4gICAgICAgICAgcmVuZGVyZWRTZWFyY2gsXG4gICAgICAgICAgcGFydGlhbFZhcnlQYXRoXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIGxheW91dCBzZWdtZW50LlxuICAgICAgaXNQYWdlID0gZmFsc2VcbiAgICAgIHNlZ21lbnQgPSBvcmlnaW5hbFNlZ21lbnRcbiAgICAgIHZhcnlQYXRoID0gZmluYWxpemVMYXlvdXRWYXJ5UGF0aChyZXF1ZXN0S2V5LCBwYXJ0aWFsVmFyeVBhdGgpXG4gICAgfVxuICB9XG5cbiAgbGV0IHNsb3RzOiB7IFtwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmddOiBSb3V0ZVRyZWUgfSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBmbGlnaHRSb3V0ZXJTdGF0ZVsxXVxuICBmb3IgKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgY29uc3QgY2hpbGRSb3V0ZXJTdGF0ZSA9IHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3QgY2hpbGRTZWdtZW50ID0gY2hpbGRSb3V0ZXJTdGF0ZVswXVxuICAgIC8vIFRPRE86IEV2ZW50dWFsbHksIHRoZSBwYXJhbSB2YWx1ZXMgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlXG4gICAgLy8gZnJvbSB0aGUgc2VydmVyLiBXZSdsbCBpbnN0ZWFkIGZpbGwgdGhlbSBpbiBvbiB0aGUgY2xpZW50IGJ5IHBhcnNpbmdcbiAgICAvLyB0aGUgVVJMLiBUaGlzIGlzIHdoZXJlIHdlJ2xsIGRvIHRoYXQuXG4gICAgY29uc3QgY2hpbGRSZXF1ZXN0S2V5UGFydCA9IGNyZWF0ZVNlZ21lbnRSZXF1ZXN0S2V5UGFydChjaGlsZFNlZ21lbnQpXG4gICAgY29uc3QgY2hpbGRSZXF1ZXN0S2V5ID0gYXBwZW5kU2VnbWVudFJlcXVlc3RLZXlQYXJ0KFxuICAgICAgcmVxdWVzdEtleSxcbiAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICBjaGlsZFJlcXVlc3RLZXlQYXJ0XG4gICAgKVxuICAgIGNvbnN0IGNoaWxkVHJlZSA9IGNvbnZlcnRGbGlnaHRSb3V0ZXJTdGF0ZVRvUm91dGVUcmVlKFxuICAgICAgY2hpbGRSb3V0ZXJTdGF0ZSxcbiAgICAgIGNoaWxkUmVxdWVzdEtleSxcbiAgICAgIHBhcnRpYWxWYXJ5UGF0aCxcbiAgICAgIHJlbmRlcmVkU2VhcmNoLFxuICAgICAgYWNjXG4gICAgKVxuICAgIGlmIChzbG90cyA9PT0gbnVsbCkge1xuICAgICAgc2xvdHMgPSB7XG4gICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogY2hpbGRUcmVlLFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbG90c1twYXJhbGxlbFJvdXRlS2V5XSA9IGNoaWxkVHJlZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVxdWVzdEtleSxcbiAgICBzZWdtZW50LFxuICAgIHZhcnlQYXRoLFxuICAgIC8vIFRPRE86IENoZWF0aW5nIHRoZSB0eXBlIHN5c3RlbSBoZXJlIGEgYml0IGJlY2F1c2UgVHlwZVNjcmlwdCBjYW4ndCB0ZWxsXG4gICAgLy8gdGhhdCB0aGUgdHlwZSBvZiBpc1BhZ2UgYW5kIHZhcnlQYXRoIGFyZSBjb25zaXN0ZW50LiBUaGUgZml4IHdvdWxkIGJlIHRvXG4gICAgLy8gY3JlYXRlIHNlcGFyYXRlIGNvbnN0cnVjdG9ycyBhbmQgY2FsbCB0aGUgYXBwcm9wcmlhdGUgb25lIGZyb20gZWFjaCBvZlxuICAgIC8vIHRoZSBicmFuY2hlcyBhYm92ZS4gSnVzdCBzZWVtcyBhIGJpdCBvdmVya2lsbCBvbmx5IGZvciBvbmUgZmllbGQgc28gSSdsbFxuICAgIC8vIGxlYXZlIGl0IGFzLWlzIGZvciBub3cuIElmIGlzUGFnZSB3ZXJlIHdyb25nIGl0IHdvdWxkIGJyZWFrIHRoZSBiZWhhdmlvclxuICAgIC8vIGFuZCB3ZSdkIGNhdGNoIGl0IHF1aWNrbHksIGFueXdheS5cbiAgICBpc1BhZ2U6IGlzUGFnZSBhcyBib29sZWFuIGFzIGFueSxcbiAgICBzbG90cyxcbiAgICBpc1Jvb3RMYXlvdXQ6IGZsaWdodFJvdXRlclN0YXRlWzRdID09PSB0cnVlLFxuICAgIGhhc0xvYWRpbmdCb3VuZGFyeTpcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlWzVdICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbGlnaHRSb3V0ZXJTdGF0ZVs1XVxuICAgICAgICA6IEhhc0xvYWRpbmdCb3VuZGFyeS5TdWJ0cmVlSGFzTm9Mb2FkaW5nQm91bmRhcnksXG5cbiAgICAvLyBOb24tc3RhdGljIHRyZWUgcmVzcG9uc2VzIGFyZSBvbmx5IHVzZWQgYnkgYXBwcyB0aGF0IGhhdmVuJ3QgYWRvcHRlZFxuICAgIC8vIENhY2hlIENvbXBvbmVudHMuIFNvIHRoaXMgaXMgYWx3YXlzIGZhbHNlLlxuICAgIGhhc1J1bnRpbWVQcmVmZXRjaDogZmFsc2UsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSb3V0ZVRyZWVUb0ZsaWdodFJvdXRlclN0YXRlKFxuICByb3V0ZVRyZWU6IFJvdXRlVHJlZVxuKTogRmxpZ2h0Um91dGVyU3RhdGUge1xuICBjb25zdCBwYXJhbGxlbFJvdXRlczogUmVjb3JkPHN0cmluZywgRmxpZ2h0Um91dGVyU3RhdGU+ID0ge31cbiAgaWYgKHJvdXRlVHJlZS5zbG90cyAhPT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZVRyZWUuc2xvdHMpIHtcbiAgICAgIHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldID0gY29udmVydFJvdXRlVHJlZVRvRmxpZ2h0Um91dGVyU3RhdGUoXG4gICAgICAgIHJvdXRlVHJlZS5zbG90c1twYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgKVxuICAgIH1cbiAgfVxuICBjb25zdCBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUgPSBbXG4gICAgcm91dGVUcmVlLnNlZ21lbnQsXG4gICAgcGFyYWxsZWxSb3V0ZXMsXG4gICAgbnVsbCxcbiAgICBudWxsLFxuICAgIHJvdXRlVHJlZS5pc1Jvb3RMYXlvdXQsXG4gIF1cbiAgcmV0dXJuIGZsaWdodFJvdXRlclN0YXRlXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFJvdXRlT25DYWNoZU1pc3MoXG4gIGVudHJ5OiBQZW5kaW5nUm91dGVDYWNoZUVudHJ5LFxuICB0YXNrOiBQcmVmZXRjaFRhc2ssXG4gIGtleTogUm91dGVDYWNoZUtleVxuKTogUHJvbWlzZTxQcmVmZXRjaFN1YnRhc2tSZXN1bHQ8bnVsbD4gfCBudWxsPiB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgYWxsb3dlZCB0byB1c2UgYXN5bmMvYXdhaXQgYmVjYXVzZSBpdCBjb250YWlucyB0aGUgYWN0dWFsXG4gIC8vIGZldGNoIHRoYXQgZ2V0cyBpc3N1ZWQgb24gYSBjYWNoZSBtaXNzLiBOb3RpY2UgaXQgd3JpdGVzIHRoZSByZXN1bHQgdG8gdGhlXG4gIC8vIGNhY2hlIGVudHJ5IGRpcmVjdGx5LCByYXRoZXIgdGhhbiByZXR1cm4gZGF0YSB0aGF0IGlzIHRoZW4gd3JpdHRlbiBieVxuICAvLyB0aGUgY2FsbGVyLlxuICBjb25zdCBwYXRobmFtZSA9IGtleS5wYXRobmFtZVxuICBjb25zdCBzZWFyY2ggPSBrZXkuc2VhcmNoXG4gIGNvbnN0IG5leHRVcmwgPSBrZXkubmV4dFVybFxuICBjb25zdCBzZWdtZW50UGF0aCA9ICcvX3RyZWUnIGFzIFNlZ21lbnRSZXF1ZXN0S2V5XG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgW1JTQ19IRUFERVJdOiAnMScsXG4gICAgW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl06ICcxJyxcbiAgICBbTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVJdOiBzZWdtZW50UGF0aCxcbiAgfVxuICBpZiAobmV4dFVybCAhPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGhuYW1lICsgc2VhcmNoLCBsb2NhdGlvbi5vcmlnaW4pXG4gICAgbGV0IHJlc3BvbnNlXG4gICAgbGV0IHVybEFmdGVyUmVkaXJlY3RzXG4gICAgaWYgKGlzT3V0cHV0RXhwb3J0TW9kZSkge1xuICAgICAgLy8gSW4gb3V0cHV0OiBcImV4cG9ydFwiIG1vZGUsIHdlIGNhbid0IHVzZSBoZWFkZXJzIHRvIHJlcXVlc3QgYSBwYXJ0aWN1bGFyXG4gICAgICAvLyBzZWdtZW50LiBJbnN0ZWFkLCB3ZSBlbmNvZGUgdGhlIGV4dHJhIHJlcXVlc3QgaW5mb3JtYXRpb24gaW50byB0aGUgVVJMLlxuICAgICAgLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgXCJwdWJsaWNcIiBpbnRlcmZhY2Ugb2YgdGhlIGFwcDsgaXQncyBhbiBpbnRlcm5hbFxuICAgICAgLy8gTmV4dC5qcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgdGhhdCB0aGUgYXBwIGRldmVsb3BlciBzaG91bGQgbm90IG5lZWQgdG9cbiAgICAgIC8vIGNvbmNlcm4gdGhlbXNlbHZlcyB3aXRoLlxuICAgICAgLy9cbiAgICAgIC8vIEZvciBleGFtcGxlLCB0byByZXF1ZXN0IGEgc2VnbWVudDpcbiAgICAgIC8vXG4gICAgICAvLyAgIFBhdGggcGFzc2VkIHRvIDxMaW5rPjogICAvcGF0aC90by9wYWdlXG4gICAgICAvLyAgIFBhdGggcGFzc2VkIHRvIGZldGNoOiAgICAvcGF0aC90by9wYWdlL19fbmV4dC1zZWdtZW50cy9fdHJlZVxuICAgICAgLy9cbiAgICAgIC8vICAgKFRoaXMgaXMgbm90IHRoZSBleGFjdCBwcm90b2NvbCwganVzdCBhbiBpbGx1c3RyYXRpb24uKVxuICAgICAgLy9cbiAgICAgIC8vIEJlZm9yZSB3ZSBkbyB0aGF0LCB0aG91Z2gsIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgcmVkaXJlY3RzLiBFdmVuIGluXG4gICAgICAvLyBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgYSBwcm94eSBtaWdodCByZWRpcmVjdCB0aGUgcGFnZSB0byBhIGRpZmZlcmVudFxuICAgICAgLy8gbG9jYXRpb24sIGJ1dCB3ZSBzaG91bGRuJ3QgYXNzdW1lIG9yIGV4cGVjdCB0aGF0IHRoZXkgYWxzbyByZWRpcmVjdCBhbGxcbiAgICAgIC8vIHRoZSBzZWdtZW50IGZpbGVzLCB0b28uXG4gICAgICAvL1xuICAgICAgLy8gVG8gY2hlY2sgd2hldGhlciB0aGUgcGFnZSBpcyByZWRpcmVjdGVkLCBwcmV2aW91c2x5IHdlIHBlcmZvcm0gYSByYW5nZVxuICAgICAgLy8gcmVxdWVzdCBvZiA2NCBieXRlcyBvZiB0aGUgSFRNTCBkb2N1bWVudCB0byBjaGVjayBpZiB0aGUgdGFyZ2V0IHBhZ2VcbiAgICAgIC8vIGlzIHBhcnQgb2YgdGhpcyBhcHAgKGJ5IGNoZWNraW5nIGlmIGJ1aWxkIGlkIG1hdGNoZXMpLiBPbmx5IGlmIHRoZSB0YXJnZXRcbiAgICAgIC8vIHBhZ2UgaXMgcGFydCBvZiB0aGlzIGFwcCBkbyB3ZSBkZXRlcm1pbmUgdGhlIGZpbmFsIGNhbm9uaWNhbCBVUkwuXG4gICAgICAvL1xuICAgICAgLy8gSG93ZXZlciwgYXMgbWVudGlvbmVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzg1OTAzLFxuICAgICAgLy8gc29tZSBwb3B1bGFyIHN0YXRpYyBob3N0aW5nIHByb3ZpZGVycyAobGlrZSBDbG91ZGZsYXJlIFBhZ2VzIG9yIFJlbmRlci5jb20pXG4gICAgICAvLyBkbyBub3Qgc3VwcG9ydCByYW5nZSByZXF1ZXN0cywgaW4gdGhlIHdvcnN0IGNhc2UsIHRoZSBlbnRpcmUgSFRNTCBpbnN0ZWFkXG4gICAgICAvLyBvZiA2NCBieXRlcyBjb3VsZCBiZSByZXR1cm5lZCwgd2hpY2ggaXMgd2FzdGVmdWwuXG4gICAgICAvL1xuICAgICAgLy8gU28gaW5zdGVhZCwgd2UgZHJvcHMgdGhlIGNoZWNrIGZvciBidWlsZCBpZCBoZXJlLCBhbmQgc2ltcGx5IHBlcmZvcm1cbiAgICAgIC8vIGEgSEVBRCByZXF1ZXN0IHRvIHJlamVjdHMgMXh4LzR4eC81eHggcmVzcG9uc2VzLCBhbmQgdGhlbiBkZXRlcm1pbmUgdGhlXG4gICAgICAvLyBmaW5hbCBVUkwgYWZ0ZXIgcmVkaXJlY3RzLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFdlIGNvdWxkIGVtYmVkIHRoZSByb3V0ZSB0cmVlIGludG8gdGhlIEhUTUwgZG9jdW1lbnQsIHRvIGF2b2lkXG4gICAgICAvLyBhIHNlY29uZCByZXF1ZXN0LiBXZSdyZSBub3QgZG9pbmcgdGhhdCBjdXJyZW50bHkgYmVjYXVzZSBpdCB3b3VsZCBtYWtlXG4gICAgICAvLyB0aGUgSFRNTCBkb2N1bWVudCBsYXJnZXIgYW5kIGFmZmVjdCBub3JtYWwgcGFnZSBsb2Fkcy5cbiAgICAgIGNvbnN0IGhlYWRSZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgIH0pXG4gICAgICBpZiAoaGVhZFJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCBoZWFkUmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAvLyBUaGUgdGFyZ2V0IHBhZ2UgcmVzcG9uZGVkIHcvbyBhIHN1Y2Nlc3NmdWwgc3RhdHVzIGNvZGVcbiAgICAgICAgLy8gQ291bGQgYmUgYSBXQUYgc2VydmluZyBhIDQwMywgb3IgYSA1eHggZnJvbSBhIGJhY2tlbmRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbid0IHVzZSBoZWFkUmVzcG9uc2Uub2sgaGVyZSwgYmVjYXVzZVxuICAgICAgICAvLyBSZXNwb25zZSNvayByZXR1cm5zIGBmYWxzZWAgd2l0aCAzeHggcmVzcG9uc2VzLlxuICAgICAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHVybEFmdGVyUmVkaXJlY3RzID0gaGVhZFJlc3BvbnNlLnJlZGlyZWN0ZWRcbiAgICAgICAgPyBuZXcgVVJMKGhlYWRSZXNwb25zZS51cmwpXG4gICAgICAgIDogdXJsXG5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hQcmVmZXRjaFJlc3BvbnNlKFxuICAgICAgICBhZGRTZWdtZW50UGF0aFRvVXJsSW5PdXRwdXRFeHBvcnRNb2RlKHVybEFmdGVyUmVkaXJlY3RzLCBzZWdtZW50UGF0aCksXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCJTZXJ2ZXJcIiBtb2RlLiBXZSBjYW4gdXNlIHJlcXVlc3QgaGVhZGVycyBpbnN0ZWFkIG9mIHRoZSBwYXRobmFtZS5cbiAgICAgIC8vIFRPRE86IFRoZSBldmVudHVhbCBwbGFuIGlzIHRvIGdldCByaWQgb2Ygb3VyIGN1c3RvbSByZXF1ZXN0IGhlYWRlcnMgYW5kXG4gICAgICAvLyBlbmNvZGUgZXZlcnl0aGluZyBpbnRvIHRoZSBVUkwsIHVzaW5nIGEgc2ltaWxhciBzdHJhdGVneSB0byB0aGVcbiAgICAgIC8vIFwib3V0cHV0OiBleHBvcnRcIiBibG9jayBhYm92ZS5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hQcmVmZXRjaFJlc3BvbnNlKHVybCwgaGVhZGVycylcbiAgICAgIHVybEFmdGVyUmVkaXJlY3RzID1cbiAgICAgICAgcmVzcG9uc2UgIT09IG51bGwgJiYgcmVzcG9uc2UucmVkaXJlY3RlZCA/IG5ldyBVUkwocmVzcG9uc2UudXJsKSA6IHVybFxuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFyZXNwb25zZSB8fFxuICAgICAgIXJlc3BvbnNlLm9rIHx8XG4gICAgICAvLyAyMDQgaXMgYSBDYWNoZSBtaXNzLiBUaG91Z2ggdGhlb3JldGljYWxseSB0aGlzIHNob3VsZG4ndCBoYXBwZW4gd2hlblxuICAgICAgLy8gUFBSIGlzIGVuYWJsZWQsIGJlY2F1c2Ugd2UgYWx3YXlzIHJlc3BvbmQgdG8gcm91dGUgdHJlZSByZXF1ZXN0cywgZXZlblxuICAgICAgLy8gaWYgaXQgbmVlZHMgdG8gYmUgYmxvY2tpbmdseSBnZW5lcmF0ZWQgb24gZGVtYW5kLlxuICAgICAgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHxcbiAgICAgICFyZXNwb25zZS5ib2R5XG4gICAgKSB7XG4gICAgICAvLyBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IsIG9yIHdpdGggYSBtaXNzLiBXZSBzaG91bGQgc3RpbGwgY2FjaGVcbiAgICAgIC8vIHRoZSByZXNwb25zZSwgYnV0IHdlIGNhbiB0cnkgYWdhaW4gYWZ0ZXIgMTAgc2Vjb25kcy5cbiAgICAgIHJlamVjdFJvdXRlQ2FjaGVFbnRyeShlbnRyeSwgRGF0ZS5ub3coKSArIDEwICogMTAwMClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gVE9ETzogVGhlIGNhbm9uaWNhbCBVUkwgaXMgdGhlIGhyZWYgd2l0aG91dCB0aGUgb3JpZ2luLiBJIHRoaW5rXG4gICAgLy8gaGlzdG9yaWNhbGx5IHRoZSByZWFzb24gZm9yIHRoaXMgaXMgYmVjYXVzZSB0aGUgaW5pdGlhbCBjYW5vbmljYWwgVVJMXG4gICAgLy8gZ2V0cyBwYXNzZWQgYXMgYSBwcm9wIHRvIHRoZSB0b3AtbGV2ZWwgUmVhY3QgY29tcG9uZW50LCB3aGljaCBtZWFucyBpdFxuICAgIC8vIG5lZWRzIHRvIGJlIGNvbXB1dGVkIGR1cmluZyBTU1IuIElmIGl0IHdlcmUgdG8gaW5jbHVkZSB0aGUgb3JpZ2luLCBpdFxuICAgIC8vIHdvdWxkIG5lZWQgdG8gYWx3YXlzIGJlIHNhbWUgYXMgbG9jYXRpb24ub3JpZ2luIG9uIHRoZSBjbGllbnQsIHRvIHByZXZlbnRcbiAgICAvLyBhIGh5ZHJhdGlvbiBtaXNtYXRjaC4gVG8gc2lkZXN0ZXAgdGhpcyBjb21wbGV4aXR5LCB3ZSBvbWl0IHRoZSBvcmlnaW4uXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGlzIGlzIG5laXRoZXIgYSBuYXRpdmUgVVJMIG9iamVjdCBub3IgYSBmdWxseSBxdWFsaWZpZWRcbiAgICAvLyBVUkwgc3RyaW5nLCB3ZSBuZWVkIHRvIGJlIGNhcmVmdWwgYWJvdXQgaG93IHdlIHVzZSBpdC4gVG8gcHJldmVudCBzdWJ0bGVcbiAgICAvLyBtaXN0YWtlcywgd2Ugc2hvdWxkIGNyZWF0ZSBhIHNwZWNpYWwgdHlwZSBmb3IgaXQsIGluc3RlYWQgb2YganVzdCBzdHJpbmcuXG4gICAgLy8gT3IsIHdlIHNob3VsZCBqdXN0IHVzZSBhIChyZWFkb25seSkgVVJMIG9iamVjdCBpbnN0ZWFkLiBUaGUgdHlwZSBvZiB0aGVcbiAgICAvLyBwcm9wIHRoYXQgd2UgcGFzcyB0byBzZWVkIHRoZSBpbml0aWFsIHN0YXRlIGRvZXMgbm90IG5lZWQgdG8gYmUgdGhlIHNhbWVcbiAgICAvLyB0eXBlIGFzIHRoZSBzdGF0ZSBpdHNlbGYuXG4gICAgY29uc3QgY2Fub25pY2FsVXJsID0gY3JlYXRlSHJlZkZyb21VcmwodXJsQWZ0ZXJSZWRpcmVjdHMpXG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByZXNwb25zZSB2YXJpZXMgYmFzZWQgb24gdGhlIE5leHQtVXJsIGhlYWRlci5cbiAgICBjb25zdCB2YXJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3ZhcnknKVxuICAgIGNvbnN0IGNvdWxkQmVJbnRlcmNlcHRlZCA9XG4gICAgICB2YXJ5SGVhZGVyICE9PSBudWxsICYmIHZhcnlIZWFkZXIuaW5jbHVkZXMoTkVYVF9VUkwpXG5cbiAgICAvLyBUcmFjayB3aGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgIGNvbnN0IGNsb3NlZCA9IGNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzPHZvaWQ+KClcblxuICAgIC8vIFRoaXMgY2hlY2tzIHdoZXRoZXIgdGhlIHJlc3BvbnNlIHdhcyBzZXJ2ZWQgZnJvbSB0aGUgcGVyLXNlZ21lbnQgY2FjaGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gdGhlIG9sZCBwcmVmZXRjaGluZyBmbG93LiBJZiBpdCBmYWlscywgaXQgaW1wbGllcyB0aGF0IFBQUlxuICAgIC8vIGlzIGRpc2FibGVkIG9uIHRoaXMgcm91dGUuXG4gICAgY29uc3Qgcm91dGVJc1BQUkVuYWJsZWQgPVxuICAgICAgcmVzcG9uc2UuaGVhZGVycy5nZXQoTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSKSA9PT0gJzInIHx8XG4gICAgICAvLyBJbiBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgd2UgY2FuJ3QgcmVseSBvbiByZXNwb25zZSBoZWFkZXJzLiBCdXQgaWYgd2VcbiAgICAgIC8vIHJlY2VpdmUgYSB3ZWxsLWZvcm1lZCByZXNwb25zZSwgd2UgY2FuIGFzc3VtZSBpdCdzIGEgc3RhdGljIHJlc3BvbnNlLFxuICAgICAgLy8gYmVjYXVzZSBhbGwgZGF0YSBpcyBzdGF0aWMgaW4gdGhpcyBtb2RlLlxuICAgICAgaXNPdXRwdXRFeHBvcnRNb2RlXG5cbiAgICBpZiAocm91dGVJc1BQUkVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHByZWZldGNoU3RyZWFtID0gY3JlYXRlUHJlZmV0Y2hSZXNwb25zZVN0cmVhbShcbiAgICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgICAgY2xvc2VkLnJlc29sdmUsXG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2VTaXplVXBkYXRlKHNpemUpIHtcbiAgICAgICAgICBzZXRTaXplSW5DYWNoZU1hcChlbnRyeSwgc2l6ZSlcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgY29uc3Qgc2VydmVyRGF0YSA9IGF3YWl0IGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW08Um9vdFRyZWVQcmVmZXRjaD4oXG4gICAgICAgIHByZWZldGNoU3RyZWFtLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApXG4gICAgICBpZiAoc2VydmVyRGF0YS5idWlsZElkICE9PSBnZXRBcHBCdWlsZElkKCkpIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciBidWlsZCBkb2VzIG5vdCBtYXRjaCB0aGUgY2xpZW50LiBUcmVhdCBhcyBhIDQwNC4gRHVyaW5nXG4gICAgICAgIC8vIGFuIGFjdHVhbCBuYXZpZ2F0aW9uLCB0aGUgcm91dGVyIHdpbGwgdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbW92aW5nIHRoZSBidWlsZCBJRCB0byBhIHJlc3BvbnNlIGhlYWRlciBzbyB3ZSBjYW4gY2hlY2tcbiAgICAgICAgLy8gaXQgYmVmb3JlIGRlY29kaW5nIHRoZSByZXNwb25zZSwgYW5kIHNvIHRoZXJlJ3Mgb25lIHdheSBvZiBjaGVja2luZ1xuICAgICAgICAvLyBhY3Jvc3MgYWxsIHJlc3BvbnNlIHR5cGVzLlxuICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgY2FjaGUgdGhlIGZhY3QgdGhhdCB0aGlzIGlzIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICAgICAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgcGFyYW1zIHRoYXQgd2VyZSB1c2VkIHRvIHJlbmRlciB0aGUgdGFyZ2V0IHBhZ2UuIFRoZXNlIG1heVxuICAgICAgLy8gYmUgZGlmZmVyZW50IGZyb20gdGhlIHBhcmFtcyBpbiB0aGUgcmVxdWVzdCBVUkwsIGlmIHRoZSBwYWdlXG4gICAgICAvLyB3YXMgcmV3cml0dGVuLlxuICAgICAgY29uc3QgcmVuZGVyZWRQYXRobmFtZSA9IGdldFJlbmRlcmVkUGF0aG5hbWUocmVzcG9uc2UpXG4gICAgICBjb25zdCByZW5kZXJlZFNlYXJjaCA9IGdldFJlbmRlcmVkU2VhcmNoKHJlc3BvbnNlKVxuXG4gICAgICAvLyBDb252ZXJ0IHRoZSBzZXJ2ZXItc2VudCBkYXRhIGludG8gdGhlIFJvdXRlVHJlZSBmb3JtYXQgdXNlZCBieSB0aGVcbiAgICAgIC8vIGNsaWVudCBjYWNoZS5cbiAgICAgIC8vXG4gICAgICAvLyBEdXJpbmcgdGhpcyB0cmF2ZXJzYWwsIHdlIGFjY3VtdWxhdGUgYWRkaXRpb25hbCBkYXRhIGludG8gdGhpc1xuICAgICAgLy8gXCJhY2N1bXVsYXRvclwiIG9iamVjdC5cbiAgICAgIGNvbnN0IGFjYzogUm91dGVUcmVlQWNjdW11bGF0b3IgPSB7IG1ldGFkYXRhVmFyeVBhdGg6IG51bGwgfVxuICAgICAgY29uc3Qgcm91dGVUcmVlID0gY29udmVydFJvb3RUcmVlUHJlZmV0Y2hUb1JvdXRlVHJlZShcbiAgICAgICAgc2VydmVyRGF0YSxcbiAgICAgICAgcmVuZGVyZWRQYXRobmFtZSxcbiAgICAgICAgcmVuZGVyZWRTZWFyY2gsXG4gICAgICAgIGFjY1xuICAgICAgKVxuICAgICAgY29uc3QgbWV0YWRhdGFWYXJ5UGF0aCA9IGFjYy5tZXRhZGF0YVZhcnlQYXRoXG4gICAgICBpZiAobWV0YWRhdGFWYXJ5UGF0aCA9PT0gbnVsbCkge1xuICAgICAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YWxlVGltZU1zID0gZ2V0U3RhbGVUaW1lTXMoc2VydmVyRGF0YS5zdGFsZVRpbWUpXG4gICAgICBmdWxmaWxsUm91dGVDYWNoZUVudHJ5KFxuICAgICAgICBlbnRyeSxcbiAgICAgICAgcm91dGVUcmVlLFxuICAgICAgICBtZXRhZGF0YVZhcnlQYXRoLFxuICAgICAgICBEYXRlLm5vdygpICsgc3RhbGVUaW1lTXMsXG4gICAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZCxcbiAgICAgICAgY2Fub25pY2FsVXJsLFxuICAgICAgICByZW5kZXJlZFNlYXJjaCxcbiAgICAgICAgcm91dGVJc1BQUkVuYWJsZWRcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUFBSIGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHJvdXRlLiBUaGUgc2VydmVyIHJlc3BvbmRzIHdpdGggYVxuICAgICAgLy8gZGlmZmVyZW50IGZvcm1hdCAoRmxpZ2h0Um91dGVyU3RhdGUpIHRoYXQgd2UgbmVlZCB0byBjb252ZXJ0LlxuICAgICAgLy8gVE9ETzogV2Ugd2lsbCB1bmlmeSB0aGUgcmVzcG9uc2VzIGV2ZW50dWFsbHkuIEknbSBrZWVwaW5nIHRoZSB0eXBlc1xuICAgICAgLy8gc2VwYXJhdGUgZm9yIG5vdyBiZWNhdXNlIEZsaWdodFJvdXRlclN0YXRlIGhhcyBzbyBtYW55XG4gICAgICAvLyBvdmVybG9hZGVkIGNvbmNlcm5zLlxuICAgICAgY29uc3QgcHJlZmV0Y2hTdHJlYW0gPSBjcmVhdGVQcmVmZXRjaFJlc3BvbnNlU3RyZWFtKFxuICAgICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgICBjbG9zZWQucmVzb2x2ZSxcbiAgICAgICAgZnVuY3Rpb24gb25SZXNwb25zZVNpemVVcGRhdGUoc2l6ZSkge1xuICAgICAgICAgIHNldFNpemVJbkNhY2hlTWFwKGVudHJ5LCBzaXplKVxuICAgICAgICB9XG4gICAgICApXG4gICAgICBjb25zdCBzZXJ2ZXJEYXRhID1cbiAgICAgICAgYXdhaXQgY3JlYXRlRnJvbU5leHRSZWFkYWJsZVN0cmVhbTxOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2U+KFxuICAgICAgICAgIHByZWZldGNoU3RyZWFtLFxuICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgKVxuICAgICAgaWYgKHNlcnZlckRhdGEuYiAhPT0gZ2V0QXBwQnVpbGRJZCgpKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgYnVpbGQgZG9lcyBub3QgbWF0Y2ggdGhlIGNsaWVudC4gVHJlYXQgYXMgYSA0MDQuIER1cmluZ1xuICAgICAgICAvLyBhbiBhY3R1YWwgbmF2aWdhdGlvbiwgdGhlIHJvdXRlciB3aWxsIHRyaWdnZXIgYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1vdmluZyB0aGUgYnVpbGQgSUQgdG8gYSByZXNwb25zZSBoZWFkZXIgc28gd2UgY2FuIGNoZWNrXG4gICAgICAgIC8vIGl0IGJlZm9yZSBkZWNvZGluZyB0aGUgcmVzcG9uc2UsIGFuZCBzbyB0aGVyZSdzIG9uZSB3YXkgb2YgY2hlY2tpbmdcbiAgICAgICAgLy8gYWNyb3NzIGFsbCByZXNwb25zZSB0eXBlcy5cbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGNhY2hlIHRoZSBmYWN0IHRoYXQgdGhpcyBpcyBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAgICAgcmVqZWN0Um91dGVDYWNoZUVudHJ5KGVudHJ5LCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICB3cml0ZUR5bmFtaWNUcmVlUmVzcG9uc2VJbnRvQ2FjaGUoXG4gICAgICAgIERhdGUubm93KCksXG4gICAgICAgIHRhc2ssXG4gICAgICAgIC8vIFRoZSBub24tUFBSIHJlc3BvbnNlIGZvcm1hdCBpcyB3aGF0IHdlJ2QgZ2V0IGlmIHdlIHByZWZldGNoZWQgdGhlc2Ugc2VnbWVudHNcbiAgICAgICAgLy8gdXNpbmcgdGhlIExvYWRpbmdCb3VuZGFyeSBmZXRjaCBzdHJhdGVneSwgc28gbWFyayB0aGVpciBjYWNoZSBlbnRyaWVzIGFjY29yZGluZ2x5LlxuICAgICAgICBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeSxcbiAgICAgICAgcmVzcG9uc2UgYXMgUlNDUmVzcG9uc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPixcbiAgICAgICAgc2VydmVyRGF0YSxcbiAgICAgICAgZW50cnksXG4gICAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZCxcbiAgICAgICAgY2Fub25pY2FsVXJsLFxuICAgICAgICByb3V0ZUlzUFBSRW5hYmxlZFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICghY291bGRCZUludGVyY2VwdGVkKSB7XG4gICAgICAvLyBUaGlzIHJvdXRlIHdpbGwgbmV2ZXIgYmUgaW50ZXJjZXB0ZWQuIFNvIHdlIGNhbiB1c2UgdGhpcyBlbnRyeSBmb3IgYWxsXG4gICAgICAvLyByZXF1ZXN0cyB0byB0aGlzIHJvdXRlLCByZWdhcmRsZXNzIG9mIHRoZSBOZXh0LVVybCBoZWFkZXIuIFRoaXMgd29ya3NcbiAgICAgIC8vIGJlY2F1c2Ugd2hlbiByZWFkaW5nIHRoZSBjYWNoZSB3ZSBhbHdheXMgY2hlY2sgZm9yIGEgdmFsaWRcbiAgICAgIC8vIG5vbi1pbnRlcmNlcHRlZCBlbnRyeSBmaXJzdC5cblxuICAgICAgLy8gUmUta2V5IHRoZSBlbnRyeS4gVGhlIGBzZXRgIGltcGxlbWVudGF0aW9uIGhhbmRsZXMgcmVtb3ZpbmcgaXQgZnJvbVxuICAgICAgLy8gaXRzIHByZXZpb3VzIHBvc2l0aW9uIGluIHRoZSBjYWNoZS4gV2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyB0b1xuICAgICAgLy8gdXBkYXRlIHRoZSBMUlUsIGJlY2F1c2UgdGhlIGVudHJ5IGlzIGFscmVhZHkgaW4gaXQuXG4gICAgICAvLyBUT0RPOiBUcmVhdCB0aGlzIGFzIGFuIHVwc2VydCDigJQgc2hvdWxkIGNoZWNrIGlmIGFuIGVudHJ5IGFscmVhZHlcbiAgICAgIC8vIGV4aXN0cyBhdCB0aGUgbmV3IGtleXBhdGgsIGFuZCBpZiBzbywgd2hldGhlciB3ZSBzaG91bGQga2VlcCB0aGF0XG4gICAgICAvLyBvbmUgaW5zdGVhZC5cbiAgICAgIGNvbnN0IGZ1bGZpbGxlZFZhcnlQYXRoOiBSb3V0ZVZhcnlQYXRoID0gZ2V0RnVsZmlsbGVkUm91dGVWYXJ5UGF0aChcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgbmV4dFVybCxcbiAgICAgICAgY291bGRCZUludGVyY2VwdGVkXG4gICAgICApXG4gICAgICBjb25zdCBpc1JldmFsaWRhdGlvbiA9IGZhbHNlXG4gICAgICBzZXRJbkNhY2hlTWFwKHJvdXRlQ2FjaGVNYXAsIGZ1bGZpbGxlZFZhcnlQYXRoLCBlbnRyeSwgaXNSZXZhbGlkYXRpb24pXG4gICAgfVxuICAgIC8vIFJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gY2xvc2VzLCBzb1xuICAgIC8vIHRoZSBzY2hlZHVsZXIgY2FuIHRyYWNrIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBuZXR3b3JrIGNvbm5lY3Rpb25zLlxuICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBjbG9zZWQ6IGNsb3NlZC5wcm9taXNlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBFaXRoZXIgdGhlIGNvbm5lY3Rpb24gaXRzZWxmIGZhaWxlZCwgb3Igc29tZXRoaW5nIGJhZCBoYXBwZW5lZCB3aGlsZVxuICAgIC8vIGRlY29kaW5nIHRoZSByZXNwb25zZS5cbiAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTZWdtZW50T25DYWNoZU1pc3MoXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIHNlZ21lbnRDYWNoZUVudHJ5OiBQZW5kaW5nU2VnbWVudENhY2hlRW50cnksXG4gIHJvdXRlS2V5OiBSb3V0ZUNhY2hlS2V5LFxuICB0cmVlOiBSb3V0ZVRyZWVcbik6IFByb21pc2U8UHJlZmV0Y2hTdWJ0YXNrUmVzdWx0PEZ1bGZpbGxlZFNlZ21lbnRDYWNoZUVudHJ5PiB8IG51bGw+IHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBhbGxvd2VkIHRvIHVzZSBhc3luYy9hd2FpdCBiZWNhdXNlIGl0IGNvbnRhaW5zIHRoZSBhY3R1YWxcbiAgLy8gZmV0Y2ggdGhhdCBnZXRzIGlzc3VlZCBvbiBhIGNhY2hlIG1pc3MuIE5vdGljZSBpdCB3cml0ZXMgdGhlIHJlc3VsdCB0byB0aGVcbiAgLy8gY2FjaGUgZW50cnkgZGlyZWN0bHksIHJhdGhlciB0aGFuIHJldHVybiBkYXRhIHRoYXQgaXMgdGhlbiB3cml0dGVuIGJ5XG4gIC8vIHRoZSBjYWxsZXIuXG4gIC8vXG4gIC8vIFNlZ21lbnQgZmV0Y2hlcyBhcmUgbm9uLWJsb2NraW5nIHNvIHdlIGRvbid0IG5lZWQgdG8gcGluZyB0aGUgc2NoZWR1bGVyXG4gIC8vIG9uIGNvbXBsZXRpb24uXG5cbiAgLy8gVXNlIHRoZSBjYW5vbmljYWwgVVJMIHRvIHJlcXVlc3QgdGhlIHNlZ21lbnQsIG5vdCB0aGUgb3JpZ2luYWwgVVJMLiBUaGVzZVxuICAvLyBhcmUgdXN1YWxseSB0aGUgc2FtZSwgYnV0IHRoZSBjYW5vbmljYWwgVVJMIHdpbGwgYmUgZGlmZmVyZW50IGlmIHRoZSByb3V0ZVxuICAvLyB0cmVlIHJlc3BvbnNlIHdhcyByZWRpcmVjdGVkLiBUbyBhdm9pZCBhbiBleHRyYSB3YXRlcmZhbGwgb24gZXZlcnkgc2VnbWVudFxuICAvLyByZXF1ZXN0LCB3ZSBwYXNzIHRoZSByZWRpcmVjdGVkIFVSTCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBvbmUuXG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocm91dGUuY2Fub25pY2FsVXJsLCBsb2NhdGlvbi5vcmlnaW4pXG4gIGNvbnN0IG5leHRVcmwgPSByb3V0ZUtleS5uZXh0VXJsXG5cbiAgY29uc3QgcmVxdWVzdEtleSA9IHRyZWUucmVxdWVzdEtleVxuICBjb25zdCBub3JtYWxpemVkUmVxdWVzdEtleSA9XG4gICAgcmVxdWVzdEtleSA9PT0gUk9PVF9TRUdNRU5UX1JFUVVFU1RfS0VZXG4gICAgICA/IC8vIFRoZSByb290IHNlZ21lbnQgaXMgYSBzcGVjaWFsIGNhc2UuIFRvIHNpbXBsaWZ5IHRoZSBzZXJ2ZXItc2lkZVxuICAgICAgICAvLyBoYW5kbGluZyBvZiB0aGVzZSByZXF1ZXN0cywgd2UgZW5jb2RlIHRoZSByb290IHNlZ21lbnQgcGF0aCBhc1xuICAgICAgICAvLyBgX2luZGV4YCBpbnN0ZWFkIG9mIGFzIGFuIGVtcHR5IHN0cmluZy4gVGhpcyBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICAgICAgICAvLyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgYW5kIG5vdCBhcyBhIHN0YWJsZSBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAgICAgICAgLy8gSXQganVzdCBuZWVkcyB0byBtYXRjaCB0aGUgZXF1aXZhbGVudCBsb2dpYyB0aGF0IGhhcHBlbnMgd2hlblxuICAgICAgICAvLyBwcmVyZW5kZXJpbmcgdGhlIHJlc3BvbnNlcy4gSXQgc2hvdWxkIG5vdCBsZWFrIG91dHNpZGUgb2YgTmV4dC5qcy5cbiAgICAgICAgKCcvX2luZGV4JyBhcyBTZWdtZW50UmVxdWVzdEtleSlcbiAgICAgIDogcmVxdWVzdEtleVxuXG4gIGNvbnN0IGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzID0ge1xuICAgIFtSU0NfSEVBREVSXTogJzEnLFxuICAgIFtORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdOiAnMScsXG4gICAgW05FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSXTogbm9ybWFsaXplZFJlcXVlc3RLZXksXG4gIH1cbiAgaWYgKG5leHRVcmwgIT09IG51bGwpIHtcbiAgICBoZWFkZXJzW05FWFRfVVJMXSA9IG5leHRVcmxcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3RVcmwgPSBpc091dHB1dEV4cG9ydE1vZGVcbiAgICA/IC8vIEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB3ZSBuZWVkIHRvIGFkZCB0aGUgc2VnbWVudCBwYXRoIHRvIHRoZSBVUkwuXG4gICAgICBhZGRTZWdtZW50UGF0aFRvVXJsSW5PdXRwdXRFeHBvcnRNb2RlKHVybCwgbm9ybWFsaXplZFJlcXVlc3RLZXkpXG4gICAgOiB1cmxcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoUHJlZmV0Y2hSZXNwb25zZShyZXF1ZXN0VXJsLCBoZWFkZXJzKVxuICAgIGlmIChcbiAgICAgICFyZXNwb25zZSB8fFxuICAgICAgIXJlc3BvbnNlLm9rIHx8XG4gICAgICByZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCAvLyBDYWNoZSBtaXNzXG4gICAgICAvLyBUaGlzIGNoZWNrcyB3aGV0aGVyIHRoZSByZXNwb25zZSB3YXMgc2VydmVkIGZyb20gdGhlIHBlci1zZWdtZW50IGNhY2hlLFxuICAgICAgLy8gcmF0aGVyIHRoYW4gdGhlIG9sZCBwcmVmZXRjaGluZyBmbG93LiBJZiBpdCBmYWlscywgaXQgaW1wbGllcyB0aGF0IFBQUlxuICAgICAgLy8gaXMgZGlzYWJsZWQgb24gdGhpcyByb3V0ZS4gVGhlb3JldGljYWxseSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgIC8vIGJlY2F1c2Ugd2Ugb25seSBpc3N1ZSByZXF1ZXN0cyBmb3Igc2VnbWVudHMgb25jZSB3ZSd2ZSB2ZXJpZmllZCB0aGF0XG4gICAgICAvLyB0aGUgcm91dGUgc3VwcG9ydHMgUFBSLlxuICAgICAgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfRElEX1BPU1RQT05FX0hFQURFUikgIT09ICcyJyAmJlxuICAgICAgICAvLyBJbiBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgd2UgY2FuJ3QgcmVseSBvbiByZXNwb25zZSBoZWFkZXJzLiBCdXQgaWZcbiAgICAgICAgLy8gd2UgcmVjZWl2ZSBhIHdlbGwtZm9ybWVkIHJlc3BvbnNlLCB3ZSBjYW4gYXNzdW1lIGl0J3MgYSBzdGF0aWNcbiAgICAgICAgLy8gcmVzcG9uc2UsIGJlY2F1c2UgYWxsIGRhdGEgaXMgc3RhdGljIGluIHRoaXMgbW9kZS5cbiAgICAgICAgIWlzT3V0cHV0RXhwb3J0TW9kZSkgfHxcbiAgICAgICFyZXNwb25zZS5ib2R5XG4gICAgKSB7XG4gICAgICAvLyBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IsIG9yIHdpdGggYSBtaXNzLiBXZSBzaG91bGQgc3RpbGwgY2FjaGVcbiAgICAgIC8vIHRoZSByZXNwb25zZSwgYnV0IHdlIGNhbiB0cnkgYWdhaW4gYWZ0ZXIgMTAgc2Vjb25kcy5cbiAgICAgIHJlamVjdFNlZ21lbnRDYWNoZUVudHJ5KHNlZ21lbnRDYWNoZUVudHJ5LCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBUcmFjayB3aGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgIGNvbnN0IGNsb3NlZCA9IGNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzPHZvaWQ+KClcblxuICAgIC8vIFdyYXAgdGhlIG9yaWdpbmFsIHN0cmVhbSBpbiBhIG5ldyBzdHJlYW0gdGhhdCBuZXZlciBjbG9zZXMuIFRoYXQgd2F5IHRoZVxuICAgIC8vIEZsaWdodCBjbGllbnQgZG9lc24ndCBlcnJvciBpZiB0aGVyZSdzIGEgaGFuZ2luZyBwcm9taXNlLlxuICAgIGNvbnN0IHByZWZldGNoU3RyZWFtID0gY3JlYXRlUHJlZmV0Y2hSZXNwb25zZVN0cmVhbShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbG9zZWQucmVzb2x2ZSxcbiAgICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2VTaXplVXBkYXRlKHNpemUpIHtcbiAgICAgICAgc2V0U2l6ZUluQ2FjaGVNYXAoc2VnbWVudENhY2hlRW50cnksIHNpemUpXG4gICAgICB9XG4gICAgKVxuICAgIGNvbnN0IHNlcnZlckRhdGEgPSBhd2FpdCAoY3JlYXRlRnJvbU5leHRSZWFkYWJsZVN0cmVhbShcbiAgICAgIHByZWZldGNoU3RyZWFtLFxuICAgICAgaGVhZGVyc1xuICAgICkgYXMgUHJvbWlzZTxTZWdtZW50UHJlZmV0Y2g+KVxuICAgIGlmIChzZXJ2ZXJEYXRhLmJ1aWxkSWQgIT09IGdldEFwcEJ1aWxkSWQoKSkge1xuICAgICAgLy8gVGhlIHNlcnZlciBidWlsZCBkb2VzIG5vdCBtYXRjaCB0aGUgY2xpZW50LiBUcmVhdCBhcyBhIDQwNC4gRHVyaW5nXG4gICAgICAvLyBhbiBhY3R1YWwgbmF2aWdhdGlvbiwgdGhlIHJvdXRlciB3aWxsIHRyaWdnZXIgYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBtb3ZpbmcgdGhlIGJ1aWxkIElEIHRvIGEgcmVzcG9uc2UgaGVhZGVyIHNvIHdlIGNhbiBjaGVja1xuICAgICAgLy8gaXQgYmVmb3JlIGRlY29kaW5nIHRoZSByZXNwb25zZSwgYW5kIHNvIHRoZXJlJ3Mgb25lIHdheSBvZiBjaGVja2luZ1xuICAgICAgLy8gYWNyb3NzIGFsbCByZXNwb25zZSB0eXBlcy5cbiAgICAgIHJlamVjdFNlZ21lbnRDYWNoZUVudHJ5KHNlZ21lbnRDYWNoZUVudHJ5LCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBmdWxmaWxsU2VnbWVudENhY2hlRW50cnkoXG4gICAgICAgIHNlZ21lbnRDYWNoZUVudHJ5LFxuICAgICAgICBzZXJ2ZXJEYXRhLnJzYyxcbiAgICAgICAgc2VydmVyRGF0YS5sb2FkaW5nLFxuICAgICAgICAvLyBUT0RPOiBUaGUgc2VydmVyIGRvZXMgbm90IGN1cnJlbnRseSBwcm92aWRlIHBlci1zZWdtZW50IHN0YWxlIHRpbWUuXG4gICAgICAgIC8vIFNvIHdlIHVzZSB0aGUgc3RhbGUgdGltZSBvZiB0aGUgcm91dGUuXG4gICAgICAgIHJvdXRlLnN0YWxlQXQsXG4gICAgICAgIHNlcnZlckRhdGEuaXNQYXJ0aWFsXG4gICAgICApLFxuICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG5ldHdvcmsgY29ubmVjdGlvbiBjbG9zZXMsIHNvXG4gICAgICAvLyB0aGUgc2NoZWR1bGVyIGNhbiB0cmFjayB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgbmV0d29yayBjb25uZWN0aW9ucy5cbiAgICAgIGNsb3NlZDogY2xvc2VkLnByb21pc2UsXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIEVpdGhlciB0aGUgY29ubmVjdGlvbiBpdHNlbGYgZmFpbGVkLCBvciBzb21ldGhpbmcgYmFkIGhhcHBlbmVkIHdoaWxlXG4gICAgLy8gZGVjb2RpbmcgdGhlIHJlc3BvbnNlLlxuICAgIHJlamVjdFNlZ21lbnRDYWNoZUVudHJ5KHNlZ21lbnRDYWNoZUVudHJ5LCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoU2VnbWVudFByZWZldGNoZXNVc2luZ0R5bmFtaWNSZXF1ZXN0KFxuICB0YXNrOiBQcmVmZXRjaFRhc2ssXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIGZldGNoU3RyYXRlZ3k6XG4gICAgfCBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeVxuICAgIHwgRmV0Y2hTdHJhdGVneS5QUFJSdW50aW1lXG4gICAgfCBGZXRjaFN0cmF0ZWd5LkZ1bGwsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHNwYXduZWRFbnRyaWVzOiBNYXA8U2VnbWVudFJlcXVlc3RLZXksIFBlbmRpbmdTZWdtZW50Q2FjaGVFbnRyeT5cbik6IFByb21pc2U8UHJlZmV0Y2hTdWJ0YXNrUmVzdWx0PG51bGw+IHwgbnVsbD4ge1xuICBjb25zdCBrZXkgPSB0YXNrLmtleVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJvdXRlLmNhbm9uaWNhbFVybCwgbG9jYXRpb24ub3JpZ2luKVxuICBjb25zdCBuZXh0VXJsID0ga2V5Lm5leHRVcmxcblxuICBpZiAoXG4gICAgc3Bhd25lZEVudHJpZXMuc2l6ZSA9PT0gMSAmJlxuICAgIHNwYXduZWRFbnRyaWVzLmhhcyhyb3V0ZS5tZXRhZGF0YS5yZXF1ZXN0S2V5KVxuICApIHtcbiAgICAvLyBUaGUgb25seSB0aGluZyBwZW5kaW5nIGlzIHRoZSBoZWFkLiBJbnN0cnVjdCB0aGUgc2VydmVyIHRvXG4gICAgLy8gc2tpcCBvdmVyIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICBkeW5hbWljUmVxdWVzdFRyZWUgPSBNZXRhZGF0YU9ubHlSZXF1ZXN0VHJlZVxuICB9XG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgW1JTQ19IRUFERVJdOiAnMScsXG4gICAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTpcbiAgICAgIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QoZHluYW1pY1JlcXVlc3RUcmVlKSxcbiAgfVxuICBpZiAobmV4dFVybCAhPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG4gIHN3aXRjaCAoZmV0Y2hTdHJhdGVneSkge1xuICAgIGNhc2UgRmV0Y2hTdHJhdGVneS5GdWxsOiB7XG4gICAgICAvLyBXZSBvbWl0IHRoZSBwcmVmZXRjaCBoZWFkZXIgZnJvbSBhIGZ1bGwgcHJlZmV0Y2ggYmVjYXVzZSBpdCdzIGVzc2VudGlhbGx5XG4gICAgICAvLyBqdXN0IGEgbmF2aWdhdGlvbiByZXF1ZXN0IHRoYXQgaGFwcGVucyBhaGVhZCBvZiB0aW1lIOKAlCBpdCBzaG91bGQgaW5jbHVkZVxuICAgICAgLy8gYWxsIHRoZSBzYW1lIGRhdGEgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBGZXRjaFN0cmF0ZWd5LlBQUlJ1bnRpbWU6IHtcbiAgICAgIGhlYWRlcnNbTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSXSA9ICcyJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeToge1xuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdID0gJzEnXG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBmZXRjaFN0cmF0ZWd5IHNhdGlzZmllcyBuZXZlclxuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFByZWZldGNoUmVzcG9uc2UodXJsLCBoZWFkZXJzKVxuICAgIGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLm9rIHx8ICFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAvLyBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IsIG9yIHdpdGggYSBtaXNzLiBXZSBzaG91bGQgc3RpbGwgY2FjaGVcbiAgICAgIC8vIHRoZSByZXNwb25zZSwgYnV0IHdlIGNhbiB0cnkgYWdhaW4gYWZ0ZXIgMTAgc2Vjb25kcy5cbiAgICAgIHJlamVjdFNlZ21lbnRFbnRyaWVzSWZTdGlsbFBlbmRpbmcoc3Bhd25lZEVudHJpZXMsIERhdGUubm93KCkgKyAxMCAqIDEwMDApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVkU2VhcmNoID0gZ2V0UmVuZGVyZWRTZWFyY2gocmVzcG9uc2UpXG4gICAgaWYgKHJlbmRlcmVkU2VhcmNoICE9PSByb3V0ZS5yZW5kZXJlZFNlYXJjaCkge1xuICAgICAgLy8gVGhlIHNlYXJjaCBwYXJhbXMgdGhhdCB3ZXJlIHVzZWQgdG8gcmVuZGVyIHRoZSB0YXJnZXQgcGFnZSBhcmVcbiAgICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBzZWFyY2ggcGFyYW1zIGluIHRoZSByZXF1ZXN0IFVSTC4gVGhpcyBvbmx5IGhhcHBlbnNcbiAgICAgIC8vIHdoZW4gdGhlcmUncyBhIGR5bmFtaWMgcmV3cml0ZSBpbiBiZXR3ZWVuIHRoZSB0cmVlIHByZWZldGNoIGFuZCB0aGVcbiAgICAgIC8vIGRhdGEgcHJlZmV0Y2guXG4gICAgICAvLyBUT0RPOiBGb3Igbm93LCBzaW5jZSB0aGlzIGlzIGFuIGVkZ2UgY2FzZSwgd2UgcmVqZWN0IHRoZSBwcmVmZXRjaCwgYnV0XG4gICAgICAvLyB0aGUgcHJvcGVyIHdheSB0byBoYW5kbGUgdGhpcyBpcyB0byBldmljdCB0aGUgc3RhbGUgcm91dGUgdHJlZSBlbnRyeVxuICAgICAgLy8gdGhlbiBmaWxsIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgcmVzcG9uc2UuXG4gICAgICByZWplY3RTZWdtZW50RW50cmllc0lmU3RpbGxQZW5kaW5nKHNwYXduZWRFbnRyaWVzLCBEYXRlLm5vdygpICsgMTAgKiAxMDAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBUcmFjayB3aGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgIGNvbnN0IGNsb3NlZCA9IGNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzPHZvaWQ+KClcblxuICAgIGxldCBmdWxmaWxsZWRFbnRyaWVzOiBBcnJheTxGdWxmaWxsZWRTZWdtZW50Q2FjaGVFbnRyeT4gfCBudWxsID0gbnVsbFxuICAgIGNvbnN0IHByZWZldGNoU3RyZWFtID0gY3JlYXRlUHJlZmV0Y2hSZXNwb25zZVN0cmVhbShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbG9zZWQucmVzb2x2ZSxcbiAgICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2VTaXplVXBkYXRlKHRvdGFsQnl0ZXNSZWNlaXZlZFNvRmFyKSB7XG4gICAgICAgIC8vIFdoZW4gcHJvY2Vzc2luZyBhIGR5bmFtaWMgcmVzcG9uc2UsIHdlIGRvbid0IGtub3cgaG93IGxhcmdlIGVhY2hcbiAgICAgICAgLy8gaW5kaXZpZHVhbCBzZWdtZW50IGlzLCBzbyBhcHByb3hpbWF0ZSBieSBhc3NpZ2luZyBlYWNoIHNlZ21lbnRcbiAgICAgICAgLy8gdGhlIGF2ZXJhZ2Ugb2YgdGhlIHRvdGFsIHJlc3BvbnNlIHNpemUuXG4gICAgICAgIGlmIChmdWxmaWxsZWRFbnRyaWVzID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSGF2ZW4ndCByZWNlaXZlZCBlbm91Z2ggZGF0YSB5ZXQgdG8ga25vdyB3aGljaCBzZWdtZW50c1xuICAgICAgICAgIC8vIHdlcmUgaW5jbHVkZWQuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXZlcmFnZVNpemUgPSB0b3RhbEJ5dGVzUmVjZWl2ZWRTb0ZhciAvIGZ1bGZpbGxlZEVudHJpZXMubGVuZ3RoXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZnVsZmlsbGVkRW50cmllcykge1xuICAgICAgICAgIHNldFNpemVJbkNhY2hlTWFwKGVudHJ5LCBhdmVyYWdlU2l6ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgICBjb25zdCBzZXJ2ZXJEYXRhID0gYXdhaXQgKGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gICAgICBwcmVmZXRjaFN0cmVhbSxcbiAgICAgIGhlYWRlcnNcbiAgICApIGFzIFByb21pc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPilcblxuICAgIGNvbnN0IGlzUmVzcG9uc2VQYXJ0aWFsID1cbiAgICAgIGZldGNoU3RyYXRlZ3kgPT09IEZldGNoU3RyYXRlZ3kuUFBSUnVudGltZVxuICAgICAgICA/IC8vIEEgcnVudGltZSBwcmVmZXRjaCBtYXkgaGF2ZSBob2xlcy5cbiAgICAgICAgICBzZXJ2ZXJEYXRhLnJwPy5bMF0gPT09IHRydWVcbiAgICAgICAgOiAvLyBGdWxsIGFuZCBMb2FkaW5nQm91bmRhcnkgcHJlZmV0Y2hlcyBjYW5ub3QgaGF2ZSBob2xlcy5cbiAgICAgICAgICAvLyAoZXZlbiBpZiB3ZSBkaWQgc2V0IHRoZSBwcmVmZXRjaCBoZWFkZXIsIHdlIG9ubHkgdXNlIHRoaXMgY29kZXBhdGggZm9yIG5vbi1QUFItZW5hYmxlZCByb3V0ZXMpXG4gICAgICAgICAgZmFsc2VcblxuICAgIC8vIEFzaWRlIGZyb20gd3JpdGluZyB0aGUgZGF0YSBpbnRvIHRoZSBjYWNoZSwgdGhpcyBmdW5jdGlvbiBhbHNvIHJldHVybnNcbiAgICAvLyB0aGUgZW50cmllcyB0aGF0IHdlcmUgZnVsZmlsbGVkLCBzbyB3ZSBjYW4gc3RyZWFtaW5nbHkgdXBkYXRlIHRoZWlyIHNpemVzXG4gICAgLy8gaW4gdGhlIExSVSBhcyBtb3JlIGRhdGEgY29tZXMgaW4uXG4gICAgZnVsZmlsbGVkRW50cmllcyA9IHdyaXRlRHluYW1pY1JlbmRlclJlc3BvbnNlSW50b0NhY2hlKFxuICAgICAgRGF0ZS5ub3coKSxcbiAgICAgIHRhc2ssXG4gICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgcmVzcG9uc2UgYXMgUlNDUmVzcG9uc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPixcbiAgICAgIHNlcnZlckRhdGEsXG4gICAgICBpc1Jlc3BvbnNlUGFydGlhbCxcbiAgICAgIHJvdXRlLFxuICAgICAgc3Bhd25lZEVudHJpZXNcbiAgICApXG5cbiAgICAvLyBSZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbmV0d29yayBjb25uZWN0aW9uIGNsb3Nlcywgc29cbiAgICAvLyB0aGUgc2NoZWR1bGVyIGNhbiB0cmFjayB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgbmV0d29yayBjb25uZWN0aW9ucy5cbiAgICByZXR1cm4geyB2YWx1ZTogbnVsbCwgY2xvc2VkOiBjbG9zZWQucHJvbWlzZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhzcGF3bmVkRW50cmllcywgRGF0ZS5ub3coKSArIDEwICogMTAwMClcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlRHluYW1pY1RyZWVSZXNwb25zZUludG9DYWNoZShcbiAgbm93OiBudW1iZXIsXG4gIHRhc2s6IFByZWZldGNoVGFzayxcbiAgZmV0Y2hTdHJhdGVneTpcbiAgICB8IEZldGNoU3RyYXRlZ3kuTG9hZGluZ0JvdW5kYXJ5XG4gICAgfCBGZXRjaFN0cmF0ZWd5LlBQUlJ1bnRpbWVcbiAgICB8IEZldGNoU3RyYXRlZ3kuRnVsbCxcbiAgcmVzcG9uc2U6IFJTQ1Jlc3BvbnNlPE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZT4sXG4gIHNlcnZlckRhdGE6IE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZSxcbiAgZW50cnk6IFBlbmRpbmdSb3V0ZUNhY2hlRW50cnksXG4gIGNvdWxkQmVJbnRlcmNlcHRlZDogYm9vbGVhbixcbiAgY2Fub25pY2FsVXJsOiBzdHJpbmcsXG4gIHJvdXRlSXNQUFJFbmFibGVkOiBib29sZWFuXG4pIHtcbiAgLy8gR2V0IHRoZSBVUkwgdGhhdCB3YXMgdXNlZCB0byByZW5kZXIgdGhlIHRhcmdldCBwYWdlLiBUaGlzIG1heSBiZSBkaWZmZXJlbnRcbiAgLy8gZnJvbSB0aGUgVVJMIGluIHRoZSByZXF1ZXN0IFVSTCwgaWYgdGhlIHBhZ2Ugd2FzIHJld3JpdHRlbi5cbiAgY29uc3QgcmVuZGVyZWRTZWFyY2ggPSBnZXRSZW5kZXJlZFNlYXJjaChyZXNwb25zZSlcblxuICBjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YVJlc3VsdCA9IG5vcm1hbGl6ZUZsaWdodERhdGEoc2VydmVyRGF0YS5mKVxuICBpZiAoXG4gICAgLy8gQSBzdHJpbmcgcmVzdWx0IG1lYW5zIG5hdmlnYXRpbmcgdG8gdGhpcyByb3V0ZSB3aWxsIHJlc3VsdCBpbiBhblxuICAgIC8vIE1QQSBuYXZpZ2F0aW9uLlxuICAgIHR5cGVvZiBub3JtYWxpemVkRmxpZ2h0RGF0YVJlc3VsdCA9PT0gJ3N0cmluZycgfHxcbiAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVJlc3VsdC5sZW5ndGggIT09IDFcbiAgKSB7XG4gICAgcmVqZWN0Um91dGVDYWNoZUVudHJ5KGVudHJ5LCBub3cgKyAxMCAqIDEwMDApXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgZmxpZ2h0RGF0YSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhUmVzdWx0WzBdXG4gIGlmICghZmxpZ2h0RGF0YS5pc1Jvb3RSZW5kZXIpIHtcbiAgICAvLyBVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdC5cbiAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIG5vdyArIDEwICogMTAwMClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGZsaWdodFJvdXRlclN0YXRlID0gZmxpZ2h0RGF0YS50cmVlXG4gIC8vIEZvciBydW50aW1lIHByZWZldGNoZXMsIHN0YWxlIHRpbWUgaXMgaW4gdGhlIHBheWxvYWQgYXQgcnBbMV0uXG4gIC8vIEZvciBvdGhlciByZXNwb25zZXMsIGZhbGwgYmFjayB0byB0aGUgaGVhZGVyLlxuICBjb25zdCBzdGFsZVRpbWVTZWNvbmRzID1cbiAgICB0eXBlb2Ygc2VydmVyRGF0YS5ycD8uWzFdID09PSAnbnVtYmVyJ1xuICAgICAgPyBzZXJ2ZXJEYXRhLnJwWzFdXG4gICAgICA6IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSKSA/PyAnJywgMTApXG4gIGNvbnN0IHN0YWxlVGltZU1zID0gIWlzTmFOKHN0YWxlVGltZVNlY29uZHMpXG4gICAgPyBnZXRTdGFsZVRpbWVNcyhzdGFsZVRpbWVTZWNvbmRzKVxuICAgIDogU1RBVElDX1NUQUxFVElNRV9NU1xuXG4gIC8vIElmIHRoZSByZXNwb25zZSBjb250YWlucyBkeW5hbWljIGhvbGVzLCB0aGVuIHdlIG11c3QgY29uc2VydmF0aXZlbHkgYXNzdW1lXG4gIC8vIHRoYXQgYW55IGluZGl2aWR1YWwgc2VnbWVudCBtaWdodCBjb250YWluIGR5bmFtaWMgaG9sZXMsIGFuZCBhbHNvIHRoZVxuICAvLyBoZWFkLiBJZiBpdCBkaWQgbm90IGNvbnRhaW4gZHluYW1pYyBob2xlcywgdGhlbiB3ZSBjYW4gYXNzdW1lIGV2ZXJ5IHNlZ21lbnRcbiAgLy8gYW5kIHRoZSBoZWFkIGlzIGNvbXBsZXRlbHkgc3RhdGljLlxuICBjb25zdCBpc1Jlc3BvbnNlUGFydGlhbCA9XG4gICAgcmVzcG9uc2UuaGVhZGVycy5nZXQoTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSKSA9PT0gJzEnXG5cbiAgLy8gQ29udmVydCB0aGUgc2VydmVyLXNlbnQgZGF0YSBpbnRvIHRoZSBSb3V0ZVRyZWUgZm9ybWF0IHVzZWQgYnkgdGhlXG4gIC8vIGNsaWVudCBjYWNoZS5cbiAgLy9cbiAgLy8gRHVyaW5nIHRoaXMgdHJhdmVyc2FsLCB3ZSBhY2N1bXVsYXRlIGFkZGl0aW9uYWwgZGF0YSBpbnRvIHRoaXNcbiAgLy8gXCJhY2N1bXVsYXRvclwiIG9iamVjdC5cbiAgY29uc3QgYWNjOiBSb3V0ZVRyZWVBY2N1bXVsYXRvciA9IHsgbWV0YWRhdGFWYXJ5UGF0aDogbnVsbCB9XG4gIGNvbnN0IHJvdXRlVHJlZSA9IGNvbnZlcnRSb290RmxpZ2h0Um91dGVyU3RhdGVUb1JvdXRlVHJlZShcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgICByZW5kZXJlZFNlYXJjaCxcbiAgICBhY2NcbiAgKVxuICBjb25zdCBtZXRhZGF0YVZhcnlQYXRoID0gYWNjLm1ldGFkYXRhVmFyeVBhdGhcbiAgaWYgKG1ldGFkYXRhVmFyeVBhdGggPT09IG51bGwpIHtcbiAgICByZWplY3RSb3V0ZUNhY2hlRW50cnkoZW50cnksIG5vdyArIDEwICogMTAwMClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGZ1bGZpbGxlZEVudHJ5ID0gZnVsZmlsbFJvdXRlQ2FjaGVFbnRyeShcbiAgICBlbnRyeSxcbiAgICByb3V0ZVRyZWUsXG4gICAgbWV0YWRhdGFWYXJ5UGF0aCxcbiAgICBub3cgKyBzdGFsZVRpbWVNcyxcbiAgICBjb3VsZEJlSW50ZXJjZXB0ZWQsXG4gICAgY2Fub25pY2FsVXJsLFxuICAgIHJlbmRlcmVkU2VhcmNoLFxuICAgIHJvdXRlSXNQUFJFbmFibGVkXG4gIClcblxuICAvLyBJZiB0aGUgc2VydmVyIHNlbnQgc2VnbWVudCBkYXRhIGFzIHBhcnQgb2YgdGhlIHJlc3BvbnNlLCB3ZSBzaG91bGQgd3JpdGVcbiAgLy8gaXQgaW50byB0aGUgY2FjaGUgdG8gcHJldmVudCBhIHNlY29uZCwgcmVkdW5kYW50IHByZWZldGNoIHJlcXVlc3QuXG4gIC8vXG4gIC8vIFRPRE86IFdoZW4gYGNsaWVudFNlZ21lbnRDYWNoZWAgaXMgZW5hYmxlZCwgdGhlIHNlcnZlciBkb2VzIG5vdCBpbmNsdWRlXG4gIC8vIHNlZ21lbnQgZGF0YSB3aGVuIHJlc3BvbmRpbmcgdG8gYSByb3V0ZSB0cmVlIHByZWZldGNoIHJlcXVlc3QuIEhvd2V2ZXIsXG4gIC8vIHdoZW4gYGNsaWVudFNlZ21lbnRDYWNoZWAgaXMgc2V0IHRvIFwiY2xpZW50LW9ubHlcIiwgYW5kIFBQUiBpcyBlbmFibGVkIChvclxuICAvLyB0aGUgcGFnZSBpcyBmdWxseSBzdGF0aWMpLCB0aGUgbm9ybWFsIGNoZWNrIGlzIGJ5cGFzc2VkIGFuZCB0aGUgc2VydmVyXG4gIC8vIHJlc3BvbmRzIHdpdGggdGhlIGZ1bGwgcGFnZS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzaXR1YXRpb24gdW50aWwgd2UgY2FuXG4gIC8vIHJlbW92ZSB0aGUgXCJjbGllbnQtb25seVwiIG9wdGlvbi4gVGhlbiwgd2UgY2FuIGRlbGV0ZSB0aGlzIGZ1bmN0aW9uIGNhbGwuXG4gIHdyaXRlRHluYW1pY1JlbmRlclJlc3BvbnNlSW50b0NhY2hlKFxuICAgIG5vdyxcbiAgICB0YXNrLFxuICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgcmVzcG9uc2UsXG4gICAgc2VydmVyRGF0YSxcbiAgICBpc1Jlc3BvbnNlUGFydGlhbCxcbiAgICBmdWxmaWxsZWRFbnRyeSxcbiAgICBudWxsXG4gIClcbn1cblxuZnVuY3Rpb24gcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhcbiAgZW50cmllczogTWFwPFNlZ21lbnRSZXF1ZXN0S2V5LCBTZWdtZW50Q2FjaGVFbnRyeT4sXG4gIHN0YWxlQXQ6IG51bWJlclxuKTogQXJyYXk8RnVsZmlsbGVkU2VnbWVudENhY2hlRW50cnk+IHtcbiAgY29uc3QgZnVsZmlsbGVkRW50cmllcyA9IFtdXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcy52YWx1ZXMoKSkge1xuICAgIGlmIChlbnRyeS5zdGF0dXMgPT09IEVudHJ5U3RhdHVzLlBlbmRpbmcpIHtcbiAgICAgIHJlamVjdFNlZ21lbnRDYWNoZUVudHJ5KGVudHJ5LCBzdGFsZUF0KVxuICAgIH0gZWxzZSBpZiAoZW50cnkuc3RhdHVzID09PSBFbnRyeVN0YXR1cy5GdWxmaWxsZWQpIHtcbiAgICAgIGZ1bGZpbGxlZEVudHJpZXMucHVzaChlbnRyeSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bGZpbGxlZEVudHJpZXNcbn1cblxuZnVuY3Rpb24gd3JpdGVEeW5hbWljUmVuZGVyUmVzcG9uc2VJbnRvQ2FjaGUoXG4gIG5vdzogbnVtYmVyLFxuICB0YXNrOiBQcmVmZXRjaFRhc2ssXG4gIGZldGNoU3RyYXRlZ3k6XG4gICAgfCBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeVxuICAgIHwgRmV0Y2hTdHJhdGVneS5QUFJSdW50aW1lXG4gICAgfCBGZXRjaFN0cmF0ZWd5LkZ1bGwsXG4gIHJlc3BvbnNlOiBSU0NSZXNwb25zZTxOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2U+LFxuICBzZXJ2ZXJEYXRhOiBOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2UsXG4gIGlzUmVzcG9uc2VQYXJ0aWFsOiBib29sZWFuLFxuICByb3V0ZTogRnVsZmlsbGVkUm91dGVDYWNoZUVudHJ5LFxuICBzcGF3bmVkRW50cmllczogTWFwPFNlZ21lbnRSZXF1ZXN0S2V5LCBQZW5kaW5nU2VnbWVudENhY2hlRW50cnk+IHwgbnVsbFxuKTogQXJyYXk8RnVsZmlsbGVkU2VnbWVudENhY2hlRW50cnk+IHwgbnVsbCB7XG4gIGlmIChzZXJ2ZXJEYXRhLmIgIT09IGdldEFwcEJ1aWxkSWQoKSkge1xuICAgIC8vIFRoZSBzZXJ2ZXIgYnVpbGQgZG9lcyBub3QgbWF0Y2ggdGhlIGNsaWVudC4gVHJlYXQgYXMgYSA0MDQuIER1cmluZ1xuICAgIC8vIGFuIGFjdHVhbCBuYXZpZ2F0aW9uLCB0aGUgcm91dGVyIHdpbGwgdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBDb25zaWRlciBtb3ZpbmcgdGhlIGJ1aWxkIElEIHRvIGEgcmVzcG9uc2UgaGVhZGVyIHNvIHdlIGNhbiBjaGVja1xuICAgIC8vIGl0IGJlZm9yZSBkZWNvZGluZyB0aGUgcmVzcG9uc2UsIGFuZCBzbyB0aGVyZSdzIG9uZSB3YXkgb2YgY2hlY2tpbmdcbiAgICAvLyBhY3Jvc3MgYWxsIHJlc3BvbnNlIHR5cGVzLlxuICAgIGlmIChzcGF3bmVkRW50cmllcyAhPT0gbnVsbCkge1xuICAgICAgcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhzcGF3bmVkRW50cmllcywgbm93ICsgMTAgKiAxMDAwKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgZmxpZ2h0RGF0YXMgPSBub3JtYWxpemVGbGlnaHREYXRhKHNlcnZlckRhdGEuZilcbiAgaWYgKHR5cGVvZiBmbGlnaHREYXRhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUaGlzIG1lYW5zIG5hdmlnYXRpbmcgdG8gdGhpcyByb3V0ZSB3aWxsIHJlc3VsdCBpbiBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgY2FjaGUgdGhpcywgdG9vLCBzbyB0aGF0IHRoZSBNUEEgbmF2aWdhdGlvbiBpcyBpbW1lZGlhdGUuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEZvciBydW50aW1lIHByZWZldGNoZXMsIHN0YWxlIHRpbWUgaXMgaW4gdGhlIHBheWxvYWQgYXQgcnBbMV0uXG4gIC8vIEZvciBvdGhlciByZXNwb25zZXMsIGZhbGwgYmFjayB0byB0aGUgaGVhZGVyLlxuICBjb25zdCBzdGFsZVRpbWVTZWNvbmRzID1cbiAgICB0eXBlb2Ygc2VydmVyRGF0YS5ycD8uWzFdID09PSAnbnVtYmVyJ1xuICAgICAgPyBzZXJ2ZXJEYXRhLnJwWzFdXG4gICAgICA6IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSKSA/PyAnJywgMTApXG4gIGNvbnN0IHN0YWxlVGltZU1zID0gIWlzTmFOKHN0YWxlVGltZVNlY29uZHMpXG4gICAgPyBnZXRTdGFsZVRpbWVNcyhzdGFsZVRpbWVTZWNvbmRzKVxuICAgIDogU1RBVElDX1NUQUxFVElNRV9NU1xuICBjb25zdCBzdGFsZUF0ID0gbm93ICsgc3RhbGVUaW1lTXNcblxuICBmb3IgKGNvbnN0IGZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YXMpIHtcbiAgICBjb25zdCBzZWVkRGF0YSA9IGZsaWdodERhdGEuc2VlZERhdGFcbiAgICBpZiAoc2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciByZXByZXNlbnRzIG9ubHkgYSBzdWJ0cmVlIG9mIHRoZSBhcHAuIFdlXG4gICAgICAvLyBuZWVkIHRvIGZpbmQgdGhlIHBhcnQgb2YgdGhlIHRhc2sgdHJlZSB0aGF0IG1hdGNoZXMgdGhlIHJlc3BvbnNlLlxuICAgICAgLy9cbiAgICAgIC8vIHNlZ21lbnRQYXRoIHJlcHJlc2VudHMgdGhlIHBhcmVudCBwYXRoIG9mIHN1YnRyZWUuIEl0J3MgYSByZXBlYXRpbmdcbiAgICAgIC8vIHBhdHRlcm4gb2YgcGFyYWxsZWwgcm91dGUga2V5IGFuZCBzZWdtZW50OlxuICAgICAgLy9cbiAgICAgIC8vICAgW3N0cmluZywgU2VnbWVudCwgc3RyaW5nLCBTZWdtZW50LCBzdHJpbmcsIFNlZ21lbnQsIC4uLl1cbiAgICAgIGNvbnN0IHNlZ21lbnRQYXRoID0gZmxpZ2h0RGF0YS5zZWdtZW50UGF0aFxuICAgICAgbGV0IHRyZWUgPSByb3V0ZS50cmVlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsUm91dGVLZXk6IHN0cmluZyA9IHNlZ21lbnRQYXRoW2ldXG4gICAgICAgIGlmICh0cmVlPy5zbG90cz8uW3BhcmFsbGVsUm91dGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0cmVlID0gdHJlZS5zbG90c1twYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzcGF3bmVkRW50cmllcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhzcGF3bmVkRW50cmllcywgbm93ICsgMTAgKiAxMDAwKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdyaXRlU2VlZERhdGFJbnRvQ2FjaGUoXG4gICAgICAgIG5vdyxcbiAgICAgICAgdGFzayxcbiAgICAgICAgZmV0Y2hTdHJhdGVneSxcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHN0YWxlQXQsXG4gICAgICAgIHNlZWREYXRhLFxuICAgICAgICBpc1Jlc3BvbnNlUGFydGlhbCxcbiAgICAgICAgc3Bhd25lZEVudHJpZXNcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkID0gZmxpZ2h0RGF0YS5oZWFkXG4gICAgaWYgKGhlYWQgIT09IG51bGwpIHtcbiAgICAgIGZ1bGZpbGxFbnRyeVNwYXduZWRCeVJ1bnRpbWVQcmVmZXRjaChcbiAgICAgICAgbm93LFxuICAgICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgaGVhZCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZmxpZ2h0RGF0YS5pc0hlYWRQYXJ0aWFsLFxuICAgICAgICBzdGFsZUF0LFxuICAgICAgICByb3V0ZS5tZXRhZGF0YSxcbiAgICAgICAgc3Bhd25lZEVudHJpZXNcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgLy8gQW55IGVudHJ5IHRoYXQncyBzdGlsbCBwZW5kaW5nIHdhcyBpbnRlbnRpb25hbGx5IG5vdCByZW5kZXJlZCBieSB0aGVcbiAgLy8gc2VydmVyLCBiZWNhdXNlIGl0IHdhcyBpbnNpZGUgdGhlIGxvYWRpbmcgYm91bmRhcnkuIE1hcmsgdGhlbSBhcyByZWplY3RlZFxuICAvLyBzbyB3ZSBrbm93IG5vdCB0byBmZXRjaCB0aGVtIGFnYWluLlxuICAvLyBUT0RPOiBJZiBQUFIgaXMgZW5hYmxlZCBvbiBzb21lIHJvdXRlcyBidXQgbm90IG90aGVycywgdGhlbiBpdCdzIHBvc3NpYmxlXG4gIC8vIHRoYXQgYSBkaWZmZXJlbnQgcGFnZSBpcyBhYmxlIHRvIGRvIGEgcGVyLXNlZ21lbnQgcHJlZmV0Y2ggb2Ygb25lIG9mIHRoZVxuICAvLyBzZWdtZW50cyB3ZSdyZSBtYXJraW5nIGFzIHJlamVjdGVkIGhlcmUuIFdlIHNob3VsZCBtYXJrIG9uIHRoZSBzZWdtZW50XG4gIC8vIHNvbWVob3cgdGhhdCB0aGUgcmVhc29uIGZvciB0aGUgcmVqZWN0aW9uIGlzIGJlY2F1c2Ugb2YgYSBub24tUFBSIHByZWZldGNoLlxuICAvLyBUaGF0IHdheSBhIHBlci1zZWdtZW50IHByZWZldGNoIGtub3dzIHRvIGRpc3JlZ2FyZCB0aGUgcmVqZWN0aW9uLlxuICBpZiAoc3Bhd25lZEVudHJpZXMgIT09IG51bGwpIHtcbiAgICBjb25zdCBmdWxmaWxsZWRFbnRyaWVzID0gcmVqZWN0U2VnbWVudEVudHJpZXNJZlN0aWxsUGVuZGluZyhcbiAgICAgIHNwYXduZWRFbnRyaWVzLFxuICAgICAgbm93ICsgMTAgKiAxMDAwXG4gICAgKVxuICAgIHJldHVybiBmdWxmaWxsZWRFbnRyaWVzXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gd3JpdGVTZWVkRGF0YUludG9DYWNoZShcbiAgbm93OiBudW1iZXIsXG4gIHRhc2s6IFByZWZldGNoVGFzayxcbiAgZmV0Y2hTdHJhdGVneTpcbiAgICB8IEZldGNoU3RyYXRlZ3kuTG9hZGluZ0JvdW5kYXJ5XG4gICAgfCBGZXRjaFN0cmF0ZWd5LlBQUlJ1bnRpbWVcbiAgICB8IEZldGNoU3RyYXRlZ3kuRnVsbCxcbiAgcm91dGU6IEZ1bGZpbGxlZFJvdXRlQ2FjaGVFbnRyeSxcbiAgdHJlZTogUm91dGVUcmVlLFxuICBzdGFsZUF0OiBudW1iZXIsXG4gIHNlZWREYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgaXNSZXNwb25zZVBhcnRpYWw6IGJvb2xlYW4sXG4gIGVudHJpZXNPd25lZEJ5Q3VycmVudFRhc2s6IE1hcDxcbiAgICBTZWdtZW50UmVxdWVzdEtleSxcbiAgICBQZW5kaW5nU2VnbWVudENhY2hlRW50cnlcbiAgPiB8IG51bGxcbikge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gd3JpdGUgdGhlIHJlc3VsdCBvZiBhIHJ1bnRpbWUgc2VydmVyIHJlcXVlc3RcbiAgLy8gKENhY2hlTm9kZVNlZWREYXRhKSBpbnRvIHRoZSBwcmVmZXRjaCBjYWNoZS5cbiAgY29uc3QgcnNjID0gc2VlZERhdGFbMF1cbiAgY29uc3QgbG9hZGluZyA9IHNlZWREYXRhWzJdXG4gIGNvbnN0IGlzUGFydGlhbCA9IHJzYyA9PT0gbnVsbCB8fCBpc1Jlc3BvbnNlUGFydGlhbFxuICBmdWxmaWxsRW50cnlTcGF3bmVkQnlSdW50aW1lUHJlZmV0Y2goXG4gICAgbm93LFxuICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgcm91dGUsXG4gICAgcnNjLFxuICAgIGxvYWRpbmcsXG4gICAgaXNQYXJ0aWFsLFxuICAgIHN0YWxlQXQsXG4gICAgdHJlZSxcbiAgICBlbnRyaWVzT3duZWRCeUN1cnJlbnRUYXNrXG4gIClcblxuICAvLyBSZWN1cnNpdmVseSB3cml0ZSB0aGUgY2hpbGQgZGF0YSBpbnRvIHRoZSBjYWNoZS5cbiAgY29uc3Qgc2xvdHMgPSB0cmVlLnNsb3RzXG4gIGlmIChzbG90cyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWREYXRhQ2hpbGRyZW4gPSBzZWVkRGF0YVsxXVxuICAgIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBpbiBzbG90cykge1xuICAgICAgY29uc3QgY2hpbGRUcmVlID0gc2xvdHNbcGFyYWxsZWxSb3V0ZUtleV1cbiAgICAgIGNvbnN0IGNoaWxkU2VlZERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCB8IHZvaWQgPVxuICAgICAgICBzZWVkRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICBpZiAoY2hpbGRTZWVkRGF0YSAhPT0gbnVsbCAmJiBjaGlsZFNlZWREYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd3JpdGVTZWVkRGF0YUludG9DYWNoZShcbiAgICAgICAgICBub3csXG4gICAgICAgICAgdGFzayxcbiAgICAgICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgIGNoaWxkVHJlZSxcbiAgICAgICAgICBzdGFsZUF0LFxuICAgICAgICAgIGNoaWxkU2VlZERhdGEsXG4gICAgICAgICAgaXNSZXNwb25zZVBhcnRpYWwsXG4gICAgICAgICAgZW50cmllc093bmVkQnlDdXJyZW50VGFza1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGxFbnRyeVNwYXduZWRCeVJ1bnRpbWVQcmVmZXRjaChcbiAgbm93OiBudW1iZXIsXG4gIGZldGNoU3RyYXRlZ3k6XG4gICAgfCBGZXRjaFN0cmF0ZWd5LkxvYWRpbmdCb3VuZGFyeVxuICAgIHwgRmV0Y2hTdHJhdGVneS5QUFJSdW50aW1lXG4gICAgfCBGZXRjaFN0cmF0ZWd5LkZ1bGwsXG4gIHJvdXRlOiBGdWxmaWxsZWRSb3V0ZUNhY2hlRW50cnksXG4gIHJzYzogUmVhY3QuUmVhY3ROb2RlLFxuICBsb2FkaW5nOiBMb2FkaW5nTW9kdWxlRGF0YSB8IFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+LFxuICBpc1BhcnRpYWw6IGJvb2xlYW4sXG4gIHN0YWxlQXQ6IG51bWJlcixcbiAgdHJlZTogUm91dGVUcmVlLFxuICBlbnRyaWVzT3duZWRCeUN1cnJlbnRUYXNrOiBNYXA8XG4gICAgU2VnbWVudFJlcXVlc3RLZXksXG4gICAgUGVuZGluZ1NlZ21lbnRDYWNoZUVudHJ5XG4gID4gfCBudWxsXG4pIHtcbiAgLy8gV2Ugc2hvdWxkIG9ubHkgd3JpdGUgaW50byBjYWNoZSBlbnRyaWVzIHRoYXQgYXJlIG93bmVkIGJ5IHVzLiBPciBjcmVhdGVcbiAgLy8gYSBuZXcgb25lIGFuZCB3cml0ZSBpbnRvIHRoYXQuIFdlIG11c3QgbmV2ZXIgd3JpdGUgb3ZlciBhbiBlbnRyeSB0aGF0IHdhc1xuICAvLyBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50IHRhc2ssIGJlY2F1c2UgdGhhdCBjYXVzZXMgZGF0YSByYWNlcy5cbiAgY29uc3Qgb3duZWRFbnRyeSA9XG4gICAgZW50cmllc093bmVkQnlDdXJyZW50VGFzayAhPT0gbnVsbFxuICAgICAgPyBlbnRyaWVzT3duZWRCeUN1cnJlbnRUYXNrLmdldCh0cmVlLnJlcXVlc3RLZXkpXG4gICAgICA6IHVuZGVmaW5lZFxuICBpZiAob3duZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZnVsZmlsbFNlZ21lbnRDYWNoZUVudHJ5KG93bmVkRW50cnksIHJzYywgbG9hZGluZywgc3RhbGVBdCwgaXNQYXJ0aWFsKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbWF0Y2hpbmcgZW50cnkuIEF0dGVtcHQgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICBjb25zdCBwb3NzaWJseU5ld0VudHJ5ID0gcmVhZE9yQ3JlYXRlU2VnbWVudENhY2hlRW50cnkoXG4gICAgICBub3csXG4gICAgICBmZXRjaFN0cmF0ZWd5LFxuICAgICAgcm91dGUsXG4gICAgICB0cmVlXG4gICAgKVxuICAgIGlmIChwb3NzaWJseU5ld0VudHJ5LnN0YXR1cyA9PT0gRW50cnlTdGF0dXMuRW1wdHkpIHtcbiAgICAgIC8vIENvbmZpcm1lZCB0aGlzIGlzIGEgbmV3IGVudHJ5LiBXZSBjYW4gZnVsZmlsbCBpdC5cbiAgICAgIGNvbnN0IG5ld0VudHJ5ID0gcG9zc2libHlOZXdFbnRyeVxuICAgICAgZnVsZmlsbFNlZ21lbnRDYWNoZUVudHJ5KFxuICAgICAgICB1cGdyYWRlVG9QZW5kaW5nU2VnbWVudChuZXdFbnRyeSwgZmV0Y2hTdHJhdGVneSksXG4gICAgICAgIHJzYyxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgc3RhbGVBdCxcbiAgICAgICAgaXNQYXJ0aWFsXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIHdhcyBhbHJlYWR5IGFuIGVudHJ5IGluIHRoZSBjYWNoZS4gQnV0IHdlIG1heSBiZSBhYmxlIHRvXG4gICAgICAvLyByZXBsYWNlIGl0IHdpdGggdGhlIG5ldyBvbmUgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgY29uc3QgbmV3RW50cnkgPSBmdWxmaWxsU2VnbWVudENhY2hlRW50cnkoXG4gICAgICAgIHVwZ3JhZGVUb1BlbmRpbmdTZWdtZW50KFxuICAgICAgICAgIGNyZWF0ZURldGFjaGVkU2VnbWVudENhY2hlRW50cnkoc3RhbGVBdCksXG4gICAgICAgICAgZmV0Y2hTdHJhdGVneVxuICAgICAgICApLFxuICAgICAgICByc2MsXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICAgIHN0YWxlQXQsXG4gICAgICAgIGlzUGFydGlhbFxuICAgICAgKVxuICAgICAgdXBzZXJ0U2VnbWVudEVudHJ5KFxuICAgICAgICBub3csXG4gICAgICAgIGdldFNlZ21lbnRWYXJ5UGF0aEZvclJlcXVlc3QoZmV0Y2hTdHJhdGVneSwgdHJlZSksXG4gICAgICAgIG5ld0VudHJ5XG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUHJlZmV0Y2hSZXNwb25zZTxUPihcbiAgdXJsOiBVUkwsXG4gIGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzXG4pOiBQcm9taXNlPFJTQ1Jlc3BvbnNlPFQ+IHwgbnVsbD4ge1xuICBjb25zdCBmZXRjaFByaW9yaXR5ID0gJ2xvdydcbiAgLy8gV2hlbiBpc3N1aW5nIGEgcHJlZmV0Y2ggcmVxdWVzdCwgZG9uJ3QgaW1tZWRpYXRlbHkgZGVjb2RlIHRoZSByZXNwb25zZTsgd2VcbiAgLy8gdXNlIHRoZSBsb3dlciBsZXZlbCBgY3JlYXRlRnJvbVJlc3BvbnNlYCBBUEkgaW5zdGVhZCBiZWNhdXNlIHdlIG5lZWQgdG8gZG9cbiAgLy8gc29tZSBleHRyYSBwcm9jZXNzaW5nIG9mIHRoZSByZXNwb25zZSBzdHJlYW0uIFNlZVxuICAvLyBgY3JlYXRlUHJlZmV0Y2hSZXNwb25zZVN0cmVhbWAgZm9yIG1vcmUgZGV0YWlscy5cbiAgY29uc3Qgc2hvdWxkSW1tZWRpYXRlbHlEZWNvZGUgPSBmYWxzZVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZUZldGNoPFQ+KFxuICAgIHVybCxcbiAgICBoZWFkZXJzLFxuICAgIGZldGNoUHJpb3JpdHksXG4gICAgc2hvdWxkSW1tZWRpYXRlbHlEZWNvZGVcbiAgKVxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENoZWNrIHRoZSBjb250ZW50IHR5cGVcbiAgaWYgKGlzT3V0cHV0RXhwb3J0TW9kZSkge1xuICAgIC8vIEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB3ZSByZWxheGVkIGFib3V0IHRoZSBjb250ZW50IHR5cGUsIHNpbmNlIGl0J3NcbiAgICAvLyBub3QgTmV4dC5qcyB0aGF0J3Mgc2VydmluZyB0aGUgcmVzcG9uc2UuIElmIHRoZSBzdGF0dXMgaXMgT0ssIGFzc3VtZSB0aGVcbiAgICAvLyByZXNwb25zZSBpcyB2YWxpZC4gSWYgaXQncyBub3QgYSB2YWxpZCByZXNwb25zZSwgdGhlIEZsaWdodCBjbGllbnQgd29uJ3RcbiAgICAvLyBiZSBhYmxlIHRvIGRlY29kZSBpdCwgYW5kIHdlJ2xsIHRyZWF0IGl0IGFzIGEgbWlzcy5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKVxuICAgIGNvbnN0IGlzRmxpZ2h0UmVzcG9uc2UgPVxuICAgICAgY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuc3RhcnRzV2l0aChSU0NfQ09OVEVOVF9UWVBFX0hFQURFUilcbiAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiByZXNwb25zZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmVmZXRjaFJlc3BvbnNlU3RyZWFtKFxuICBvcmlnaW5hbEZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4sXG4gIG9uU3RyZWFtQ2xvc2U6ICgpID0+IHZvaWQsXG4gIG9uUmVzcG9uc2VTaXplVXBkYXRlOiAoc2l6ZTogbnVtYmVyKSA9PiB2b2lkXG4pOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gIC8vIFdoZW4gUFBSIGlzIGVuYWJsZWQsIHByZWZldGNoIHN0cmVhbXMgbWF5IGNvbnRhaW4gcmVmZXJlbmNlcyB0aGF0IG5ldmVyXG4gIC8vIHJlc29sdmUsIGJlY2F1c2UgdGhhdCdzIGhvdyB3ZSBlbmNvZGUgZHluYW1pYyBkYXRhIGFjY2Vzcy4gSW4gdGhlIGRlY29kZWRcbiAgLy8gb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBGbGlnaHQgY2xpZW50LCB0aGVzZSBhcmUgcmVpZmllZCBpbnRvIGhhbmdpbmdcbiAgLy8gcHJvbWlzZXMgdGhhdCBzdXNwZW5kIGR1cmluZyByZW5kZXIsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHdoYXQgd2Ugd2FudC5cbiAgLy8gVGhlIFVJIHJlc29sdmVzIHdoZW4gaXQgc3dpdGNoZXMgdG8gdGhlIGR5bmFtaWMgZGF0YSBzdHJlYW1cbiAgLy8gKHZpYSB1c2VEZWZlcnJlZFZhbHVlKGR5bmFtaWMsIHN0YXRpYykpLlxuICAvL1xuICAvLyBIb3dldmVyLCB0aGUgRmxpZ2h0IGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBlcnJvcnMgaWYgdGhlIHNlcnZlciBjbG9zZXNcbiAgLy8gdGhlIHJlc3BvbnNlIGJlZm9yZSBhbGwgdGhlIHJlZmVyZW5jZXMgYXJlIHJlc29sdmVkLiBBcyBhIGNoZWF0IHRvIHdvcmtcbiAgLy8gYXJvdW5kIHRoaXMsIHdlIHdyYXAgdGhlIG9yaWdpbmFsIHN0cmVhbSBpbiBhIG5ldyBzdHJlYW0gdGhhdCBuZXZlciBjbG9zZXMsXG4gIC8vIGFuZCB0aGVyZWZvcmUgZG9lc24ndCBlcnJvci5cbiAgLy9cbiAgLy8gV2hpbGUgcHJvY2Vzc2luZyB0aGUgb3JpZ2luYWwgc3RyZWFtLCB3ZSBhbHNvIGluY3JlbWVudGFsbHkgdXBkYXRlIHRoZSBzaXplXG4gIC8vIG9mIHRoZSBjYWNoZSBlbnRyeSBpbiB0aGUgTFJVLlxuICBsZXQgdG90YWxCeXRlTGVuZ3RoID0gMFxuICBjb25zdCByZWFkZXIgPSBvcmlnaW5hbEZsaWdodFN0cmVhbS5nZXRSZWFkZXIoKVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgLy8gUGFzcyB0byB0aGUgdGFyZ2V0IHN0cmVhbSBhbmQga2VlcCBjb25zdW1pbmcgdGhlIEZsaWdodCByZXNwb25zZVxuICAgICAgICAgIC8vIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpXG5cbiAgICAgICAgICAvLyBJbmNyZW1lbnRhbGx5IHVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgY2FjaGUgZW50cnkgaW4gdGhlIExSVS5cbiAgICAgICAgICAvLyBOT1RFOiBTaW5jZSBwcmVmZXRjaCByZXNwb25zZXMgYXJlIGRlbGl2ZXJlZCBpbiBhIHNpbmdsZSBjaHVuayxcbiAgICAgICAgICAvLyBpdCdzIG5vdCByZWFsbHkgbmVjZXNzYXJ5IHRvIGRvIHRoaXMgc3RyZWFtaW5nbHksIGJ1dCBJJ20gZG9pbmcgaXRcbiAgICAgICAgICAvLyBhbnl3YXkgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICB0b3RhbEJ5dGVMZW5ndGggKz0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgIG9uUmVzcG9uc2VTaXplVXBkYXRlKHRvdGFsQnl0ZUxlbmd0aClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc3RyZWFtIGhhcyBjbG9zZWQuIEV4aXQsIGJ1dCBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbG9zZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IHN0cmVhbS4gV2UgZG8gbm90aWZ5IHRoZSBjYWxsZXIsIHRob3VnaC5cbiAgICAgICAgb25TdHJlYW1DbG9zZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnRQYXRoVG9VcmxJbk91dHB1dEV4cG9ydE1vZGUoXG4gIHVybDogVVJMLFxuICBzZWdtZW50UGF0aDogU2VnbWVudFJlcXVlc3RLZXlcbik6IFVSTCB7XG4gIGlmIChpc091dHB1dEV4cG9ydE1vZGUpIHtcbiAgICAvLyBJbiBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgd2UgY2Fubm90IHVzZSBhIGhlYWRlciB0byBlbmNvZGUgdGhlIHNlZ21lbnRcbiAgICAvLyBwYXRoLiBJbnN0ZWFkLCB3ZSBhcHBlbmQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgcGF0aG5hbWUuXG4gICAgY29uc3Qgc3RhdGljVXJsID0gbmV3IFVSTCh1cmwpXG4gICAgY29uc3Qgcm91dGVEaXIgPSBzdGF0aWNVcmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKVxuICAgICAgPyBzdGF0aWNVcmwucGF0aG5hbWUuc2xpY2UoMCwgLTEpXG4gICAgICA6IHN0YXRpY1VybC5wYXRobmFtZVxuICAgIGNvbnN0IHN0YXRpY0V4cG9ydEZpbGVuYW1lID1cbiAgICAgIGNvbnZlcnRTZWdtZW50UGF0aFRvU3RhdGljRXhwb3J0RmlsZW5hbWUoc2VnbWVudFBhdGgpXG4gICAgc3RhdGljVXJsLnBhdGhuYW1lID0gYCR7cm91dGVEaXJ9LyR7c3RhdGljRXhwb3J0RmlsZW5hbWV9YFxuICAgIHJldHVybiBzdGF0aWNVcmxcbiAgfVxuICByZXR1cm4gdXJsXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIG5ldyBmZXRjaCBzdHJhdGVneSBpcyBsaWtlbHkgdG8gcHJvdmlkZSBtb3JlIGNvbnRlbnQgdGhhbiB0aGUgb2xkIG9uZS5cbiAqXG4gKiBHZW5lcmFsbHksIHdoZW4gYW4gYXBwIHVzZXMgZHluYW1pYyBkYXRhLCBhIFwibW9yZSBzcGVjaWZpY1wiIGZldGNoIHN0cmF0ZWd5IGlzIGV4cGVjdGVkIHRvIHByb3ZpZGUgbW9yZSBjb250ZW50OlxuICogLSBgTG9hZGluZ0JvdW5kYXJ5YCBvbmx5IHByb3ZpZGVzIHN0YXRpYyBsYXlvdXRzXG4gKiAtIGBQUFJgIGNhbiBwcm92aWRlIHNoZWxscyBmb3IgZWFjaCBzZWdtZW50IChldmVuIGZvciBzZWdtZW50cyB0aGF0IHVzZSBkeW5hbWljIGRhdGEpXG4gKiAtIGBQUFJSdW50aW1lYCBjYW4gYWRkaXRpb25hbGx5IGluY2x1ZGUgY29udGVudCB0aGF0IHVzZXMgc2VhcmNoUGFyYW1zLCBwYXJhbXMsIG9yIGNvb2tpZXNcbiAqIC0gYEZ1bGxgIGluY2x1ZGVzIGFsbCB0aGUgY29udGVudCwgZXZlbiBpZiBpdCB1c2VzIGR5bmFtaWMgZGF0YVxuICpcbiAqIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdGhhdCBhIG1vcmUgc3BlY2lmaWMgZmV0Y2ggc3RyYXRlZ3kgKndvbid0KiBnaXZlIHVzIG1vcmUgY29udGVudCBpZjpcbiAqIC0gYSBzZWdtZW50IGlzIGZ1bGx5IHN0YXRpY1xuICogICAodGhlbiwgYFBQUmAvYFBQUlJ1bnRpbWVgL2BGdWxsYCB3aWxsIGFsbCB5aWVsZCBlcXVpdmFsZW50IHJlc3VsdHMpXG4gKiAtIHByb3ZpZGluZyBzZWFyY2hQYXJhbXMvcGFyYW1zL2Nvb2tpZXMgZG9lc24ndCByZXZlYWwgYW55IG1vcmUgY29udGVudCwgZS5nLiBiZWNhdXNlIG9mIGFuIGBhd2FpdCBjb25uZWN0aW9uKClgXG4gKiAgICh0aGVuLCBgUFBSYCBhbmQgYFBQUlJ1bnRpbWVgIHdpbGwgeWllbGQgZXF1aXZhbGVudCByZXN1bHRzLCBvbmx5IGBGdWxsYCB3aWxsIGdpdmUgdXMgbW9yZSlcbiAqIEJlY2F1c2Ugb2YgdGhpcywgd2hlbiBjb21wYXJpbmcgdHdvIHNlZ21lbnRzLCB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiB0aGUgZXhpc3Rpbmcgc2VnbWVudCBpcyBwYXJ0aWFsLlxuICogSWYgaXQncyBub3QgcGFydGlhbCwgdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gcHJlZmV0Y2ggaXQgYWdhaW4sIGV2ZW4gdXNpbmcgYSBcIm1vcmUgc3BlY2lmaWNcIiBzdHJhdGVneS5cbiAqIFRoZXJlJ3MgY3VycmVudGx5IG5vIHdheSB0byBrbm93IGlmIGBQUFJSdW50aW1lYCB3aWxsIHlpZWxkIG1vcmUgZGF0YSB0aGF0IGBQUFJgLCBzbyB3ZSBoYXZlIHRvIGFzc3VtZSBpdCB3aWxsLlxuICpcbiAqIEFsc28gbm90ZSB0aGF0LCBpbiBwcmFjdGljZSwgd2UgZG9uJ3QgZXhwZWN0IHRvIGJlIGNvbXBhcmluZyBgTG9hZGluZ0JvdW5kYXJ5YCB0byBgUFBSYC9gUFBSUnVudGltZWAsXG4gKiBiZWNhdXNlIGEgbm9uLVBQUi1lbmFibGVkIHJvdXRlIHdvdWxkbid0IGV2ZXIgdXNlIHRoZSBsYXR0ZXIgc3RyYXRlZ2llcy4gSXQgbWlnaHQgaG93ZXZlciB1c2UgYEZ1bGxgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuTmV3RmV0Y2hTdHJhdGVneVByb3ZpZGVNb3JlQ29udGVudChcbiAgY3VycmVudFN0cmF0ZWd5OiBGZXRjaFN0cmF0ZWd5LFxuICBuZXdTdHJhdGVneTogRmV0Y2hTdHJhdGVneVxuKTogYm9vbGVhbiB7XG4gIHJldHVybiBjdXJyZW50U3RyYXRlZ3kgPCBuZXdTdHJhdGVneVxufVxuIl0sIm5hbWVzIjpbIkVudHJ5U3RhdHVzIiwiY2FuTmV3RmV0Y2hTdHJhdGVneVByb3ZpZGVNb3JlQ29udGVudCIsImNvbnZlcnRSb3V0ZVRyZWVUb0ZsaWdodFJvdXRlclN0YXRlIiwiY3JlYXRlRGV0YWNoZWRTZWdtZW50Q2FjaGVFbnRyeSIsImZldGNoUm91dGVPbkNhY2hlTWlzcyIsImZldGNoU2VnbWVudE9uQ2FjaGVNaXNzIiwiZmV0Y2hTZWdtZW50UHJlZmV0Y2hlc1VzaW5nRHluYW1pY1JlcXVlc3QiLCJnZXRDdXJyZW50Q2FjaGVWZXJzaW9uIiwiZ2V0U3RhbGVUaW1lTXMiLCJvdmVyd3JpdGVSZXZhbGlkYXRpbmdTZWdtZW50Q2FjaGVFbnRyeSIsInBpbmdJbnZhbGlkYXRpb25MaXN0ZW5lcnMiLCJyZWFkT3JDcmVhdGVSZXZhbGlkYXRpbmdTZWdtZW50RW50cnkiLCJyZWFkT3JDcmVhdGVSb3V0ZUNhY2hlRW50cnkiLCJyZWFkT3JDcmVhdGVTZWdtZW50Q2FjaGVFbnRyeSIsInJlYWRSb3V0ZUNhY2hlRW50cnkiLCJyZWFkU2VnbWVudENhY2hlRW50cnkiLCJyZXF1ZXN0T3B0aW1pc3RpY1JvdXRlQ2FjaGVFbnRyeSIsInJldmFsaWRhdGVFbnRpcmVDYWNoZSIsInVwZ3JhZGVUb1BlbmRpbmdTZWdtZW50IiwidXBzZXJ0U2VnbWVudEVudHJ5Iiwid2FpdEZvclNlZ21lbnRDYWNoZUVudHJ5Iiwic3RhbGVUaW1lU2Vjb25kcyIsIk1hdGgiLCJtYXgiLCJpc091dHB1dEV4cG9ydE1vZGUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfQ09ORklHX09VVFBVVCIsIk1ldGFkYXRhT25seVJlcXVlc3RUcmVlIiwicm91dGVDYWNoZU1hcCIsImNyZWF0ZUNhY2hlTWFwIiwic2VnbWVudENhY2hlTWFwIiwiaW52YWxpZGF0aW9uTGlzdGVuZXJzIiwiY3VycmVudENhY2hlVmVyc2lvbiIsIm5leHRVcmwiLCJ0cmVlIiwic3RhcnRSZXZhbGlkYXRpb25Db29sZG93biIsInBpbmdWaXNpYmxlTGlua3MiLCJhdHRhY2hJbnZhbGlkYXRpb25MaXN0ZW5lciIsInRhc2siLCJvbkludmFsaWRhdGUiLCJTZXQiLCJhZGQiLCJub3RpZnlJbnZhbGlkYXRpb25MaXN0ZW5lciIsImVycm9yIiwicmVwb3J0RXJyb3IiLCJjb25zb2xlIiwidGFza3MiLCJpc1ByZWZldGNoVGFza0RpcnR5Iiwibm93Iiwia2V5IiwidmFyeVBhdGgiLCJnZXRSb3V0ZVZhcnlQYXRoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJpc1JldmFsaWRhdGlvbiIsImdldEZyb21DYWNoZU1hcCIsInJlYWRSZXZhbGlkYXRpbmdTZWdtZW50Q2FjaGVFbnRyeSIsInBlbmRpbmdFbnRyeSIsInByb21pc2VXaXRoUmVzb2x2ZXJzIiwicHJvbWlzZSIsImNyZWF0ZVByb21pc2VXaXRoUmVzb2x2ZXJzIiwiZXhpc3RpbmdFbnRyeSIsImNhbm9uaWNhbFVybCIsInN0YXR1cyIsImJsb2NrZWRUYXNrcyIsIm1ldGFkYXRhIiwiY291bGRCZUludGVyY2VwdGVkIiwiaXNQUFJFbmFibGVkIiwicmVuZGVyZWRTZWFyY2giLCJyZWYiLCJzaXplIiwic3RhbGVBdCIsIkluZmluaXR5IiwidmVyc2lvbiIsInNldEluQ2FjaGVNYXAiLCJyZXF1ZXN0ZWRVcmwiLCJyZXF1ZXN0ZWRTZWFyY2giLCJ1cmxXaXRob3V0U2VhcmNoUGFyYW1zIiwiVVJMIiwicm91dGVXaXRoTm9TZWFyY2hQYXJhbXMiLCJjcmVhdGVQcmVmZXRjaFJlcXVlc3RLZXkiLCJocmVmIiwiY2Fub25pY2FsVXJsRm9yUm91dGVXaXRoTm9TZWFyY2hQYXJhbXMiLCJvcmlnaW4iLCJvcHRpbWlzdGljQ2Fub25pY2FsU2VhcmNoIiwib3B0aW1pc3RpY1JlbmRlcmVkU2VhcmNoIiwib3B0aW1pc3RpY1VybCIsImxvY2F0aW9uIiwib3B0aW1pc3RpY0Nhbm9uaWNhbFVybCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwib3B0aW1pc3RpY1JvdXRlVHJlZSIsImNyZWF0ZU9wdGltaXN0aWNSb3V0ZVRyZWUiLCJvcHRpbWlzdGljTWV0YWRhdGFUcmVlIiwib3B0aW1pc3RpY0VudHJ5IiwibmV3UmVuZGVyZWRTZWFyY2giLCJjbG9uZWRTbG90cyIsIm9yaWdpbmFsU2xvdHMiLCJzbG90cyIsInBhcmFsbGVsUm91dGVLZXkiLCJjaGlsZFRyZWUiLCJpc1BhZ2UiLCJyZXF1ZXN0S2V5Iiwic2VnbWVudCIsImNsb25lUGFnZVZhcnlQYXRoV2l0aE5ld1NlYXJjaFBhcmFtcyIsImlzUm9vdExheW91dCIsImhhc0xvYWRpbmdCb3VuZGFyeSIsImhhc1J1bnRpbWVQcmVmZXRjaCIsImZldGNoU3RyYXRlZ3kiLCJyb3V0ZSIsInZhcnlQYXRoRm9yUmVxdWVzdCIsImdldFNlZ21lbnRWYXJ5UGF0aEZvclJlcXVlc3QiLCJjYW5kaWRhdGVFbnRyeSIsImlzVmFsdWVFeHBpcmVkIiwiaXNQYXJ0aWFsIiwicmVqZWN0ZWRFbnRyeSIsImxvYWRpbmciLCJyc2MiLCJkZWxldGVGcm9tQ2FjaGVNYXAiLCJlbXB0eUVudHJ5IiwiRmV0Y2hTdHJhdGVneSIsIlBQUiIsIkZ1bGwiLCJwaW5nQmxvY2tlZFRhc2tzIiwiZW50cnkiLCJwaW5nUHJlZmV0Y2hUYXNrIiwiZnVsZmlsbFJvdXRlQ2FjaGVFbnRyeSIsIm1ldGFkYXRhVmFyeVBhdGgiLCJIRUFEX1JFUVVFU1RfS0VZIiwiSGFzTG9hZGluZ0JvdW5kYXJ5IiwiU3VidHJlZUhhc05vTG9hZGluZ0JvdW5kYXJ5IiwiZnVsZmlsbGVkRW50cnkiLCJmdWxmaWxsU2VnbWVudENhY2hlRW50cnkiLCJzZWdtZW50Q2FjaGVFbnRyeSIsInJlc29sdmUiLCJyZWplY3RSb3V0ZUNhY2hlRW50cnkiLCJyZWplY3RTZWdtZW50Q2FjaGVFbnRyeSIsImNvbnZlcnRSb290VHJlZVByZWZldGNoVG9Sb3V0ZVRyZWUiLCJyb290VHJlZSIsInJlbmRlcmVkUGF0aG5hbWUiLCJhY2MiLCJwYXRobmFtZVBhcnRzIiwic3BsaXQiLCJmaWx0ZXIiLCJwIiwiaW5kZXgiLCJyb290U2VnbWVudCIsIlJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSIsImNvbnZlcnRUcmVlUHJlZmV0Y2hUb1JvdXRlVHJlZSIsInByZWZldGNoIiwicGFydGlhbFZhcnlQYXRoIiwicGF0aG5hbWVQYXJ0c0luZGV4IiwicHJlZmV0Y2hTbG90cyIsImZpbmFsaXplTGF5b3V0VmFyeVBhdGgiLCJjaGlsZFByZWZldGNoIiwiY2hpbGRQYXJhbU5hbWUiLCJuYW1lIiwiY2hpbGRQYXJhbVR5cGUiLCJwYXJhbVR5cGUiLCJjaGlsZFNlcnZlclNlbnRQYXJhbUtleSIsInBhcmFtS2V5IiwiY2hpbGREb2VzQXBwZWFySW5VUkwiLCJjaGlsZFNlZ21lbnQiLCJjaGlsZFBhcnRpYWxWYXJ5UGF0aCIsImNoaWxkUGFyYW1WYWx1ZSIsInBhcnNlRHluYW1pY1BhcmFtRnJvbVVSTFBhcnQiLCJjaGlsZFBhcmFtS2V5IiwiZ2V0Q2FjaGVLZXlGb3JEeW5hbWljUGFyYW0iLCJhcHBlbmRMYXlvdXRWYXJ5UGF0aCIsImRvZXNTdGF0aWNTZWdtZW50QXBwZWFySW5VUkwiLCJjaGlsZFBhdGhuYW1lUGFydHNJbmRleCIsImNoaWxkUmVxdWVzdEtleVBhcnQiLCJjcmVhdGVTZWdtZW50UmVxdWVzdEtleVBhcnQiLCJjaGlsZFJlcXVlc3RLZXkiLCJhcHBlbmRTZWdtZW50UmVxdWVzdEtleVBhcnQiLCJlbmRzV2l0aCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJmaW5hbGl6ZVBhZ2VWYXJ5UGF0aCIsImZpbmFsaXplTWV0YWRhdGFWYXJ5UGF0aCIsIlNlZ21lbnRIYXNMb2FkaW5nQm91bmRhcnkiLCJjb252ZXJ0Um9vdEZsaWdodFJvdXRlclN0YXRlVG9Sb3V0ZVRyZWUiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsImNvbnZlcnRGbGlnaHRSb3V0ZXJTdGF0ZVRvUm91dGVUcmVlIiwicGFyZW50UGFydGlhbFZhcnlQYXRoIiwib3JpZ2luYWxTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwicGFyYW1DYWNoZUtleSIsInBhcmFsbGVsUm91dGVzIiwiY2hpbGRSb3V0ZXJTdGF0ZSIsInVuZGVmaW5lZCIsInJvdXRlVHJlZSIsInNlZ21lbnRQYXRoIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIiLCJORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUiIsIk5FWFRfVVJMIiwidXJsIiwicmVzcG9uc2UiLCJ1cmxBZnRlclJlZGlyZWN0cyIsImhlYWRSZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiRGF0ZSIsInJlZGlyZWN0ZWQiLCJmZXRjaFByZWZldGNoUmVzcG9uc2UiLCJhZGRTZWdtZW50UGF0aFRvVXJsSW5PdXRwdXRFeHBvcnRNb2RlIiwib2siLCJib2R5IiwidmFyeUhlYWRlciIsImdldCIsImluY2x1ZGVzIiwiY2xvc2VkIiwicm91dGVJc1BQUkVuYWJsZWQiLCJORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIiLCJwcmVmZXRjaFN0cmVhbSIsImNyZWF0ZVByZWZldGNoUmVzcG9uc2VTdHJlYW0iLCJvblJlc3BvbnNlU2l6ZVVwZGF0ZSIsInNldFNpemVJbkNhY2hlTWFwIiwic2VydmVyRGF0YSIsImNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0iLCJidWlsZElkIiwiZ2V0QXBwQnVpbGRJZCIsImdldFJlbmRlcmVkUGF0aG5hbWUiLCJnZXRSZW5kZXJlZFNlYXJjaCIsInN0YWxlVGltZU1zIiwic3RhbGVUaW1lIiwiYiIsIndyaXRlRHluYW1pY1RyZWVSZXNwb25zZUludG9DYWNoZSIsIkxvYWRpbmdCb3VuZGFyeSIsImZ1bGZpbGxlZFZhcnlQYXRoIiwiZ2V0RnVsZmlsbGVkUm91dGVWYXJ5UGF0aCIsInZhbHVlIiwicm91dGVLZXkiLCJub3JtYWxpemVkUmVxdWVzdEtleSIsInJlcXVlc3RVcmwiLCJkeW5hbWljUmVxdWVzdFRyZWUiLCJzcGF3bmVkRW50cmllcyIsImhhcyIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwicHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdCIsIlBQUlJ1bnRpbWUiLCJyZWplY3RTZWdtZW50RW50cmllc0lmU3RpbGxQZW5kaW5nIiwiZnVsZmlsbGVkRW50cmllcyIsInRvdGFsQnl0ZXNSZWNlaXZlZFNvRmFyIiwiYXZlcmFnZVNpemUiLCJsZW5ndGgiLCJpc1Jlc3BvbnNlUGFydGlhbCIsInJwIiwid3JpdGVEeW5hbWljUmVuZGVyUmVzcG9uc2VJbnRvQ2FjaGUiLCJub3JtYWxpemVkRmxpZ2h0RGF0YVJlc3VsdCIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmIiwiZmxpZ2h0RGF0YSIsImlzUm9vdFJlbmRlciIsInBhcnNlSW50IiwiTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIiLCJpc05hTiIsIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJlbnRyaWVzIiwidmFsdWVzIiwicHVzaCIsImZsaWdodERhdGFzIiwic2VlZERhdGEiLCJpIiwid3JpdGVTZWVkRGF0YUludG9DYWNoZSIsImhlYWQiLCJmdWxmaWxsRW50cnlTcGF3bmVkQnlSdW50aW1lUHJlZmV0Y2giLCJpc0hlYWRQYXJ0aWFsIiwiZW50cmllc093bmVkQnlDdXJyZW50VGFzayIsInNlZWREYXRhQ2hpbGRyZW4iLCJjaGlsZFNlZWREYXRhIiwib3duZWRFbnRyeSIsInBvc3NpYmx5TmV3RW50cnkiLCJuZXdFbnRyeSIsImZldGNoUHJpb3JpdHkiLCJzaG91bGRJbW1lZGlhdGVseURlY29kZSIsImNyZWF0ZUZldGNoIiwiY29udGVudFR5cGUiLCJpc0ZsaWdodFJlc3BvbnNlIiwic3RhcnRzV2l0aCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwib3JpZ2luYWxGbGlnaHRTdHJlYW0iLCJvblN0cmVhbUNsb3NlIiwidG90YWxCeXRlTGVuZ3RoIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW0iLCJwdWxsIiwiY29udHJvbGxlciIsImRvbmUiLCJyZWFkIiwiZW5xdWV1ZSIsImJ5dGVMZW5ndGgiLCJzdGF0aWNVcmwiLCJyb3V0ZURpciIsInNsaWNlIiwic3RhdGljRXhwb3J0RmlsZW5hbWUiLCJjb252ZXJ0U2VnbWVudFBhdGhUb1N0YXRpY0V4cG9ydEZpbGVuYW1lIiwiY3VycmVudFN0cmF0ZWd5IiwibmV3U3RyYXRlZ3kiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/components/segment-cache/cache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This file is only used in app router due to the specific error state handling.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../components/is-next-router-error */ \"(app-pages-browser)/../node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/../node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _errorboundary = __webpack_require__(/*! ../components/error-boundary */ \"(app-pages-browser)/../node_modules/next/dist/client/components/error-boundary.js\");\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../components/builtin/global-error */ \"(app-pages-browser)/../node_modules/next/dist/client/components/builtin/global-error.js\"));\nconst devToolErrorMod =  true ? __webpack_require__(/*! ../../next-devtools/userspace/app/errors */ \"(app-pages-browser)/../node_modules/next/dist/next-devtools/userspace/app/errors/index.js\") : 0;\nfunction onCaughtError(thrownValue, errorInfo) {\n    const errorBoundaryComponent = errorInfo.errorBoundary?.constructor;\n    let isImplicitErrorBoundary;\n    if (true) {\n        const { AppDevOverlayErrorBoundary } = __webpack_require__(/*! ../../next-devtools/userspace/app/app-dev-overlay-error-boundary */ \"(app-pages-browser)/../node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js\");\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _globalerror.default;\n    // Skip the segment explorer triggered error\n    if (true) {\n        const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } = __webpack_require__(/*! ../../next-devtools/userspace/app/segment-explorer-node */ \"(app-pages-browser)/../node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\");\n        if (thrownValue instanceof Error && thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {\n            return;\n        }\n    }\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(thrownValue);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (true) {\n        const errorBoundaryName = errorBoundaryComponent?.displayName || errorBoundaryComponent?.name || 'Unknown';\n        const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1];\n        // Match chrome or safari stack trace\n        const matches = // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`;\n        const componentErrorMessage = componentThatErroredName ? `The above error occurred in the <${componentThatErroredName}> component.` : `The above error occurred in one of your components.`;\n        const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`;\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // Log and report the error with location but without modifying the error stack\n        devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation);\n        devToolErrorMod.handleClientError(error);\n    } else {}\n}\nfunction onUncaughtError(thrownValue) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (true) {\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(error);\n    } else {}\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary-callbacks.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL2Vycm9yLWJvdW5kYXJ5LWNhbGxiYWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpRkFBaUY7Ozs7Ozs7Ozs7Ozs7SUFrQmpFQSxhQUFhO2VBQWJBOztJQStFQUMsZUFBZTtlQUFmQTs7OzsrQ0E5RmtCOzBDQUNFOytDQUNGOzJDQUNHO2tGQUNKO0FBRWpDLE1BQU1DLGtCQUNKQyxLQUFvQixHQUNmRyxtQkFBT0EsQ0FBQywySUFBMEMsSUFDbkQsQ0FJQztBQUVBLFNBQVNOLGNBQ2RhLFdBQW9CLEVBQ3BCQyxTQUEwRDtJQUUxRCxNQUFNQyx5QkFBeUJELFVBQVVFLGFBQWEsRUFBRUM7SUFFeEQsSUFBSUM7SUFFSixJQUFJZixJQUFvQixFQUFtQjtRQUN6QyxNQUFNLEVBQUVnQiwwQkFBMEIsRUFBRSxHQUNsQ2IsbUJBQU9BLENBQUMscUxBQWtFO1FBRTVFWSwwQkFDRUgsMkJBQTJCSTtJQUMvQjtJQUVBRCwwQkFDRUEsMkJBQ0NILDJCQUEyQkssZUFBQUEsb0JBQW9CLElBQzdDTixVQUFVRSxhQUFhLENBQ3JCSyxLQUFLLENBQUNDLGNBQWMsS0FBS0MsYUFBQUEsT0FBb0I7SUFFcEQsNENBQTRDO0lBQzVDLElBQUlwQixJQUFvQixFQUFtQjtRQUN6QyxNQUFNLEVBQUVxQix3Q0FBd0MsRUFBRSxHQUNoRGxCLG1CQUFPQSxDQUFDLG1LQUF5RDtRQUNuRSxJQUNFTyx1QkFBdUJZLFNBQ3ZCWixZQUFZYSxPQUFPLEtBQUtGLDBDQUN4QjtZQUNBO1FBQ0Y7SUFDRjtJQUVBLElBQUlOLHlCQUF5QjtRQUMzQiw2RUFBNkU7UUFDN0UsdURBQXVEO1FBQ3ZELDZEQUE2RDtRQUM3RCxPQUFPakIsZ0JBQWdCWTtJQUN6QjtJQUVBLDZFQUE2RTtJQUM3RSxJQUFJYyxDQUFBQSxHQUFBQSxjQUFBQSxtQkFBQUEsRUFBb0JkLGdCQUFnQmUsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQmYsY0FBYztJQUV4RSxJQUFJVixJQUFvQixFQUFtQjtRQUN6QyxNQUFNMEIsb0JBRUosd0JBQWlDQyxXQURFLElBRW5DZix3QkFBd0JnQixRQUN4QjtRQUVGLE1BQU1DLDRCQUE0QmxCLFdBQVdtQixnQkFBZ0JDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFFM0UscUNBQXFDO1FBQ3JDLE1BQU1DLFVBQ0osc0RBQXNELCtDQUMrQztRQUNyRyxnR0FBZ0c7UUFDaEdILDJCQUEyQkksTUFBTSw0QkFBNEIsRUFBRTtRQUNqRSxNQUFNQywyQkFBMkJGLE9BQU8sQ0FBQyxFQUFFLElBQUlBLE9BQU8sQ0FBQyxFQUFFLElBQUk7UUFFN0QsaUlBQWlJO1FBQ2pJLE1BQU1HLHVCQUF1QixDQUFDLHVCQUF1QixFQUFFVCxrQkFBa0IsaUJBQWlCLENBQUM7UUFDM0YsTUFBTVUsd0JBQXdCRiwyQkFDMUIsQ0FBQyxpQ0FBaUMsRUFBRUEseUJBQXlCLFlBQVksQ0FBQyxHQUMxRSxDQUFDLG1EQUFtRCxDQUFDO1FBRXpELE1BQU1HLGdCQUFnQixHQUFHRCxzQkFBc0IsQ0FBQyxFQUFFRCxzQkFBc0I7UUFDeEUsTUFBTTlCLFFBQVFOLGdCQUFnQkssZ0JBQWdCLENBQUNNO1FBRS9DLCtFQUErRTtRQUMvRVgsZ0JBQWdCUSxrQkFBa0IsQ0FBQyxZQUFZRyxhQUFhMkI7UUFFNUR0QyxnQkFBZ0JPLGlCQUFpQixDQUFDRDtJQUNwQyxPQUFPLEVBRU47QUFDSDtBQUVPLFNBQVNQLGdCQUFnQlksV0FBb0I7SUFDbEQsNkVBQTZFO0lBQzdFLElBQUljLENBQUFBLEdBQUFBLGNBQUFBLG1CQUFBQSxFQUFvQmQsZ0JBQWdCZSxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCZixjQUFjO0lBRXhFLElBQUlWLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU1LLFFBQVFOLGdCQUFnQkssZ0JBQWdCLENBQUNNO1FBRS9DLG9GQUFvRjtRQUNwRjRCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JqQztJQUNwQixPQUFPLEVBRU47QUFDSCIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpdGFsaXl1bGl0b3Zza3kvc3JjL2NsaWVudC9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL2Vycm9yLWJvdW5kYXJ5LWNhbGxiYWNrcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgb25seSB1c2VkIGluIGFwcCByb3V0ZXIgZHVlIHRvIHRoZSBzcGVjaWZpYyBlcnJvciBzdGF0ZSBoYW5kbGluZy5cblxuaW1wb3J0IHR5cGUgeyBFcnJvckluZm8gfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IHJlcG9ydEdsb2JhbEVycm9yIH0gZnJvbSAnLi9yZXBvcnQtZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgRXJyb3JCb3VuZGFyeUhhbmRsZXIgfSBmcm9tICcuLi9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IERlZmF1bHRFcnJvckJvdW5kYXJ5IGZyb20gJy4uL2NvbXBvbmVudHMvYnVpbHRpbi9nbG9iYWwtZXJyb3InXG5cbmNvbnN0IGRldlRvb2xFcnJvck1vZDogdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycycpID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gKHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzJykpXG4gICAgOiB7XG4gICAgICAgIGRlY29yYXRlRGV2RXJyb3I6IChlcnJvcjogdW5rbm93bikgPT4gZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgIGhhbmRsZUNsaWVudEVycm9yOiAoKSA9PiB7fSxcbiAgICAgICAgb3JpZ2luQ29uc29sZUVycm9yOiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgICB9XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNhdWdodEVycm9yKFxuICB0aHJvd25WYWx1ZTogdW5rbm93bixcbiAgZXJyb3JJbmZvOiBFcnJvckluZm8gJiB7IGVycm9yQm91bmRhcnk/OiBSZWFjdC5Db21wb25lbnQgfVxuKSB7XG4gIGNvbnN0IGVycm9yQm91bmRhcnlDb21wb25lbnQgPSBlcnJvckluZm8uZXJyb3JCb3VuZGFyeT8uY29uc3RydWN0b3JcblxuICBsZXQgaXNJbXBsaWNpdEVycm9yQm91bmRhcnlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHsgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2FwcC1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeScpXG5cbiAgICBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSA9XG4gICAgICBlcnJvckJvdW5kYXJ5Q29tcG9uZW50ID09PSBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVxuICB9XG5cbiAgaXNJbXBsaWNpdEVycm9yQm91bmRhcnkgPVxuICAgIGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5IHx8XG4gICAgKGVycm9yQm91bmRhcnlDb21wb25lbnQgPT09IEVycm9yQm91bmRhcnlIYW5kbGVyICYmXG4gICAgICAoZXJyb3JJbmZvLmVycm9yQm91bmRhcnkhIGFzIEluc3RhbmNlVHlwZTx0eXBlb2YgRXJyb3JCb3VuZGFyeUhhbmRsZXI+KVxuICAgICAgICAucHJvcHMuZXJyb3JDb21wb25lbnQgPT09IERlZmF1bHRFcnJvckJvdW5kYXJ5KVxuXG4gIC8vIFNraXAgdGhlIHNlZ21lbnQgZXhwbG9yZXIgdHJpZ2dlcmVkIGVycm9yXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKVxuICAgIGlmIChcbiAgICAgIHRocm93blZhbHVlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIHRocm93blZhbHVlLm1lc3NhZ2UgPT09IFNFR01FTlRfRVhQTE9SRVJfU0lNVUxBVEVEX0VSUk9SX01FU1NBR0VcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIGlmIChpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIFdlIGRvbid0IGNvbnNpZGVyIGVycm9ycyBjYXVnaHQgdW5sZXNzIHRoZXkncmUgY2F1Z2h0IGJ5IGFuIGV4cGxpY2l0IGVycm9yXG4gICAgLy8gYm91bmRhcnkuIFRoZSBidWlsdC1pbiBvbmVzIGFyZSBjb25zaWRlcmVkIGltcGxpY2l0LlxuICAgIC8vIFRoaXMgbWltaWNzIGhvdyB0aGUgc2FtZSBhcHAgd291bGQgYmVoYXZlIHdpdGhvdXQgTmV4dC5qcy5cbiAgICByZXR1cm4gb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKVxuICB9XG5cbiAgLy8gU2tpcCBjZXJ0YWluIGN1c3RvbSBlcnJvcnMgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZXBvcnRlZCBvbiBjbGllbnRcbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IodGhyb3duVmFsdWUpIHx8IGlzTmV4dFJvdXRlckVycm9yKHRocm93blZhbHVlKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBlcnJvckJvdW5kYXJ5TmFtZSA9XG4gICAgICAvLyByZWFkIHJlYWN0IGNvbXBvbmVudCBkaXNwbGF5TmFtZVxuICAgICAgKGVycm9yQm91bmRhcnlDb21wb25lbnQgYXMgYW55KT8uZGlzcGxheU5hbWUgfHxcbiAgICAgIGVycm9yQm91bmRhcnlDb21wb25lbnQ/Lm5hbWUgfHxcbiAgICAgICdVbmtub3duJ1xuXG4gICAgY29uc3QgY29tcG9uZW50VGhhdEVycm9yZWRGcmFtZSA9IGVycm9ySW5mbz8uY29tcG9uZW50U3RhY2s/LnNwbGl0KCdcXG4nKVsxXVxuXG4gICAgLy8gTWF0Y2ggY2hyb21lIG9yIHNhZmFyaSBzdGFjayB0cmFjZVxuICAgIGNvbnN0IG1hdGNoZXMgPVxuICAgICAgLy8gcmVnZXggdG8gbWF0Y2ggdGhlIGZ1bmN0aW9uIG5hbWUgaW4gdGhlIHN0YWNrIHRyYWNlXG4gICAgICAvLyBleGFtcGxlIDE6IGF0IFBhZ2UgKGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzL2luZGV4LmpzP3RzPTE2MzE2MDAwMDAwMDA6MjoxKVxuICAgICAgLy8gZXhhbXBsZSAyOiBQYWdlQGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzL2luZGV4LmpzP3RzPTE2MzE2MDAwMDAwMDA6MjoxXG4gICAgICBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lPy5tYXRjaCgvXFxzK2F0IChcXHcrKVxccyt8KFxcdyspQC8pID8/IFtdXG4gICAgY29uc3QgY29tcG9uZW50VGhhdEVycm9yZWROYW1lID0gbWF0Y2hlc1sxXSB8fCBtYXRjaGVzWzJdIHx8ICdVbmtub3duJ1xuXG4gICAgLy8gQ3JlYXRlIGVycm9yIGxvY2F0aW9uIHdpdGggZXJyb3JlZCBjb21wb25lbnQgYW5kIGVycm9yIGJvdW5kYXJ5LCB0byBtYXRjaCB0aGUgYmVoYXZpb3Igb2YgZGVmYXVsdCBSZWFjdCBvbkNhdWdodEVycm9yIGhhbmRsZXIuXG4gICAgY29uc3QgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSBgSXQgd2FzIGhhbmRsZWQgYnkgdGhlIDwke2Vycm9yQm91bmRhcnlOYW1lfT4gZXJyb3IgYm91bmRhcnkuYFxuICAgIGNvbnN0IGNvbXBvbmVudEVycm9yTWVzc2FnZSA9IGNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZVxuICAgICAgPyBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JHtjb21wb25lbnRUaGF0RXJyb3JlZE5hbWV9PiBjb21wb25lbnQuYFxuICAgICAgOiBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMuYFxuXG4gICAgY29uc3QgZXJyb3JMb2NhdGlvbiA9IGAke2NvbXBvbmVudEVycm9yTWVzc2FnZX0gJHtlcnJvckJvdW5kYXJ5TWVzc2FnZX1gXG4gICAgY29uc3QgZXJyb3IgPSBkZXZUb29sRXJyb3JNb2QuZGVjb3JhdGVEZXZFcnJvcih0aHJvd25WYWx1ZSlcblxuICAgIC8vIExvZyBhbmQgcmVwb3J0IHRoZSBlcnJvciB3aXRoIGxvY2F0aW9uIGJ1dCB3aXRob3V0IG1vZGlmeWluZyB0aGUgZXJyb3Igc3RhY2tcbiAgICBkZXZUb29sRXJyb3JNb2Qub3JpZ2luQ29uc29sZUVycm9yKCclb1xcblxcbiVzJywgdGhyb3duVmFsdWUsIGVycm9yTG9jYXRpb24pXG5cbiAgICBkZXZUb29sRXJyb3JNb2QuaGFuZGxlQ2xpZW50RXJyb3IoZXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgZGV2VG9vbEVycm9yTW9kLm9yaWdpbkNvbnNvbGVFcnJvcih0aHJvd25WYWx1ZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlOiB1bmtub3duKSB7XG4gIC8vIFNraXAgY2VydGFpbiBjdXN0b20gZXJyb3JzIHdoaWNoIGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgcmVwb3J0ZWQgb24gY2xpZW50XG4gIGlmIChpc0JhaWxvdXRUb0NTUkVycm9yKHRocm93blZhbHVlKSB8fCBpc05leHRSb3V0ZXJFcnJvcih0aHJvd25WYWx1ZSkpIHJldHVyblxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgZXJyb3IgPSBkZXZUb29sRXJyb3JNb2QuZGVjb3JhdGVEZXZFcnJvcih0aHJvd25WYWx1ZSlcblxuICAgIC8vIFRPRE86IEFkZCBhbiBhZGVuZHVtIHRvIHRoZSBvdmVybGF5IHRlbGxpbmcgcGVvcGxlIGFib3V0IGN1c3RvbSBlcnJvciBib3VuZGFyaWVzLlxuICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKVxuICB9IGVsc2Uge1xuICAgIHJlcG9ydEdsb2JhbEVycm9yKHRocm93blZhbHVlKVxuICB9XG59XG4iXSwibmFtZXMiOlsib25DYXVnaHRFcnJvciIsIm9uVW5jYXVnaHRFcnJvciIsImRldlRvb2xFcnJvck1vZCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInJlcXVpcmUiLCJkZWNvcmF0ZURldkVycm9yIiwiZXJyb3IiLCJoYW5kbGVDbGllbnRFcnJvciIsIm9yaWdpbkNvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJiaW5kIiwidGhyb3duVmFsdWUiLCJlcnJvckluZm8iLCJlcnJvckJvdW5kYXJ5Q29tcG9uZW50IiwiZXJyb3JCb3VuZGFyeSIsImNvbnN0cnVjdG9yIiwiaXNJbXBsaWNpdEVycm9yQm91bmRhcnkiLCJBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSIsIkVycm9yQm91bmRhcnlIYW5kbGVyIiwicHJvcHMiLCJlcnJvckNvbXBvbmVudCIsIkRlZmF1bHRFcnJvckJvdW5kYXJ5IiwiU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSIsIkVycm9yIiwibWVzc2FnZSIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImVycm9yQm91bmRhcnlOYW1lIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiY29tcG9uZW50VGhhdEVycm9yZWRGcmFtZSIsImNvbXBvbmVudFN0YWNrIiwic3BsaXQiLCJtYXRjaGVzIiwibWF0Y2giLCJjb21wb25lbnRUaGF0RXJyb3JlZE5hbWUiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbXBvbmVudEVycm9yTWVzc2FnZSIsImVycm9yTG9jYXRpb24iLCJyZXBvcnRHbG9iYWxFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/route-params.js":
/*!********************************************************!*\
  !*** ../node_modules/next/dist/client/route-params.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    doesStaticSegmentAppearInURL: function() {\n        return doesStaticSegmentAppearInURL;\n    },\n    getCacheKeyForDynamicParam: function() {\n        return getCacheKeyForDynamicParam;\n    },\n    getParamValueFromCacheKey: function() {\n        return getParamValueFromCacheKey;\n    },\n    getRenderedPathname: function() {\n        return getRenderedPathname;\n    },\n    getRenderedSearch: function() {\n        return getRenderedSearch;\n    },\n    parseDynamicParamFromURLPart: function() {\n        return parseDynamicParamFromURLPart;\n    },\n    urlSearchParamsToParsedUrlQuery: function() {\n        return urlSearchParamsToParsedUrlQuery;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _segment = __webpack_require__(/*! ../shared/lib/segment */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/segment.js\");\nconst _segmentvalueencoding = __webpack_require__(/*! ../shared/lib/segment-cache/segment-value-encoding */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js\");\nconst _approuterheaders = __webpack_require__(/*! ./components/app-router-headers */ \"(app-pages-browser)/../node_modules/next/dist/client/components/app-router-headers.js\");\nfunction getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nfunction getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nfunction parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Catchall intercepted\n        case 'ci(..)(..)':\n        case 'ci(.)':\n        case 'ci(..)':\n        case 'ci(...)':\n            {\n                const prefix = paramType.length - 2;\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s, i)=>{\n                    if (i === 0) {\n                        return encodeURIComponent(s.slice(prefix));\n                    }\n                    return encodeURIComponent(s);\n                }) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        // Dynamic intercepted\n        case 'di(..)(..)':\n        case 'di(.)':\n        case 'di(..)':\n        case 'di(...)':\n            {\n                const prefix = paramType.length - 2;\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex].slice(prefix));\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nfunction doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(_segment.PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === _segment.DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nfunction getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = (0, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (false) {}\n    return urlWithoutFlightParameters;\n}\nfunction getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nfunction urlSearchParamsToParsedUrlQuery(searchParams) {\n    // Converts a URLSearchParams object to the same type used by the server when\n    // creating search params props, i.e. the type returned by Node's\n    // \"querystring\" module.\n    const result = {};\n    for (const [key, value] of searchParams.entries()){\n        if (result[key] === undefined) {\n            result[key] = value;\n        } else if (Array.isArray(result[key])) {\n            result[key].push(value);\n        } else {\n            result[key] = [\n                result[key],\n                value\n            ];\n        }\n    }\n    return result;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-params.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1wYXJhbXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBaUlnQkEsNEJBQTRCO2VBQTVCQTs7SUE0QkFDLDBCQUEwQjtlQUExQkE7O0lBd0NBQyx5QkFBeUI7ZUFBekJBOztJQTlKQUMsbUJBQW1CO2VBQW5CQTs7SUFsQkFDLGlCQUFpQjtlQUFqQkE7O0lBOEJBQyw0QkFBNEI7ZUFBNUJBOztJQXFLQUMsK0JBQStCO2VBQS9CQTs7SUFwQ0FDLDJCQUEyQjtlQUEzQkE7OztxQ0EvS1Q7a0RBQ2tDOzhDQUtsQztBQVVBLFNBQVNILGtCQUNkSSxRQUF5QztJQUV6QywwRUFBMEU7SUFDMUUsMkVBQTJFO0lBQzNFLDRFQUE0RTtJQUM1RSxNQUFNQyxpQkFBaUJELFNBQVNFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDQyxrQkFBQUEsMkJBQTJCO0lBQ3ZFLElBQUlILG1CQUFtQixNQUFNO1FBQzNCLE9BQ0VBLG1CQUFtQixLQUFLLEtBQUssTUFBTUE7SUFFdkM7SUFDQSwyRUFBMkU7SUFDM0UsNkJBQTZCO0lBQzdCLE9BQU9GLDRCQUE0QixJQUFJTSxJQUFJTCxTQUFTTSxHQUFHLEdBQ3BEQyxNQUFNO0FBQ1g7QUFFTyxTQUFTWixvQkFDZEssUUFBeUM7SUFFekMscUVBQXFFO0lBQ3JFLDZFQUE2RTtJQUM3RSx3RUFBd0U7SUFDeEUsTUFBTVEsZ0JBQWdCUixTQUFTRSxPQUFPLENBQUNDLEdBQUcsQ0FBQ00sa0JBQUFBLDBCQUEwQjtJQUNyRSxPQUFRRCxpQkFDTlQsNEJBQTRCLElBQUlNLElBQUlMLFNBQVNNLEdBQUcsR0FDN0NJLFFBQVE7QUFDZjtBQUVPLFNBQVNiLDZCQUNkYyxTQUFpQyxFQUNqQ0MsYUFBNEIsRUFDNUJDLFNBQWlCO0lBRWpCLDREQUE0RDtJQUM1RCxPQUFRRjtRQUNOLFlBQVk7UUFDWixLQUFLO1lBQUs7Z0JBQ1IsaUVBQWlFO2dCQUNqRSxt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ZS1wYXJhbXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBEeW5hbWljUGFyYW1UeXBlc1Nob3J0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLXR5cGVzJ1xuaW1wb3J0IHtcbiAgYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudCxcbiAgREVGQVVMVF9TRUdNRU5UX0tFWSxcbiAgUEFHRV9TRUdNRU5UX0tFWSxcbn0gZnJvbSAnLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHsgUk9PVF9TRUdNRU5UX1JFUVVFU1RfS0VZIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9zZWdtZW50LWNhY2hlL3NlZ21lbnQtdmFsdWUtZW5jb2RpbmcnXG5pbXBvcnQge1xuICBORVhUX1JFV1JJVFRFTl9QQVRIX0hFQURFUixcbiAgTkVYVF9SRVdSSVRURU5fUVVFUllfSEVBREVSLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbn0gZnJvbSAnLi9jb21wb25lbnRzL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB0eXBlIHtcbiAgTm9ybWFsaXplZFBhdGhuYW1lLFxuICBOb3JtYWxpemVkU2VhcmNoLFxufSBmcm9tICcuL2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZS9jYWNoZS1rZXknXG5pbXBvcnQgdHlwZSB7IFJTQ1Jlc3BvbnNlIH0gZnJvbSAnLi9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcblxuZXhwb3J0IHR5cGUgUm91dGVQYXJhbVZhbHVlID0gc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IG51bGxcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlcmVkU2VhcmNoKFxuICByZXNwb25zZTogUlNDUmVzcG9uc2U8dW5rbm93bj4gfCBSZXNwb25zZVxuKTogTm9ybWFsaXplZFNlYXJjaCB7XG4gIC8vIElmIHRoZSBzZXJ2ZXIgcGVyZm9ybWVkIGEgcmV3cml0ZSwgdGhlIHNlYXJjaCBwYXJhbXMgdXNlZCB0byByZW5kZXIgdGhlXG4gIC8vIHBhZ2Ugd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgcGFyYW1zIGluIHRoZSByZXF1ZXN0IFVSTC4gSW4gdGhpcyBjYXNlLFxuICAvLyB0aGUgcmVzcG9uc2Ugd2lsbCBpbmNsdWRlIGEgaGVhZGVyIHRoYXQgZ2l2ZXMgdGhlIHJld3JpdHRlbiBzZWFyY2ggcXVlcnkuXG4gIGNvbnN0IHJld3JpdHRlblF1ZXJ5ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoTkVYVF9SRVdSSVRURU5fUVVFUllfSEVBREVSKVxuICBpZiAocmV3cml0dGVuUXVlcnkgIT09IG51bGwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgcmV3cml0dGVuUXVlcnkgPT09ICcnID8gJycgOiAnPycgKyByZXdyaXR0ZW5RdWVyeVxuICAgICkgYXMgTm9ybWFsaXplZFNlYXJjaFxuICB9XG4gIC8vIElmIHRoZSBoZWFkZXIgaXMgbm90IHByZXNlbnQsIHRoZXJlIHdhcyBubyByZXdyaXRlLCBzbyB3ZSB1c2UgdGhlIHNlYXJjaFxuICAvLyBxdWVyeSBvZiB0aGUgcmVzcG9uc2UgVVJMLlxuICByZXR1cm4gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKG5ldyBVUkwocmVzcG9uc2UudXJsKSlcbiAgICAuc2VhcmNoIGFzIE5vcm1hbGl6ZWRTZWFyY2hcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlcmVkUGF0aG5hbWUoXG4gIHJlc3BvbnNlOiBSU0NSZXNwb25zZTx1bmtub3duPiB8IFJlc3BvbnNlXG4pOiBOb3JtYWxpemVkUGF0aG5hbWUge1xuICAvLyBJZiB0aGUgc2VydmVyIHBlcmZvcm1lZCBhIHJld3JpdGUsIHRoZSBwYXRobmFtZSB1c2VkIHRvIHJlbmRlciB0aGVcbiAgLy8gcGFnZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBwYXRobmFtZSBpbiB0aGUgcmVxdWVzdCBVUkwuIEluIHRoaXMgY2FzZSxcbiAgLy8gdGhlIHJlc3BvbnNlIHdpbGwgaW5jbHVkZSBhIGhlYWRlciB0aGF0IGdpdmVzIHRoZSByZXdyaXR0ZW4gcGF0aG5hbWUuXG4gIGNvbnN0IHJld3JpdHRlblBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldChORVhUX1JFV1JJVFRFTl9QQVRIX0hFQURFUilcbiAgcmV0dXJuIChyZXdyaXR0ZW5QYXRoID8/XG4gICAgdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKG5ldyBVUkwocmVzcG9uc2UudXJsKSlcbiAgICAgIC5wYXRobmFtZSkgYXMgTm9ybWFsaXplZFBhdGhuYW1lXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUR5bmFtaWNQYXJhbUZyb21VUkxQYXJ0KFxuICBwYXJhbVR5cGU6IER5bmFtaWNQYXJhbVR5cGVzU2hvcnQsXG4gIHBhdGhuYW1lUGFydHM6IEFycmF5PHN0cmluZz4sXG4gIHBhcnRJbmRleDogbnVtYmVyXG4pOiBSb3V0ZVBhcmFtVmFsdWUge1xuICAvLyBUaGlzIG5lZWRzIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBpbiBnZXQtZHluYW1pYy1wYXJhbS50cy5cbiAgc3dpdGNoIChwYXJhbVR5cGUpIHtcbiAgICAvLyBDYXRjaGFsbHNcbiAgICBjYXNlICdjJzoge1xuICAgICAgLy8gQ2F0Y2hhbGxzIHJlY2VpdmUgYWxsIHRoZSByZW1haW5pbmcgVVJMIHBhcnRzLiBJZiB0aGVyZSBhcmUgbm9cbiAgICAgIC8vIHJlbWFpbmluZyBwYXRobmFtZSBwYXJ0cywgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICAgICAgcmV0dXJuIHBhcnRJbmRleCA8IHBhdGhuYW1lUGFydHMubGVuZ3RoXG4gICAgICAgID8gcGF0aG5hbWVQYXJ0cy5zbGljZShwYXJ0SW5kZXgpLm1hcCgocykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHMpKVxuICAgICAgICA6IFtdXG4gICAgfVxuICAgIC8vIENhdGNoYWxsIGludGVyY2VwdGVkXG4gICAgY2FzZSAnY2koLi4pKC4uKSc6XG4gICAgY2FzZSAnY2koLiknOlxuICAgIGNhc2UgJ2NpKC4uKSc6XG4gICAgY2FzZSAnY2koLi4uKSc6IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHBhcmFtVHlwZS5sZW5ndGggLSAyXG4gICAgICByZXR1cm4gcGFydEluZGV4IDwgcGF0aG5hbWVQYXJ0cy5sZW5ndGhcbiAgICAgICAgPyBwYXRobmFtZVBhcnRzLnNsaWNlKHBhcnRJbmRleCkubWFwKChzLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHMuc2xpY2UocHJlZml4KSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzKVxuICAgICAgICAgIH0pXG4gICAgICAgIDogW11cbiAgICB9XG4gICAgLy8gT3B0aW9uYWwgY2F0Y2hhbGxzXG4gICAgY2FzZSAnb2MnOiB7XG4gICAgICAvLyBPcHRpb25hbCBjYXRjaGFsbHMgcmVjZWl2ZSBhbGwgdGhlIHJlbWFpbmluZyBVUkwgcGFydHMsIHVubGVzcyB0aGlzIGlzXG4gICAgICAvLyB0aGUgZW5kIG9mIHRoZSBwYXRobmFtZSwgaW4gd2hpY2ggY2FzZSB0aGV5IHJldHVybiBudWxsLlxuICAgICAgcmV0dXJuIHBhcnRJbmRleCA8IHBhdGhuYW1lUGFydHMubGVuZ3RoXG4gICAgICAgID8gcGF0aG5hbWVQYXJ0cy5zbGljZShwYXJ0SW5kZXgpLm1hcCgocykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHMpKVxuICAgICAgICA6IG51bGxcbiAgICB9XG4gICAgLy8gRHluYW1pY1xuICAgIGNhc2UgJ2QnOiB7XG4gICAgICBpZiAocGFydEluZGV4ID49IHBhdGhuYW1lUGFydHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRoZSByb3V0ZSB0cmVlIGV4cGVjdGVkIHRoZXJlIHRvIGJlIG1vcmUgcGFydHMgaW4gdGhlIFVSTCB0aGFuIHRoZXJlXG4gICAgICAgIC8vIGFjdHVhbGx5IGFyZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWYgdGhlIHgtbmV4dGpzLXJld3JpdHRlbi1wYXRoIGhlYWRlclxuICAgICAgICAvLyBpcyBpbmNvcnJlY3RseSBzZXQsIG9yIHBvdGVudGlhbGx5IGR1ZSB0byBidWcgaW4gTmV4dC5qcy4gVE9ETzpcbiAgICAgICAgLy8gU2hvdWxkIHRoaXMgYmUgYSBoYXJkIGVycm9yPyBEdXJpbmcgYSBwcmVmZXRjaCwgd2UgY2FuIGp1c3QgYWJvcnQuXG4gICAgICAgIC8vIER1cmluZyBhIGNsaWVudCBuYXZpZ2F0aW9uLCB3ZSBjb3VsZCB0cmlnZ2VyIGEgaGFyZCByZWZyZXNoLiBCdXQgaWZcbiAgICAgICAgLy8gaXQgaGFwcGVucyBkdXJpbmcgaW5pdGlhbCByZW5kZXIsIHdlIGRvbid0IHJlYWxseSBoYXZlIGFueVxuICAgICAgICAvLyByZWNvdmVyeSBvcHRpb25zLlxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocGF0aG5hbWVQYXJ0c1twYXJ0SW5kZXhdKVxuICAgIH1cbiAgICAvLyBEeW5hbWljIGludGVyY2VwdGVkXG4gICAgY2FzZSAnZGkoLi4pKC4uKSc6XG4gICAgY2FzZSAnZGkoLiknOlxuICAgIGNhc2UgJ2RpKC4uKSc6XG4gICAgY2FzZSAnZGkoLi4uKSc6IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHBhcmFtVHlwZS5sZW5ndGggLSAyXG4gICAgICBpZiAocGFydEluZGV4ID49IHBhdGhuYW1lUGFydHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRoZSByb3V0ZSB0cmVlIGV4cGVjdGVkIHRoZXJlIHRvIGJlIG1vcmUgcGFydHMgaW4gdGhlIFVSTCB0aGFuIHRoZXJlXG4gICAgICAgIC8vIGFjdHVhbGx5IGFyZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWYgdGhlIHgtbmV4dGpzLXJld3JpdHRlbi1wYXRoIGhlYWRlclxuICAgICAgICAvLyBpcyBpbmNvcnJlY3RseSBzZXQsIG9yIHBvdGVudGlhbGx5IGR1ZSB0byBidWcgaW4gTmV4dC5qcy4gVE9ETzpcbiAgICAgICAgLy8gU2hvdWxkIHRoaXMgYmUgYSBoYXJkIGVycm9yPyBEdXJpbmcgYSBwcmVmZXRjaCwgd2UgY2FuIGp1c3QgYWJvcnQuXG4gICAgICAgIC8vIER1cmluZyBhIGNsaWVudCBuYXZpZ2F0aW9uLCB3ZSBjb3VsZCB0cmlnZ2VyIGEgaGFyZCByZWZyZXNoLiBCdXQgaWZcbiAgICAgICAgLy8gaXQgaGFwcGVucyBkdXJpbmcgaW5pdGlhbCByZW5kZXIsIHdlIGRvbid0IHJlYWxseSBoYXZlIGFueVxuICAgICAgICAvLyByZWNvdmVyeSBvcHRpb25zLlxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwYXRobmFtZVBhcnRzW3BhcnRJbmRleF0uc2xpY2UocHJlZml4KSlcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcmFtVHlwZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgIHJldHVybiAnJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb2VzU3RhdGljU2VnbWVudEFwcGVhckluVVJMKHNlZ21lbnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBUaGlzIGlzIG5vdCBhIHBhcmFtZXRlcml6ZWQgc2VnbWVudDsgaG93ZXZlciwgd2UgbmVlZCB0byBkZXRlcm1pbmVcbiAgLy8gd2hldGhlciBvciBub3QgdGhpcyBzZWdtZW50IGFwcGVhcnMgaW4gdGhlIFVSTC4gRm9yIGV4YW1wbGUsIHRoaXMgcm91dGVcbiAgLy8gZ3JvdXBzIGRvIG5vdCBhcHBlYXIgaW4gdGhlIFVSTCwgc28gdGhleSBzaG91bGQgYmUgc2tpcHBlZC4gQW55IG90aGVyXG4gIC8vIHNwZWNpYWwgY2FzZXMgbXVzdCBiZSBoYW5kbGVkIGhlcmUuXG4gIC8vIFRPRE86IENvbnNpZGVyIGVuY29kaW5nIHRoaXMgZGlyZWN0bHkgaW50byB0aGUgcm91dGVyIHRyZWUgaW5zdGVhZCBvZlxuICAvLyBpbmZlcnJpbmcgaXQgb24gdGhlIGNsaWVudCBiYXNlZCBvbiB0aGUgc2VnbWVudCB0eXBlLiBTb21ldGhpbmcgbGlrZVxuICAvLyBhIGBkb2VzQXBwZWFySW5VUkxgIGZsYWcgaW4gRmxpZ2h0Um91dGVyU3RhdGUuXG4gIGlmIChcbiAgICBzZWdtZW50ID09PSBST09UX1NFR01FTlRfUkVRVUVTVF9LRVkgfHxcbiAgICAvLyBGb3Igc29tZSByZWFzb24sIHRoZSBsb2FkZXIgdHJlZSBzb21ldGltZXMgaW5jbHVkZXMgZXh0cmEgX19QQUdFX19cbiAgICAvLyBcImxheW91dHNcIiB3aGVuIHBhcnQgb2YgYSBwYXJhbGxlbCByb3V0ZS4gQnV0IGl0J3Mgbm90IGEgbGVhZiBub2RlLlxuICAgIC8vIE90aGVyd2lzZSwgd2Ugd291bGRuJ3QgbmVlZCB0aGlzIHNwZWNpYWwgY2FzZSBiZWNhdXNlIHBhZ2VzIGFyZVxuICAgIC8vIGFsd2F5cyBsZWFmIG5vZGVzLlxuICAgIC8vIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGUgbG9hZGVyIHByb2R1Y2VzIHRoZXNlIGZha2UgcGFnZSBzZWdtZW50cy5cbiAgICBzZWdtZW50LnN0YXJ0c1dpdGgoUEFHRV9TRUdNRU5UX0tFWSkgfHxcbiAgICAvLyBSb3V0ZSBncm91cHMuXG4gICAgKHNlZ21lbnRbMF0gPT09ICcoJyAmJiBzZWdtZW50LmVuZHNXaXRoKCcpJykpIHx8XG4gICAgc2VnbWVudCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSB8fFxuICAgIHNlZ21lbnQgPT09ICcvX25vdC1mb3VuZCdcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgLy8gQWxsIG90aGVyIHNlZ21lbnQgdHlwZXMgYXBwZWFyIGluIHRoZSBVUkxcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWNoZUtleUZvckR5bmFtaWNQYXJhbShcbiAgcGFyYW1WYWx1ZTogUm91dGVQYXJhbVZhbHVlLFxuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaFxuKTogc3RyaW5nIHtcbiAgLy8gVGhpcyBuZWVkcyB0byBtYXRjaCB0aGUgbG9naWMgaW4gZ2V0LWR5bmFtaWMtcGFyYW0udHMsIHVudGlsIHdlJ3JlIGFibGUgdG9cbiAgLy8gdW5pZnkgdGhlIHZhcmlvdXMgaW1wbGVtZW50YXRpb25zIHNvIHRoYXQgdGhlc2UgYXJlIGFsd2F5cyBjb21wdXRlZCBvblxuICAvLyB0aGUgY2xpZW50LlxuICBpZiAodHlwZW9mIHBhcmFtVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVE9ETzogUmVmYWN0b3Igb3IgcmVtb3ZlIHRoaXMgaGVscGVyIGZ1bmN0aW9uIHRvIGFjY2VwdCBhIHN0cmluZyByYXRoZXJcbiAgICAvLyB0aGFuIHRoZSB3aG9sZSBzZWdtZW50IHR5cGUuIEFsc28gd2UgY2FuIHByb2JhYmx5IGp1c3QgYXBwZW5kIHRoZVxuICAgIC8vIHNlYXJjaCBzdHJpbmcgaW5zdGVhZCBvZiB0dXJuaW5nIGl0IGludG8gSlNPTi5cbiAgICBjb25zdCBwYWdlU2VnbWVudFdpdGhTZWFyY2hQYXJhbXMgPSBhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50KFxuICAgICAgcGFyYW1WYWx1ZSxcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhuZXcgVVJMU2VhcmNoUGFyYW1zKHJlbmRlcmVkU2VhcmNoKSlcbiAgICApIGFzIHN0cmluZ1xuICAgIHJldHVybiBwYWdlU2VnbWVudFdpdGhTZWFyY2hQYXJhbXNcbiAgfSBlbHNlIGlmIChwYXJhbVZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcmFtVmFsdWUuam9pbignLycpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcih1cmw6IFVSTCk6IFVSTCB7XG4gIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwpXG4gIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnICYmXG4gICAgICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5wYXRobmFtZS5lbmRzV2l0aCgnLnR4dCcpXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVyc1xuICAgICAgY29uc3QgbGVuZ3RoID0gcGF0aG5hbWUuZW5kc1dpdGgoJy9pbmRleC50eHQnKSA/IDEwIDogNFxuICAgICAgLy8gU2xpY2Ugb2ZmIGAvaW5kZXgudHh0YCBvciBgLnR4dGAgZnJvbSB0aGUgZW5kIG9mIHRoZSBwYXRobmFtZVxuICAgICAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMucGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgwLCAtbGVuZ3RoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtVmFsdWVGcm9tQ2FjaGVLZXkoXG4gIHBhcmFtQ2FjaGVLZXk6IHN0cmluZyxcbiAgcGFyYW1UeXBlOiBEeW5hbWljUGFyYW1UeXBlc1Nob3J0XG4pIHtcbiAgLy8gVHVybiB0aGUgY2FjaGUga2V5IHN0cmluZyBzZW50IGJ5IHRoZSBzZXJ2ZXIgKGFzIHBhcnQgb2YgRmxpZ2h0Um91dGVyU3RhdGUpXG4gIC8vIGludG8gYSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gYHVzZVBhcmFtc2AgYW5kIGNsaWVudCBjb21wb25lbnRzLlxuICBjb25zdCBpc0NhdGNoQWxsID0gcGFyYW1UeXBlID09PSAnYycgfHwgcGFyYW1UeXBlID09PSAnb2MnXG4gIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgLy8gQ2F0Y2gtYWxsIHBhcmFtIGtleXMgYXJlIGEgY29uY2F0ZW5hdGlvbiBvZiB0aGUgcGF0aCBzZWdtZW50cy5cbiAgICAvLyBTZWUgZXF1aXZhbGVudCBsb2dpYyBpbiBgZ2V0U2VsZWN0ZWRQYXJhbXNgLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBqdXN0IHBhc3MgdGhlIGFycmF5IGRpcmVjdGx5LCByYXRoZXIgdGhhbiBjb25jYXRlbmF0ZVxuICAgIC8vIGl0IHRvIGEgc3RyaW5nIGFuZCB0aGVuIHNwbGl0IGl0IGJhY2sgdG8gYW4gYXJyYXkuIEl0IG5lZWRzIHRvIGJlIGFuXG4gICAgLy8gYXJyYXkgaW4gc29tZSBwbGFjZXMsIGxpa2Ugd2hlbiBwYXNzaW5nIGEga2V5IFJlYWN0LCBidXQgd2UgY2FuIGNvbnZlcnRcbiAgICAvLyBpdCBhdCBydW50aW1lIGluIHRob3NlIHBsYWNlcy5cbiAgICByZXR1cm4gcGFyYW1DYWNoZUtleS5zcGxpdCgnLycpXG4gIH1cbiAgcmV0dXJuIHBhcmFtQ2FjaGVLZXlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFNlYXJjaFBhcmFtc1RvUGFyc2VkVXJsUXVlcnkoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBQYXJzZWRVcmxRdWVyeSB7XG4gIC8vIENvbnZlcnRzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB0byB0aGUgc2FtZSB0eXBlIHVzZWQgYnkgdGhlIHNlcnZlciB3aGVuXG4gIC8vIGNyZWF0aW5nIHNlYXJjaCBwYXJhbXMgcHJvcHMsIGkuZS4gdGhlIHR5cGUgcmV0dXJuZWQgYnkgTm9kZSdzXG4gIC8vIFwicXVlcnlzdHJpbmdcIiBtb2R1bGUuXG4gIGNvbnN0IHJlc3VsdDogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzZWFyY2hQYXJhbXMuZW50cmllcygpKSB7XG4gICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IFtyZXN1bHRba2V5XSwgdmFsdWVdXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbiJdLCJuYW1lcyI6WyJkb2VzU3RhdGljU2VnbWVudEFwcGVhckluVVJMIiwiZ2V0Q2FjaGVLZXlGb3JEeW5hbWljUGFyYW0iLCJnZXRQYXJhbVZhbHVlRnJvbUNhY2hlS2V5IiwiZ2V0UmVuZGVyZWRQYXRobmFtZSIsImdldFJlbmRlcmVkU2VhcmNoIiwicGFyc2VEeW5hbWljUGFyYW1Gcm9tVVJMUGFydCIsInVybFNlYXJjaFBhcmFtc1RvUGFyc2VkVXJsUXVlcnkiLCJ1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIiLCJyZXNwb25zZSIsInJld3JpdHRlblF1ZXJ5IiwiaGVhZGVycyIsImdldCIsIk5FWFRfUkVXUklUVEVOX1FVRVJZX0hFQURFUiIsIlVSTCIsInVybCIsInNlYXJjaCIsInJld3JpdHRlblBhdGgiLCJORVhUX1JFV1JJVFRFTl9QQVRIX0hFQURFUiIsInBhdGhuYW1lIiwicGFyYW1UeXBlIiwicGF0aG5hbWVQYXJ0cyIsInBhcnRJbmRleCIsImxlbmd0aCIsInNsaWNlIiwibWFwIiwicyIsImVuY29kZVVSSUNvbXBvbmVudCIsInByZWZpeCIsImkiLCJzZWdtZW50IiwiUk9PVF9TRUdNRU5UX1JFUVVFU1RfS0VZIiwic3RhcnRzV2l0aCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJlbmRzV2l0aCIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJwYXJhbVZhbHVlIiwicmVuZGVyZWRTZWFyY2giLCJwYWdlU2VnbWVudFdpdGhTZWFyY2hQYXJhbXMiLCJhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJqb2luIiwidXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMiLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIl9fTkVYVF9DT05GSUdfT1VUUFVUIiwicGFyYW1DYWNoZUtleSIsImlzQ2F0Y2hBbGwiLCJzcGxpdCIsInJlc3VsdCIsImtleSIsInZhbHVlIiwiZW50cmllcyIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/route-params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NavigationPromisesContext: function() {\n        return NavigationPromisesContext;\n    },\n    PathParamsContext: function() {\n        return PathParamsContext;\n    },\n    PathnameContext: function() {\n        return PathnameContext;\n    },\n    ReadonlyURLSearchParams: function() {\n        return _readonlyurlsearchparams.ReadonlyURLSearchParams;\n    },\n    SearchParamsContext: function() {\n        return SearchParamsContext;\n    },\n    createDevToolsInstrumentedPromise: function() {\n        return createDevToolsInstrumentedPromise;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\nconst _readonlyurlsearchparams = __webpack_require__(/*! ../../client/components/readonly-url-search-params */ \"(app-pages-browser)/../node_modules/next/dist/client/components/readonly-url-search-params.js\");\nconst SearchParamsContext = (0, _react.createContext)(null);\nconst PathnameContext = (0, _react.createContext)(null);\nconst PathParamsContext = (0, _react.createContext)(null);\nconst NavigationPromisesContext = (0, _react.createContext)(null);\nfunction createDevToolsInstrumentedPromise(displayName, value) {\n    const promise = Promise.resolve(value);\n    promise.status = 'fulfilled';\n    promise.value = value;\n    promise.displayName = `${displayName} (SSR)`;\n    return promise;\n}\nif (true) {\n    SearchParamsContext.displayName = 'SearchParamsContext';\n    PathnameContext.displayName = 'PathnameContext';\n    PathParamsContext.displayName = 'PathParamsContext';\n    NavigationPromisesContext.displayName = 'NavigationPromisesContext';\n} //# sourceMappingURL=hooks-client-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBOEJhQSx5QkFBeUI7ZUFBekJBOztJQXRCQUMsaUJBQWlCO2VBQWpCQTs7SUFEQUMsZUFBZTtlQUFmQTs7SUF3Q0pDLHVCQUF1QjtlQUF2QkEseUJBQUFBLHVCQUF1Qjs7SUF6Q25CQyxtQkFBbUI7ZUFBbkJBOztJQThCR0MsaUNBQWlDO2VBQWpDQTs7O21DQWxDYztxREFFVTtBQUVqQyxNQUFNRCxzQkFBc0JFLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQXNDO0FBQ2xFLE1BQU1KLGtCQUFrQkksQ0FBQUEsR0FBQUEsT0FBQUEsYUFBQUEsRUFBNkI7QUFDckQsTUFBTUwsb0JBQW9CSyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFBQSxFQUE2QjtBQXNCdkQsTUFBTU4sNEJBQ1hNLENBQUFBLEdBQUFBLE9BQUFBLGFBQWEsRUFBNEI7QUFLcEMsU0FBU0Qsa0NBQ2RFLFdBQW1CLEVBQ25CQyxLQUFRO0lBRVIsTUFBTUMsVUFBVUMsUUFBUUMsT0FBTyxDQUFDSDtJQUNoQ0MsUUFBUUcsTUFBTSxHQUFHO0lBQ2pCSCxRQUFRRCxLQUFLLEdBQUdBO0lBQ2hCQyxRQUFRRixXQUFXLEdBQUcsR0FBR0EsWUFBWSxNQUFNLENBQUM7SUFDNUMsT0FBT0U7QUFDVDtBQUlBLElBQUlJLElBQW9CLEVBQW1CO0lBQ3pDVCxvQkFBb0JHLFdBQVcsR0FBRztJQUNsQ0wsZ0JBQWdCSyxXQUFXLEdBQUc7SUFDOUJOLGtCQUFrQk0sV0FBVyxHQUFHO0lBQ2hDUCwwQkFBMEJPLFdBQVcsR0FBRztBQUMxQyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpdGFsaXl1bGl0b3Zza3kvc3JjL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuaW1wb3J0IHsgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9yZWFkb25seS11cmwtc2VhcmNoLXBhcmFtcydcblxuZXhwb3J0IGNvbnN0IFNlYXJjaFBhcmFtc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVSTFNlYXJjaFBhcmFtcyB8IG51bGw+KG51bGwpXG5leHBvcnQgY29uc3QgUGF0aG5hbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxzdHJpbmcgfCBudWxsPihudWxsKVxuZXhwb3J0IGNvbnN0IFBhdGhQYXJhbXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxQYXJhbXMgfCBudWxsPihudWxsKVxuXG4vLyBEZXYtb25seSBjb250ZXh0IGZvciBTdXNwZW5zZSBEZXZUb29scyBpbnN0cnVtZW50YXRpb25cbi8vIFRoZXNlIHByb21pc2VzIGFyZSB1c2VkIHRvIHRyYWNrIG5hdmlnYXRpb24gaG9vayB1c2FnZSBpbiBSZWFjdCBEZXZUb29sc1xuZXhwb3J0IHR5cGUgSW5zdHJ1bWVudGVkUHJvbWlzZTxUPiA9IFByb21pc2U8VD4gJiB7XG4gIHN0YXR1czogJ2Z1bGZpbGxlZCdcbiAgdmFsdWU6IFRcbiAgZGlzcGxheU5hbWU6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uUHJvbWlzZXMgPSB7XG4gIHBhdGhuYW1lOiBJbnN0cnVtZW50ZWRQcm9taXNlPHN0cmluZz5cbiAgc2VhcmNoUGFyYW1zOiBJbnN0cnVtZW50ZWRQcm9taXNlPFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zPlxuICBwYXJhbXM6IEluc3RydW1lbnRlZFByb21pc2U8UGFyYW1zPlxuICAvLyBMYXlvdXQgc2VnbWVudCBob29rcyAodXBkYXRlZCBhdCBlYWNoIGxheW91dCBib3VuZGFyeSlcbiAgc2VsZWN0ZWRMYXlvdXRTZWdtZW50UHJvbWlzZXM/OiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIEluc3RydW1lbnRlZFByb21pc2U8c3RyaW5nIHwgbnVsbD5cbiAgPlxuICBzZWxlY3RlZExheW91dFNlZ21lbnRzUHJvbWlzZXM/OiBNYXA8c3RyaW5nLCBJbnN0cnVtZW50ZWRQcm9taXNlPHN0cmluZ1tdPj5cbn1cblxuZXhwb3J0IGNvbnN0IE5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQgPVxuICBjcmVhdGVDb250ZXh0PE5hdmlnYXRpb25Qcm9taXNlcyB8IG51bGw+KG51bGwpXG5cbi8vIENyZWF0ZXMgYW4gaW5zdHJ1bWVudGVkIHByb21pc2UgZm9yIFN1c3BlbnNlIERldlRvb2xzXG4vLyBUaGVzZSBwcm9taXNlcyBhcmUgYWx3YXlzIGZ1bGZpbGxlZCBhbmQgZXhpc3QgcHVyZWx5IGZvclxuLy8gdHJhY2tpbmcgaW4gUmVhY3QncyBTdXNwZW5zZSBEZXZUb29scy5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZXZUb29sc0luc3RydW1lbnRlZFByb21pc2U8VD4oXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcsXG4gIHZhbHVlOiBUXG4pOiBJbnN0cnVtZW50ZWRQcm9taXNlPFQ+IHtcbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkgYXMgSW5zdHJ1bWVudGVkUHJvbWlzZTxUPlxuICBwcm9taXNlLnN0YXR1cyA9ICdmdWxmaWxsZWQnXG4gIHByb21pc2UudmFsdWUgPSB2YWx1ZVxuICBwcm9taXNlLmRpc3BsYXlOYW1lID0gYCR7ZGlzcGxheU5hbWV9IChTU1IpYFxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5leHBvcnQgeyBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyB9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFNlYXJjaFBhcmFtc0NvbnRleHQuZGlzcGxheU5hbWUgPSAnU2VhcmNoUGFyYW1zQ29udGV4dCdcbiAgUGF0aG5hbWVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1BhdGhuYW1lQ29udGV4dCdcbiAgUGF0aFBhcmFtc0NvbnRleHQuZGlzcGxheU5hbWUgPSAnUGF0aFBhcmFtc0NvbnRleHQnXG4gIE5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQuZGlzcGxheU5hbWUgPSAnTmF2aWdhdGlvblByb21pc2VzQ29udGV4dCdcbn1cbiJdLCJuYW1lcyI6WyJOYXZpZ2F0aW9uUHJvbWlzZXNDb250ZXh0IiwiUGF0aFBhcmFtc0NvbnRleHQiLCJQYXRobmFtZUNvbnRleHQiLCJSZWFkb25seVVSTFNlYXJjaFBhcmFtcyIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJjcmVhdGVEZXZUb29sc0luc3RydW1lbnRlZFByb21pc2UiLCJjcmVhdGVDb250ZXh0IiwiZGlzcGxheU5hbWUiLCJ2YWx1ZSIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN0YXR1cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\n"));

/***/ })

});